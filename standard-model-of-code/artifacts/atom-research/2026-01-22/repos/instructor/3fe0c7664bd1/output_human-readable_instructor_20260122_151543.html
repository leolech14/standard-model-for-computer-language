<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Collider v4.0.0</title>
    <style>
        /* ═══════════════════════════════════════════════════════════════════
           COLLIDER UI - Dual Sidebar Layout
           ═══════════════════════════════════════════════════════════════════ */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --surface: rgba(15, 15, 22, 0.85);
            --surface-hover: rgba(25, 25, 35, 0.9);
            --border: rgba(255, 255, 255, 0.08);
            --border-accent: rgba(74, 158, 255, 0.3);
            --text: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.5);
            --text-muted: rgba(255, 255, 255, 0.3);
            --accent: #4a9eff;
            --accent-dim: rgba(74, 158, 255, 0.15);
            --accent-glow: rgba(74, 158, 255, 0.25);
            --green: #5a9a70;
            --yellow: #a09060;
            --red: #b07070;
            --cyan: #7090a0;
            --sidebar-width: 300px;
            --right-panel-width: 280px;
            --min-sidebar-width: 240px;
            --max-sidebar-width: 500px;
            --header-height: 48px;
            --radius: 8px;
            --radius-sm: 4px;
            --glass: blur(12px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            font-size: 12px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LOADER
           ═══════════════════════════════════════════════════════════════════ */
        #loader {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 9999;
            font-size: 14px;
            letter-spacing: 2px;
        }

        #loader-status {
            font-size: 11px;
            opacity: 0.5;
        }

        /* ═══════════════════════════════════════════════════════════════════
           HEADER - Top bar spanning full width
           ═══════════════════════════════════════════════════════════════════ */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 24px;
            z-index: 200;
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 1px;
            color: var(--accent);
        }

        .logo span {
            opacity: 0.5;
            font-size: 10px;
            margin-left: 6px;
            color: var(--text);
        }

        .header-stats {
            display: flex;
            gap: 20px;
            font-size: 11px;
        }

        .stat {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .stat-label {
            opacity: 0.4;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            color: var(--cyan);
        }

        .target-name {
            margin-left: auto;
            font-size: 11px;
            opacity: 0.5;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ═══════════════════════════════════════════════════════════════════
           MAIN LAYOUT - Graph container
           ═══════════════════════════════════════════════════════════════════ */
        #3d-graph {
            position: fixed;
            top: var(--header-height);
            left: var(--sidebar-width);
            right: var(--right-panel-width);
            bottom: 0;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LEFT SIDEBAR - Controls & Filters
           ═══════════════════════════════════════════════════════════════════ */
        #left-sidebar {
            position: fixed;
            top: var(--header-height);
            left: 0;
            bottom: 0;
            width: var(--sidebar-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
        }

        #left-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #left-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #left-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           RIGHT SIDEBAR - Info Panels
           ═══════════════════════════════════════════════════════════════════ */
        #right-sidebar {
            position: fixed;
            top: var(--header-height);
            right: 0;
            bottom: 0;
            width: var(--right-panel-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #right-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #right-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #right-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SIDEBAR RESIZE DIVIDERS - Horizontal drag handles
           ═══════════════════════════════════════════════════════════════════ */
        .sidebar-resize-handle {
            position: fixed;
            top: var(--header-height);
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 101;
            background: transparent;
            transition: background 0.15s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.25);
        }

        .sidebar-resize-handle.left {
            left: calc(var(--sidebar-width) - 3px);
        }

        .sidebar-resize-handle.right {
            right: calc(var(--right-panel-width) - 3px);
        }

        /* Visual indicator line */
        .sidebar-resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 40px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .sidebar-resize-handle:hover::after {
            opacity: 1;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION - Collapsible sections
           ═══════════════════════════════════════════════════════════════════ */
        .section {
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            padding: 12px 14px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.15s;
        }

        .section-header:hover {
            opacity: 0.9;
            background: var(--surface-hover);
        }

        .section-header .arrow {
            transition: transform 0.2s;
            font-size: 8px;
        }

        .section-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        /* PRIME SECTIONS - Highlighted config sections (muted) */
        .section.prime {
            background: linear-gradient(180deg, rgba(100, 110, 130, 0.03) 0%, transparent 100%);
            border-left: 2px solid rgba(100, 110, 130, 0.3);
        }

        .section.prime .section-header {
            opacity: 0.75;
            color: var(--text-secondary);
        }

        .section.prime .section-header:hover {
            opacity: 0.9;
        }

        .section-content {
            padding: 8px 14px 14px;
            overflow-y: auto;
            transition: max-height 0.2s ease;
        }

        .section-content.collapsed {
            display: none;
        }

        /* RESIZABLE SECTIONS - Vertical drag handles */
        .section-resize-handle {
            height: 4px;
            cursor: ns-resize;
            background: transparent;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
            position: relative;
        }

        .section-resize-handle:hover,
        .section-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.2);
        }

        .section-resize-handle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 2px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .section-resize-handle:hover::after {
            opacity: 1;
        }

        /* Section content height constraints when resizing */
        .section-content.resizable {
            min-height: 60px;
            max-height: 400px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           VIEW MODE TOGGLE - ATOMS vs FILES (top of left sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            padding: 8px 10px;
            background: linear-gradient(180deg, rgba(74, 158, 255, 0.08) 0%, rgba(74, 158, 255, 0.02) 100%);
            border-bottom: 2px solid var(--accent);
        }

        .view-mode-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .view-mode-btn:first-child {
            border-radius: var(--radius-sm) 0 0 var(--radius-sm);
            border-right: none;
        }

        .view-mode-btn:last-child {
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        }

        .view-mode-btn:hover {
            background: rgba(74, 158, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        .view-mode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
        }

        .view-mode-icon {
            font-size: 14px;
        }

        .view-mode-label {
            font-size: 10px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════════════
           BUTTON GRID - For presets and actions
           ═══════════════════════════════════════════════════════════════════ */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .btn-grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .btn-grid-4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .btn-grid-6 {
            grid-template-columns: repeat(6, 1fr);
        }

        .btn {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            font-size: 9px;
            font-weight: 500;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: var(--border-accent);
        }

        .btn.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        /* Icon buttons */
        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SLIDERS
           ═══════════════════════════════════════════════════════════════════ */
        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .slider-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .slider-label {
            opacity: 0.6;
        }

        .slider-value {
            display: none;
            /* Replaced by input */
        }

        .number-input {
            width: 48px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--cyan);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 10px;
            padding: 2px 4px;
            text-align: right;
            -moz-appearance: textfield;
        }

        .number-input::-webkit-outer-spin-button,
        .number-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.4);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px var(--accent-glow);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }

        /* ═══════════════════════════════════════════════════════════════════
           FILTER CHIPS
           ═══════════════════════════════════════════════════════════════════ */
        .filter-group {
            margin-bottom: 12px;
        }

        .filter-group:last-child {
            margin-bottom: 0;
        }

        .filter-label {
            font-size: 9px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .chip {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 14px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .chip.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
        }

        .chip .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOGGLE SWITCHES
           ═══════════════════════════════════════════════════════════════════ */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            padding: 6px 0;
        }

        .toggle-row .toggle-label {
            opacity: 0.7;
        }

        .toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text);
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle.active::after {
            transform: translateX(16px);
        }

        /* ═══════════════════════════════════════════════════════════════════
           INFO PANEL - Right sidebar node info
           ═══════════════════════════════════════════════════════════════════ */
        .info-panel {
            padding: 14px;
            border-bottom: 1px solid var(--border);
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .info-panel-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .node-info {
            display: none;
        }

        .node-info.visible {
            display: block;
        }

        .node-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
            word-break: break-all;
            color: var(--cyan);
        }

        .node-kind {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row .label {
            opacity: 0.4;
        }

        .info-row .value {
            text-align: right;
        }

        .node-file {
            font-size: 9px;
            opacity: 0.3;
            margin-top: 10px;
            word-break: break-all;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .placeholder-text {
            font-size: 10px;
            opacity: 0.3;
            text-align: center;
            padding: 20px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SELECTION PANEL
           ═══════════════════════════════════════════════════════════════════ */
        .selection-panel {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
        }

        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .selection-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .selection-count {
            font-size: 9px;
            padding: 2px 8px;
            background: var(--accent-dim);
            border-radius: 10px;
            color: var(--accent);
        }

        .selection-clear {
            font-size: 9px;
            padding: 4px 8px;
            background: none;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            cursor: pointer;
        }

        .selection-clear:hover {
            color: var(--text);
            border-color: var(--text-dim);
        }

        .selection-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .selection-item {
            font-size: 10px;
            padding: 6px 8px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            margin-bottom: 2px;
            background: rgba(255, 255, 255, 0.02);
        }

        .selection-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--accent);
        }

        /* ═══════════════════════════════════════════════════════════════════
           STATS PANEL (bottom of right sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .stats-panel {
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid var(--border);
            margin-top: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stats-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-sm);
        }

        .stats-item .value {
            font-size: 16px;
            font-weight: 600;
            color: var(--cyan);
            font-variant-numeric: tabular-nums;
        }

        .stats-item .label {
            font-size: 8px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           COLOR PANELS (right sidebar color controls)
           ═══════════════════════════════════════════════════════════════════ */
        .color-panel,
        .schemes-panel {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
        }

        .color-panel .section-content,
        .schemes-panel .section-content {
            padding: 0;
            margin-top: 10px;
        }

        .color-panel .btn-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .color-panel .btn {
            padding: 6px 8px;
            font-size: 9px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .color-panel .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .color-panel .btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        /* Collapsible header for schemes panel */
        .info-panel-header.collapsible {
            cursor: pointer;
            user-select: none;
        }

        .info-panel-header.collapsible:hover {
            opacity: 0.9;
        }

        .info-panel-header .collapse-icon {
            font-size: 8px;
            transition: transform 0.2s;
        }

        .info-panel-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .schemes-panel .section-content {
            max-height: 250px;
            overflow-y: auto;
        }

        .schemes-panel .section-content::-webkit-scrollbar {
            width: 4px;
        }

        .schemes-panel .section-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .schemes-panel .section-content.collapsed {
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           PERFORMANCE HUD (optional overlay)
           ═══════════════════════════════════════════════════════════════════ */
        #perf-hud {
            position: fixed;
            top: calc(var(--header-height) + 8px);
            left: calc(var(--sidebar-width) + 8px);
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-family: 'SF Mono', Monaco, monospace;
            z-index: 150;
            display: none;
        }

        #perf-hud.visible {
            display: block;
        }

        .perf-row {
            display: flex;
            gap: 12px;
        }

        .perf-label {
            opacity: 0.5;
        }

        .perf-value {
            font-variant-numeric: tabular-nums;
        }

        .perf-good {
            color: var(--green);
        }

        .perf-warn {
            color: var(--yellow);
        }

        .perf-bad {
            color: var(--red);
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════════════ */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--surface);
            border: 1px solid var(--border-accent);
            padding: 12px 24px;
            border-radius: var(--radius);
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Selection box for drag select */
        #selection-box {
            position: fixed;
            border: 1px solid var(--accent);
            background: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION-SPECIFIC STYLING
           ═══════════════════════════════════════════════════════════════════ */

        /* Color mode buttons with color indicators */
        .color-btn {
            position: relative;
        }

        .color-btn::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .color-btn[data-preset="tier"]::before {
            background: #ff6b6b;
        }

        .color-btn[data-preset="family"]::before {
            background: #4ecdc4;
        }

        .color-btn[data-preset="layer"]::before {
            background: #95e1d3;
        }

        .color-btn[data-preset="ring"]::before {
            background: #f9ed69;
        }

        .color-btn[data-preset="file"]::before {
            background: #a8e6cf;
        }

        .color-btn[data-preset="flow"]::before {
            background: #dcd6f7;
        }

        /* Layout buttons with mini icons */
        .layout-btn {
            height: 32px;
        }
    </style>

    <script>
        window.process = window.process || { env: { NODE_ENV: "production" } };
        window.global = window.global || window;
    </script>
    <!-- THREE.js r149 (last version without deprecation warning) + 3d-force-graph -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
</head>

<body>
    <!-- Loader -->
    <div id="loader">
        <div>INITIALIZING...</div>
        <div id="loader-status">Loading data...</div>
    </div>

    <!-- Header -->
    <div id="header">
        <div class="logo">COLLIDER <span>v4.0.0</span></div>
        <div class="header-stats">
            <div class="stat">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="stat-nodes">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="stat-edges">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Entropy</span>
                <span class="stat-value" id="stat-entropy">--</span>
            </div>
        </div>
        <div class="target-name" id="target-name"></div>
    </div>

    <!-- Left Sidebar -->
    <div id="left-sidebar">
        <!-- VIEW MODE TOGGLE - TOP PRIORITY -->
        <div class="view-mode-toggle" id="view-mode-toggle">
            <button class="view-mode-btn active" data-mode="atoms">
                <span class="view-mode-icon">◉</span>
                <span class="view-mode-label">ATOMS</span>
            </button>
            <button class="view-mode-btn" data-mode="files">
                <span class="view-mode-icon">◫</span>
                <span class="view-mode-label">FILES</span>
            </button>
        </div>

        <!-- MAPPING CONTROL (Docked) -->
        <div class="section prime" id="control-bar-container">
            <!-- Injected by control-bar.js -->
        </div>

        <!-- NODE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="node-config">
                <span>⬢ Node Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-node-config">
                <!-- Size Mode Selector -->
                <div class="filter-group">
                    <div class="filter-label">Size Mode</div>
                    <div class="btn-grid btn-grid-4">
                        <button class="btn active" data-size-mode="uniform">Uniform</button>
                        <button class="btn" data-size-mode="degree">Degree</button>
                        <button class="btn" data-size-mode="fanout">Fanout</button>
                        <button class="btn" data-size-mode="complexity">Complex</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Base Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-size" min="0.2" max="4" step="0.1" value="1">
                        <input type="number" id="cfg-node-size-num" class="number-input" min="0.2" max="4" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-opacity" min="0.1" max="1" step="0.05" value="1">
                        <input type="number" id="cfg-node-opacity-num" class="number-input" min="0.1" max="1"
                            step="0.05" value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Resolution</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-res" min="4" max="32" step="4" value="8">
                        <input type="number" id="cfg-node-res-num" class="number-input" min="4" max="32" step="4"
                            value="8">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Label Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-label-size" min="0" max="3" step="0.1" value="1">
                        <input type="number" id="cfg-label-size-num" class="number-input" min="0" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="cfg-toggle-labels"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight Selected</span>
                    <div class="toggle active" id="cfg-toggle-highlight"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Pulse Animation</span>
                    <div class="toggle" id="cfg-toggle-pulse"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">3D Depth Shading</span>
                    <div class="toggle active" id="cfg-toggle-depth"></div>
                </div>
            </div>
        </div>

        <!-- EDGE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="edge-config">
                <span>⟷ Edge Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-edge-config">
                <!-- Edge Style Selector -->
                <div class="filter-group">
                    <div class="filter-label">Edge Style</div>
                    <div class="btn-grid">
                        <button class="btn active" data-edge-style="solid">Solid</button>
                        <button class="btn" data-edge-style="dashed">Dashed</button>
                        <button class="btn" data-edge-style="particle">Particle</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-opacity" min="0" max="1" step="0.05" value="0.6">
                        <input type="number" id="cfg-edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.6">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Width</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-width" min="0.2" max="5" step="0.2" value="1.5">
                        <input type="number" id="cfg-edge-width-num" class="number-input" min="0.2" max="5" step="0.1"
                            value="1.5">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Curvature</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-curve" min="0" max="1" step="0.05" value="0">
                        <input type="number" id="cfg-edge-curve-num" class="number-input" min="0" max="1" step="0.05"
                            value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Speed</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-speed" min="0" max="0.05" step="0.005" value="0.01">
                        <input type="number" id="cfg-particle-speed-num" class="number-input" min="0" max="0.05"
                            step="0.005" value="0.01">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Density</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-count" min="0" max="10" step="1" value="0">
                        <input type="number" id="cfg-particle-count-num" class="number-input" min="0" max="10" step="1"
                            value="0">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Arrows</span>
                    <div class="toggle" id="cfg-toggle-arrows"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Gradient Colors</span>
                    <div class="toggle active" id="cfg-toggle-gradient"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight on Hover</span>
                    <div class="toggle active" id="cfg-toggle-edge-hover"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Codome Boundaries</span>
                    <div class="toggle" id="cfg-toggle-codome"></div>
                </div>
            </div>
        </div>

        <!-- LAYOUT -->
        <div class="section">
            <div class="section-header" data-section="layout">
                <span>Layout</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-layout">
                <div class="btn-grid">
                    <button class="btn layout-btn active" data-layout="force">Force</button>
                    <button class="btn layout-btn" data-layout="radial">Radial</button>
                    <button class="btn layout-btn" data-layout="orbital">Orbital</button>
                    <button class="btn layout-btn" data-layout="sphere">Sphere</button>
                    <button class="btn layout-btn" data-layout="grid">Grid</button>
                    <button class="btn layout-btn" data-layout="spiral">Spiral</button>
                </div>
            </div>
        </div>

        <!-- PHYSICS -->
        <div class="section">
            <div class="section-header" data-section="physics">
                <span>Physics</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-physics">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Repulsion</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-charge" min="-500" max="0" value="-120">
                        <input type="number" id="physics-charge-num" class="number-input" min="-500" max="0"
                            value="-120">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Link Distance</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-link" min="10" max="200" value="50">
                        <input type="number" id="physics-link-num" class="number-input" min="10" max="200" value="50">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Center Pull</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-center" min="0" max="0.5" step="0.01" value="0.05">
                        <input type="number" id="physics-center-num" class="number-input" min="0" max="0.5" step="0.01"
                            value="0.05">
                    </div>
                </div>
                <div class="btn-grid btn-grid-4" style="margin-top: 8px;">
                    <button class="btn" data-physics="default">Def</button>
                    <button class="btn" data-physics="tight">Tight</button>
                    <button class="btn" data-physics="loose">Loose</button>
                    <button class="btn" data-physics="explosive">Boom</button>
                </div>
            </div>
        </div>

        <!-- APPEARANCE -->
        <div class="section">
            <div class="section-header" data-section="appearance">
                <span>Appearance</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-appearance">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Node Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="node-size" min="0.2" max="3" step="0.1" value="1">
                        <input type="number" id="node-size-num" class="number-input" min="0.2" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Edge Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="edge-opacity" min="0" max="1" step="0.05" value="0.4">
                        <input type="number" id="edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.4">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="toggle-labels"></div>
                </div>
                <!-- Starfield toggle REMOVED - nodes ARE the stars -->
            </div>
        </div>

        <!-- FILTERS -->
        <div class="section">
            <div class="section-header" data-section="filters">
                <span>Filters</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-filters">
                <div class="filter-group">
                    <div class="filter-label">Tiers</div>
                    <div class="chips" id="filter-tiers"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Rings</div>
                    <div class="chips" id="filter-rings"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Edge Types</div>
                    <div class="chips" id="filter-edges"></div>
                </div>
            </div>
        </div>

        <!-- ACTIONS -->
        <div class="section">
            <div class="section-header collapsed" data-section="actions">
                <span>Actions</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content collapsed" id="section-actions">
                <div class="btn-grid btn-grid-2">
                    <button class="btn" id="btn-reset">Reset View</button>
                    <button class="btn" id="btn-screenshot">Screenshot</button>
                    <button class="btn" id="btn-2d">Toggle 2D</button>
                    <button class="btn" id="btn-freeze">Freeze</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Graph Container -->
    <div id="3d-graph"></div>

    <!-- Sidebar Resize Handles -->
    <div class="sidebar-resize-handle left" id="left-resize-handle"></div>
    <div class="sidebar-resize-handle right" id="right-resize-handle"></div>

    <!-- Right Sidebar -->
    <div id="right-sidebar">
        <!-- Hover Info Panel -->
        <div class="info-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Node Info</span>
            </div>
            <div class="node-info" id="hover-panel">
                <div class="node-name" id="hover-name">Node Name</div>
                <div class="node-kind" id="hover-kind">function</div>
                <div class="info-row"><span class="label">Atom</span><span class="value" id="hover-atom">--</span></div>
                <div class="info-row"><span class="label">Family</span><span class="value" id="hover-family">--</span>
                </div>
                <div class="info-row"><span class="label">Ring</span><span class="value" id="hover-ring">--</span></div>
                <div class="info-row"><span class="label">Tier</span><span class="value" id="hover-tier">--</span></div>
                <div class="info-row"><span class="label">Role</span><span class="value" id="hover-role">--</span></div>
                <div class="node-file" id="hover-file"></div>
            </div>
            <div class="placeholder-text" id="hover-placeholder">Hover over a node to see details</div>
        </div>

        <!-- Selection Panel -->
        <div class="selection-panel">
            <div class="selection-header">
                <span class="selection-title">Selection</span>
                <span class="selection-count" id="selection-count">0</span>
            </div>
            <div id="selection-actions" style="display: none; margin-bottom: 10px;">
                <button class="selection-clear" id="selection-clear">Clear</button>
            </div>
            <div class="selection-list" id="selection-list">
                <div class="placeholder-text">Click nodes to select</div>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="value" id="stats-nodes">0</div>
                    <div class="label">Visible</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-edges">0</div>
                    <div class="label">Edges</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-files">0</div>
                    <div class="label">Files</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-density">--</div>
                    <div class="label">Density</div>
                </div>
            </div>
        </div>

        <!-- COLOR SCHEMES (33 Named Gradients) - Primary color selection -->
        <div class="info-panel schemes-panel">
            <div class="info-panel-header collapsible" data-target="section-schemes">
                <span class="info-panel-title">Color Schemes</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="section-content" id="section-schemes">
                <!-- Populated dynamically by sidebar.js -->
            </div>
        </div>

        <!-- COLOR MODE (Presets) - What dimension to color by -->
        <div class="info-panel color-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Color Mode</span>
            </div>
            <div class="section-content" id="section-color">
                <div class="btn-grid btn-grid-3">
                    <button class="btn color-btn active" data-preset="tier">Tier</button>
                    <button class="btn color-btn" data-preset="family">Family</button>
                    <button class="btn color-btn" data-preset="layer">Layer</button>
                    <button class="btn color-btn" data-preset="ring">Ring</button>
                    <button class="btn color-btn" data-preset="file">File</button>
                    <button class="btn color-btn" data-preset="flow">Flow</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance HUD -->
    <div id="perf-hud">
        <div class="perf-row">
            <span class="perf-label">FPS:</span>
            <span class="perf-value" id="perf-fps">60</span>
            <span class="perf-label">Frame:</span>
            <span class="perf-value" id="perf-frame">0ms</span>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast"></div>

    <!-- Core Application Injection -->
    <div id="selection-box"></div>

    <!-- INLINED MODULES FOR GENERATED REPORTS -->
    <script>
        /**
         * @module HardwareInfo
         * (Inlined for standalone report generation)
         */
        const HardwareInfo = (function () {
            'use strict';
            let _info = null;

            function getInfo() {
                if (_info) return _info;
                _info = {
                    gpu: 'Unknown GPU', vendor: 'Unknown Vendor', renderer: 'Unknown Renderer',
                    memory: { jsHeapSizeLimit: 0, totalJSHeapSize: 0, usedJSHeapSize: 0 },
                    limits: { maxTextureSize: 0, maxCubeMapSize: 0, maxRenderBufferSize: 0 },
                    context: 'webgl'
                };
                if (performance && performance.memory) _updateMemory();

                try {
                    const canvas = document.createElement('canvas');
                    let gl = canvas.getContext('webgl');
                    if (!gl) { gl = canvas.getContext('experimental-webgl'); _info.context = 'experimental-webgl'; }
                    else { _info.context = 'webgl'; }
                    const gl2 = canvas.getContext('webgl2');
                    if (gl2) { gl = gl2; _info.context = 'webgl2'; }

                    if (gl) {
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        if (debugInfo) {
                            _info.vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                            _info.renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                            _info.gpu = _info.renderer;
                        } else {
                            _info.renderer = gl.getParameter(gl.RENDERER);
                            _info.vendor = gl.getParameter(gl.VENDOR);
                        }
                        _info.limits.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                        _info.limits.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                        _info.limits.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
                    }
                } catch (e) { console.warn('[HardwareInfo] Failed to detect GPU:', e); }
                return _info;
            }

            function _updateMemory() {
                if (performance && performance.memory) {
                    _info.memory.jsHeapSizeLimit = performance.memory.jsHeapSizeLimit;
                    _info.memory.totalJSHeapSize = performance.memory.totalJSHeapSize;
                    _info.memory.usedJSHeapSize = performance.memory.usedJSHeapSize;
                }
            }

            return { get: getInfo, refresh: function () { _updateMemory(); return _info; } };
        })();
        if (typeof window !== 'undefined') window.HardwareInfo = HardwareInfo;
    </script>

    <script>
        /**
         * @module ControlRegistry
         * (Inlined for standalone report generation)
         */
        const ControlRegistry = (function () {
            'use strict';
            const STORAGE_KEY = 'collider_control_settings_v1';
            const MOUSE_BUTTONS = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
            const ACTIONS = { ROTATE: 0, DOLLY: 1, PAN: 2 };

            const DEFAULTS = {
                mouse: { LEFT: 2, MIDDLE: 1, RIGHT: 0 },
                damping: { enabled: true, factor: 0.1 },
                speed: { rotate: 1.0, zoom: 1.2, pan: 1.0 }
            };

            let currentConfig = loadSettings();

            function loadSettings() {
                try {
                    const saved = localStorage.getItem(STORAGE_KEY);
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        return {
                            mouse: { ...DEFAULTS.mouse, ...(parsed.mouse || {}) },
                            damping: { ...DEFAULTS.damping, ...(parsed.damping || {}) },
                            speed: { ...DEFAULTS.speed, ...(parsed.speed || {}) }
                        };
                    }
                } catch (e) {
                    console.warn('[ControlRegistry] Failed to load settings:', e);
                }
                return JSON.parse(JSON.stringify(DEFAULTS));
            }

            function saveSettings() {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(currentConfig));
                    window.dispatchEvent(new CustomEvent('controls-updated', { detail: currentConfig }));
                } catch (e) {
                    console.error('[ControlRegistry] Failed to save settings:', e);
                }
            }

            return {
                getMapping: function () {
                    return {
                        LEFT: currentConfig.mouse.LEFT,
                        MIDDLE: currentConfig.mouse.MIDDLE,
                        RIGHT: currentConfig.mouse.RIGHT
                    };
                },
                getConfig: function () { return JSON.parse(JSON.stringify(currentConfig)); },
                updateMapping: function (button, actionId) {
                    if (currentConfig.mouse[button] !== undefined) {
                        currentConfig.mouse[button] = parseInt(actionId);
                        saveSettings();
                        console.log(`[ControlRegistry] Updated ${button} to Action ${actionId}`);
                    }
                },
                resetDefaults: function () {
                    currentConfig = JSON.parse(JSON.stringify(DEFAULTS));
                    saveSettings();
                },
                CONSTANTS: {
                    MOUSE_BUTTONS,
                    ACTIONS,
                    ACTION_LABELS: { 0: 'Rotate', 1: 'Zoom (Dolly)', 2: 'Pan' }
                }
            };
        })();
        if (typeof window !== 'undefined') window.ControlRegistry = ControlRegistry;
    </script>

    <script>
        /**
         * @module SettingsPanel
         * (Inlined for standalone report generation)
         */
        const SettingsPanel = (function () {
            'use strict';
            let container = null;
            let isVisible = false;

            function init() {
                if (container) {
                    console.log('[SettingsPanel] Already initialized.');
                    return;
                }

                console.log('[SettingsPanel] Initializing...');
                createPanel();
                createToggleButton();
                window.addEventListener('controls-updated', () => {
                    if (isVisible) refreshUI();
                });
                return true;
            }

            function createToggleButton() {
                const actionsSection = document.getElementById('section-actions');
                if (!actionsSection) {
                    // If section-actions doesn't exist (e.g. older template), try to create it or append to sidebar
                    console.warn('[SettingsPanel] #section-actions not found, attempting fallback');
                    // Fallback logic omitted for brevity, assuming newer template structure
                    return;
                }

                // In template.html specifically, section-actions content might be collapsed or structured differently.
                // We append to the .section-content
                let contentDiv = actionsSection.querySelector('.section-content') || actionsSection;
                if (actionsSection.classList.contains('section-content')) contentDiv = actionsSection;

                const btn = document.createElement('button');
                btn.className = 'btn'; // Re-use existing styling in template (btn vs nav-btn)
                btn.innerHTML = `<span class="icon">⚙️</span> Settings`;
                btn.onclick = togglePanel;
                btn.title = 'Configure Controls & Settings';
                btn.style.marginTop = '4px';
                btn.style.width = '100%';

                // If entry is a grid, we might want to append to the grid or after it
                const grid = contentDiv.querySelector('.btn-grid');
                if (grid) {
                    grid.appendChild(btn);
                } else {
                    contentDiv.appendChild(btn);
                }
            }

            function createPanel() {
                container = document.createElement('div');
                container.id = 'settings-panel';
                container.style.display = 'none';
                container.style.position = 'fixed';
                container.style.top = '50%';
                container.style.left = '50%';
                container.style.transform = 'translate(-50%, -50%)';
                container.style.backgroundColor = 'rgba(20, 20, 25, 0.95)';
                container.style.border = '1px solid #444';
                container.style.borderRadius = '8px';
                container.style.padding = '20px';
                container.style.zIndex = '100000';
                container.style.width = '400px';
                container.style.boxShadow = '0 10px 30px rgba(0,0,0,0.5)';
                container.style.color = '#eee';
                container.style.fontFamily = 'sans-serif';

                const header = document.createElement('div');
                header.style.display = 'flex';
                header.style.justifyContent = 'space-between';
                header.style.alignItems = 'center';
                header.style.marginBottom = '20px';
                header.style.borderBottom = '1px solid #444';
                header.style.paddingBottom = '10px';

                const title = document.createElement('h2');
                title.innerText = 'Settings';
                title.style.margin = '0';
                title.style.fontSize = '18px';

                const closeBtn = document.createElement('button');
                closeBtn.innerText = '×';
                closeBtn.style.background = 'none';
                closeBtn.style.border = 'none';
                closeBtn.style.color = '#fff';
                closeBtn.style.fontSize = '24px';
                closeBtn.style.cursor = 'pointer';
                closeBtn.onclick = hidePanel;

                header.appendChild(title);
                header.appendChild(closeBtn);
                container.appendChild(header);

                const content = document.createElement('div');
                content.id = 'settings-content';
                container.appendChild(content);

                const footer = document.createElement('div');
                footer.style.marginTop = '20px';
                footer.style.display = 'flex';
                footer.style.justifyContent = 'flex-end';
                footer.style.gap = '10px';

                const resetBtn = document.createElement('button');
                resetBtn.innerText = 'Reset Defaults';
                resetBtn.style.padding = '8px 12px';
                resetBtn.style.background = '#444';
                resetBtn.style.color = '#fff';
                resetBtn.style.border = 'none';
                resetBtn.style.borderRadius = '4px';
                resetBtn.style.cursor = 'pointer';
                resetBtn.onclick = () => {
                    if (confirm('Reset all navigation controls to default?')) {
                        ControlRegistry.resetDefaults();
                        refreshUI();
                    }
                };

                const saveBtn = document.createElement('button');
                saveBtn.innerText = 'Done';
                saveBtn.style.padding = '8px 16px';
                saveBtn.style.background = '#2196F3';
                saveBtn.style.color = '#fff';
                saveBtn.style.border = 'none';
                saveBtn.style.borderRadius = '4px';
                saveBtn.style.cursor = 'pointer';
                saveBtn.onclick = hidePanel;

                footer.appendChild(resetBtn);
                footer.appendChild(saveBtn);
                container.appendChild(footer);

                document.body.appendChild(container);
            }

            function refreshUI() {
                const content = document.getElementById('settings-content');
                content.innerHTML = '';

                const section = document.createElement('div');
                section.innerHTML = '<h3 style="margin-top:0; font-size:14px; color:#aaa; text-transform:uppercase;">Navigation Controls</h3>';

                const config = ControlRegistry.getConfig();
                const { ACTIONS, ACTION_LABELS } = ControlRegistry.CONSTANTS;

                ['LEFT', 'MIDDLE', 'RIGHT'].forEach(btn => {
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.justifyContent = 'space-between';
                    row.style.alignItems = 'center';
                    row.style.marginBottom = '10px';

                    const label = document.createElement('label');
                    label.innerText = `${btn} Mouse Button:`;
                    label.style.fontSize = '14px';

                    const select = document.createElement('select');
                    select.style.padding = '4px';
                    select.style.background = '#222';
                    select.style.color = '#ddd';
                    select.style.border = '1px solid #555';
                    select.style.borderRadius = '4px';

                    Object.keys(ACTIONS).forEach(actionKey => {
                        const actionId = ACTIONS[actionKey];
                        const opt = document.createElement('option');
                        opt.value = actionId;
                        opt.innerText = ACTION_LABELS[actionId];
                        if (config.mouse[btn] === actionId) opt.selected = true;
                        select.appendChild(opt);
                    });

                    select.onchange = (e) => { ControlRegistry.updateMapping(btn, parseInt(e.target.value)); };
                    row.appendChild(label);
                    row.appendChild(select);
                    section.appendChild(row);
                });
                content.appendChild(section);

                const hint = document.createElement('div');
                hint.style.fontSize = '12px';
                hint.style.color = '#888';
                hint.style.marginTop = '10px';
                hint.innerText = 'Tip: Changes apply immediately.';
                content.appendChild(hint);
            }

            function togglePanel() { isVisible ? hidePanel() : showPanel(); }
            function showPanel() { refreshUI(); container.style.display = 'block'; isVisible = true; }
            function hidePanel() { container.style.display = 'none'; isVisible = false; }

            return { init, toggle: togglePanel };
        })();
        if (typeof window !== 'undefined') window.SettingsPanel = SettingsPanel;
    </script>

    <script>
        // ═══ MODULE: performance.js ═══
/**
 * COLLIDER PERFORMANCE SUBSYSTEM
 *
 * Provides frame-budget-aware animation scheduling, adaptive quality management,
 * and real-time performance monitoring for the WebGL visualization.
 *
 * Architecture:
 *   PerformanceMonitor  → measures frame times, detects stuttering
 *   AnimationScheduler  → manages animation queue, enforces frame budget
 *   AdaptiveQuality     → degrades/upgrades quality based on performance
 *   PositionOwnership   → enforces single-owner invariant for node positions
 *
 * Usage:
 *   PERF.monitor.start()
 *   PERF.scheduler.requestTransition(nodes, targetPositions, duration)
 *   PERF.quality.current  // 'ultra' | 'high' | 'medium' | 'low' | 'minimal'
 */

const PERF = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION (loaded from performance.tokens.json or defaults)
    // =========================================================================

    const CONFIG = {
        frameBudget: {
            targetFps: 60,
            targetFrameMs: 16.67,
            warningThreshold: 0.8,   // 80% of budget
            criticalThreshold: 1.5   // 150% of budget
        },
        nodeThresholds: {
            small: 100,
            medium: 500,
            large: 1000,
            massive: 5000
        },
        monitoring: {
            sampleWindowMs: 1000,
            sampleCount: 60,
            degradeAfterConsecutiveDrops: 10,
            upgradeAfterConsecutiveGood: 30
        }
    };

    // =========================================================================
    // PERFORMANCE MONITOR
    // Tracks frame times using a rolling window
    // =========================================================================

    const PerformanceMonitor = {
        _frameTimes: [],
        _lastFrameTime: 0,
        _frameCount: 0,
        _droppedFrames: 0,
        _consecutiveDrops: 0,
        _consecutiveGood: 0,
        _isRunning: false,
        _rafId: null,

        start() {
            if (this._isRunning) return;
            this._isRunning = true;
            this._lastFrameTime = performance.now();
            this._tick();
        },

        stop() {
            this._isRunning = false;
            if (this._rafId) {
                cancelAnimationFrame(this._rafId);
                this._rafId = null;
            }
        },

        _tick() {
            if (!this._isRunning) return;

            const now = performance.now();
            const frameTime = now - this._lastFrameTime;
            this._lastFrameTime = now;

            // Record frame time
            this._frameTimes.push(frameTime);
            if (this._frameTimes.length > CONFIG.monitoring.sampleCount) {
                this._frameTimes.shift();
            }

            this._frameCount++;

            // Check for dropped frame
            const budget = CONFIG.frameBudget.targetFrameMs;
            if (frameTime > budget * CONFIG.frameBudget.criticalThreshold) {
                this._droppedFrames++;
                this._consecutiveDrops++;
                this._consecutiveGood = 0;

                // Trigger quality degradation check
                if (this._consecutiveDrops >= CONFIG.monitoring.degradeAfterConsecutiveDrops) {
                    AdaptiveQuality.degrade();
                    this._consecutiveDrops = 0;
                }
            } else if (frameTime < budget * CONFIG.frameBudget.warningThreshold) {
                this._consecutiveGood++;
                this._consecutiveDrops = 0;

                // Trigger quality upgrade check
                if (this._consecutiveGood >= CONFIG.monitoring.upgradeAfterConsecutiveGood) {
                    AdaptiveQuality.upgrade();
                    this._consecutiveGood = 0;
                }
            }

            this._rafId = requestAnimationFrame(() => this._tick());
        },

        get fps() {
            if (this._frameTimes.length < 2) return 0;
            const avg = this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
            return Math.round(1000 / avg);
        },

        get avgFrameTime() {
            if (this._frameTimes.length === 0) return 0;
            return this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
        },

        get lastFrameTime() {
            return this._frameTimes[this._frameTimes.length - 1] || 0;
        },

        get droppedFramePercent() {
            if (this._frameCount === 0) return 0;
            return Math.round((this._droppedFrames / this._frameCount) * 100);
        },

        get stats() {
            return {
                fps: this.fps,
                avgFrameTime: this.avgFrameTime.toFixed(2),
                lastFrameTime: this.lastFrameTime.toFixed(2),
                droppedPercent: this.droppedFramePercent,
                quality: AdaptiveQuality.current,
                owner: PositionOwnership.current
            };
        },

        reset() {
            this._frameTimes = [];
            this._frameCount = 0;
            this._droppedFrames = 0;
            this._consecutiveDrops = 0;
            this._consecutiveGood = 0;
        }
    };

    // =========================================================================
    // ADAPTIVE QUALITY MANAGER
    // Adjusts rendering quality based on performance
    // =========================================================================

    const QUALITY_TIERS = ['minimal', 'low', 'medium', 'high', 'ultra'];

    const QUALITY_SETTINGS = {
        ultra:   { refreshEvery: 1, flockEnabled: true,  labelDensity: 1.0, animDuration: 1500 },
        high:    { refreshEvery: 1, flockEnabled: false, labelDensity: 0.8, animDuration: 1200 },
        medium:  { refreshEvery: 2, flockEnabled: false, labelDensity: 0.5, animDuration: 800  },
        low:     { refreshEvery: 3, flockEnabled: false, labelDensity: 0.2, animDuration: 500  },
        minimal: { refreshEvery: 5, flockEnabled: false, labelDensity: 0.1, animDuration: 200  }
    };

    const AdaptiveQuality = {
        _current: 'high',
        _locked: false,
        _nodeCount: 0,
        _callbacks: [],

        init(nodeCount) {
            this._nodeCount = nodeCount;
            // Auto-select initial tier based on node count
            if (nodeCount <= CONFIG.nodeThresholds.small) {
                this._current = 'ultra';
            } else if (nodeCount <= CONFIG.nodeThresholds.medium) {
                this._current = 'high';
            } else if (nodeCount <= CONFIG.nodeThresholds.large) {
                this._current = 'medium';
            } else if (nodeCount <= CONFIG.nodeThresholds.massive) {
                this._current = 'low';
            } else {
                this._current = 'minimal';
            }
            console.log(`[PERF] Quality auto-set to '${this._current}' for ${nodeCount} nodes`);
            this._notify();
        },

        get current() { return this._current; },

        get settings() { return QUALITY_SETTINGS[this._current]; },

        set(tier) {
            if (!QUALITY_TIERS.includes(tier)) {
                console.warn(`[PERF] Unknown quality tier: ${tier}`);
                return;
            }
            this._current = tier;
            console.log(`[PERF] Quality set to '${tier}'`);
            this._notify();
        },

        degrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            if (idx > 0) {
                this._current = QUALITY_TIERS[idx - 1];
                console.log(`[PERF] Quality degraded to '${this._current}'`);
                this._notify();
            }
        },

        upgrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            // Don't upgrade beyond what node count allows
            const maxTier = this._getMaxTierForNodeCount();
            const maxIdx = QUALITY_TIERS.indexOf(maxTier);
            if (idx < maxIdx) {
                this._current = QUALITY_TIERS[idx + 1];
                console.log(`[PERF] Quality upgraded to '${this._current}'`);
                this._notify();
            }
        },

        lock() { this._locked = true; },
        unlock() { this._locked = false; },

        _getMaxTierForNodeCount() {
            const n = this._nodeCount;
            if (n <= CONFIG.nodeThresholds.small) return 'ultra';
            if (n <= CONFIG.nodeThresholds.medium) return 'high';
            if (n <= CONFIG.nodeThresholds.large) return 'medium';
            if (n <= CONFIG.nodeThresholds.massive) return 'low';
            return 'minimal';
        },

        onChange(callback) {
            this._callbacks.push(callback);
        },

        _notify() {
            this._callbacks.forEach(cb => cb(this._current, this.settings));
        }
    };

    // =========================================================================
    // POSITION OWNERSHIP
    // Enforces single-owner invariant for node positions (fx/fy/fz)
    // =========================================================================

    const OWNERS = ['none', 'transition', 'motion', 'flock', 'force'];

    const PositionOwnership = {
        _current: 'none',
        _animationId: null,

        get current() { return this._current; },

        acquire(owner, animationId = null) {
            if (!OWNERS.includes(owner)) {
                console.warn(`[PERF] Unknown position owner: ${owner}`);
                return false;
            }

            // Cancel any existing animation
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }

            this._current = owner;
            this._animationId = animationId;
            console.log(`[PERF] Position ownership: ${owner}`);
            return true;
        },

        release(owner) {
            if (this._current === owner) {
                if (this._animationId) {
                    cancelAnimationFrame(this._animationId);
                    this._animationId = null;
                }
                this._current = 'none';
                console.log(`[PERF] Position ownership released by ${owner}`);
            }
        },

        setAnimationId(id) {
            this._animationId = id;
        },

        cancelAnimation() {
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }
        }
    };

    // =========================================================================
    // ANIMATION SCHEDULER
    // Frame-budget-aware animation with throttling
    // =========================================================================

    const AnimationScheduler = {
        _refreshFrameCounter: 0,

        /**
         * Run a layout transition with frame budget awareness
         * @param {Object} options
         * @param {Array} options.nodes - Array of node objects
         * @param {Function} options.getTargetPosition - (node, index, total) => {x, y, z}
         * @param {number} options.duration - Animation duration in ms
         * @param {Function} options.onFrame - Called each frame with progress (0-1)
         * @param {Function} options.onComplete - Called when animation finishes
         * @param {Function} options.refresh - Function to call to refresh the graph
         */
        runTransition(options) {
            const { nodes, getTargetPosition, duration, onFrame, onComplete, refresh } = options;

            // Acquire ownership
            PositionOwnership.acquire('transition');

            const total = nodes.length;
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => getTargetPosition(n, i, total));

            const startTime = performance.now();
            const settings = AdaptiveQuality.settings;
            const actualDuration = Math.min(duration, settings.animDuration);

            this._refreshFrameCounter = 0;

            const animate = () => {
                // Check if we still own positions
                if (PositionOwnership.current !== 'transition') {
                    console.log('[PERF] Transition interrupted - lost ownership');
                    return;
                }

                const now = performance.now();
                const elapsed = now - startTime;
                const progress = Math.min(1, elapsed / actualDuration);

                // Smoothstep easing
                const eased = progress * progress * (3 - 2 * progress);

                // Update positions
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];
                    const s = startPos[i];
                    const t = targetPos[i];
                    n.fx = s.x + (t.x - s.x) * eased;
                    n.fy = s.y + (t.y - s.y) * eased;
                    n.fz = s.z + (t.z - s.z) * eased;
                }

                // Throttled refresh based on quality settings
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                if (onFrame) onFrame(progress);

                if (progress < 1) {
                    const id = requestAnimationFrame(animate);
                    PositionOwnership.setAnimationId(id);
                } else {
                    PositionOwnership.release('transition');
                    if (onComplete) onComplete();
                }
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Run continuous motion (rotate/orbit) with throttling
         */
        runMotion(options) {
            const { nodes, getPosition, speed, refresh } = options;

            PositionOwnership.acquire('motion');

            const total = nodes.length;
            const settings = AdaptiveQuality.settings;
            let time = 0;

            this._refreshFrameCounter = 0;

            const animate = () => {
                if (PositionOwnership.current !== 'motion') {
                    console.log('[PERF] Motion interrupted - lost ownership');
                    return;
                }

                time += speed;

                for (let i = 0; i < nodes.length; i++) {
                    const pos = getPosition(nodes[i], i, total, time);
                    nodes[i].fx = pos.x;
                    nodes[i].fy = pos.y;
                    nodes[i].fz = pos.z;
                }

                // Throttled refresh
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                const id = requestAnimationFrame(animate);
                PositionOwnership.setAnimationId(id);
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Stop any running animation
         */
        stop() {
            PositionOwnership.cancelAnimation();
            PositionOwnership._current = 'none';
        }
    };

    // =========================================================================
    // HUD OVERLAY
    // Real-time performance display (toggleable)
    // =========================================================================

    const HUD = {
        _element: null,
        _visible: false,
        _updateInterval: null,

        init() {
            this._element = document.createElement('div');
            this._element.id = 'perf-hud';
            this._element.style.cssText = `
                position: fixed;
                bottom: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.8);
                color: #0f0;
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
                padding: 8px 12px;
                border-radius: 4px;
                z-index: 10000;
                display: none;
                min-width: 140px;
                border: 1px solid #333;
            `;
            document.body.appendChild(this._element);
        },

        show() {
            if (!this._element) this.init();
            this._element.style.display = 'block';
            this._visible = true;
            this._startUpdates();
        },

        hide() {
            if (this._element) {
                this._element.style.display = 'none';
            }
            this._visible = false;
            this._stopUpdates();
        },

        toggle() {
            if (this._visible) this.hide();
            else this.show();
        },

        _startUpdates() {
            if (this._updateInterval) return;
            this._updateInterval = setInterval(() => this._update(), 100);
        },

        _stopUpdates() {
            if (this._updateInterval) {
                clearInterval(this._updateInterval);
                this._updateInterval = null;
            }
        },

        _update() {
            if (!this._element || !this._visible) return;

            const stats = PerformanceMonitor.stats;
            const fpsColor = stats.fps >= 55 ? '#0f0' : stats.fps >= 30 ? '#ff0' : '#f00';

            this._element.innerHTML = `
                <div style="color: ${fpsColor}; font-weight: bold;">${stats.fps} FPS</div>
                <div style="color: #888;">Frame: ${stats.lastFrameTime}ms</div>
                <div style="color: #888;">Avg: ${stats.avgFrameTime}ms</div>
                <div style="color: #888;">Drops: ${stats.droppedPercent}%</div>
                <div style="color: #0af;">Quality: ${stats.quality}</div>
                <div style="color: #a0f;">Owner: ${stats.owner}</div>
            `;
        }
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        monitor: PerformanceMonitor,
        quality: AdaptiveQuality,
        ownership: PositionOwnership,
        scheduler: AnimationScheduler,
        hud: HUD,
        config: CONFIG,

        /**
         * Initialize the performance subsystem
         * @param {number} nodeCount - Number of nodes in the graph
         * @param {Object} tokens - Optional performance tokens from JSON
         */
        init(nodeCount, tokens = null) {
            if (tokens) {
                Object.assign(CONFIG, tokens);
            }
            AdaptiveQuality.init(nodeCount);
            PerformanceMonitor.start();
            HUD.init();
            console.log('[PERF] Performance subsystem initialized');
        },

        /**
         * Check if flock simulation should be enabled
         */
        isFlockAllowed() {
            return AdaptiveQuality.settings.flockEnabled;
        },

        /**
         * Get current animation duration (adjusted for quality)
         */
        getAnimationDuration(requested) {
            return Math.min(requested, AdaptiveQuality.settings.animDuration);
        }
    };
})();

// Export for module systems if available
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PERF;
}


// ═══ MODULE: modules/utils.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UTILS MODULE - Pure Utility Functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Zero-dependency pure functions for math, string, and data operations.
 * These functions have NO external state dependencies and can be used anywhere.
 *
 * @module UTILS
 * @version 1.0.0
 * @confidence 99%
 */

window.UTILS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // MATH UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clamp value to [0, 1] range
     * @param {number} value - Value to clamp
     * @returns {number} Clamped value
     */
    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    /**
     * Clamp value to [min, max] range
     * @param {number} value - Value to clamp
     * @param {number} min - Minimum bound
     * @param {number} max - Maximum bound
     * @returns {number} Clamped value
     */
    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Normalize value to [0, 1] based on max.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} val - Value to normalize
     * @param {number} max - Maximum value
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value
     */
    function normalize(val, max, scaleName) {
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', val, 0, max);
        }
        // Fallback
        return Math.min(1, Math.max(0, val / max));
    }

    /**
     * Normalize metric value based on range.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} value - Value to normalize
     * @param {min: number, max: number} range - Range object
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value in [0, 1]
     */
    function normalizeMetric(value, range, scaleName) {
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', value, range.min, range.max);
        }
        // Fallback
        return clamp01((value - range.min) / (range.max - range.min));
    }

    /**
     * Calculate quantile from sorted values
     * @param {number[]} values - Array of numbers
     * @param {number} q - Quantile (0-1)
     * @returns {number} Quantile value
     */
    function quantile(values, q) {
        if (!values.length) return 0;
        const sorted = values.slice().sort((a, b) => a - b);
        const pos = (sorted.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;
        if (sorted[base + 1] !== undefined) {
            return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
        }
        return sorted[base];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HASH & SEED UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Convert any value to a unit float [0, 1] via hashing
     * @param {*} value - Any value to hash
     * @returns {number} Hash as unit float
     */
    function hashToUnit(value) {
        const str = String(value || '');
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return (hash >>> 0) / 0xffffffff;
    }

    /**
     * Generate stable seed from node and salt
     * @param {Object} node - Node object with id/name
     * @param {string} salt - Salt string
     * @returns {number} Stable seed in [0, 1]
     */
    function stableSeed(node, salt) {
        const id = String(node.id || node.name || '');
        const combined = `${id}|${salt}`;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
            hash = ((hash << 5) - hash + combined.charCodeAt(i)) | 0;
        }
        return ((hash >>> 0) % 1000) / 1000;
    }

    /**
     * Generate stable Z offset for node
     * @param {Object} node - Node object
     * @returns {number} Z offset
     */
    function stableZ(node) {
        const normalized = stableSeed(node, 'z');
        return (normalized - 0.5) * 60;
    }

    /**
     * Generate stable offset vector for node positioning
     * @param {Object} node - Node object
     * @param {string} salt - Salt string
     * @param {number} radius - Base radius
     * @returns {x: number, y: number, z: number} Offset vector
     */
    function stableOffset(node, salt, radius) {
        const angle = stableSeed(node, `${salt}:angle`) * Math.PI * 2;
        const spread = 0.3 + stableSeed(node, `${salt}:radius`) * 0.7;
        const zJitter = (stableSeed(node, `${salt}:z`) - 0.5) * radius * 0.6;
        const dist = radius * spread;
        return {
            x: Math.cos(angle) * dist,
            y: Math.sin(angle) * dist,
            z: zJitter
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STRING UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Escape HTML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML
     */
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Parse OKLCH color string
     * @param {string} value - OKLCH color string
     * @returns {L: number, C: number, H: number, A: number}|null} Parsed values or null
     */
    function parseOklchString(value) {
        if (typeof value !== 'string') return null;
        const match = value.trim().match(/^oklch\(\s*([\d.]+)%\s+([\d.]+)\s+([\d.]+)(?:\s*\/\s*([\d.]+))?\s*\)$/i);
        if (!match) return null;
        return {
            L: parseFloat(match[1]),
            C: parseFloat(match[2]),
            H: parseFloat(match[3]),
            A: match[4] !== undefined ? parseFloat(match[4]) : 1
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Resolve defaults against available values
     * @param {Array} defaults - Preferred defaults
     * @param {Array} available - Available values
     * @returns {Array} Resolved values
     */
    function resolveDefaults(defaults, available) {
        if (!Array.isArray(defaults) || defaults.length === 0) {
            return available;
        }
        const availableSet = new Set(available);
        const intersection = defaults.filter(value => availableSet.has(value));
        return intersection.length ? intersection : available;
    }

    /**
     * Build dataset key from data object
     * @param {Object} data - Data object with meta, nodes, links
     * @returns {string} Dataset key
     */
    function buildDatasetKey(data) {
        const meta = (data && data.meta) ? data.meta : {};
        const target = meta.target || meta.project || 'dataset';
        const version = meta.version || '';
        const nodeCount = Array.isArray(data?.nodes) ? data.nodes.length : 0;
        const edgeCount = Array.isArray(data?.links)
            ? data.links.length
            : (Array.isArray(data?.edges) ? data.edges.length : 0);
        const raw = `${target}|${nodeCount}|${edgeCount}|${version}`;
        return raw.replace(/[^a-zA-Z0-9_.-]/g, '_').slice(0, 180);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GEOMETRY UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Calculate bounding box from two points
     * @param {x: number, y: number} start - Start point
     * @param {x: number, y: number} end - End point
     * @returns {left: number, top: number, width: number, height: number, right: number, bottom: number} Box rect
     */
    function getBoxRect(start, end) {
        const left = Math.min(start.x, end.x);
        const top = Math.min(start.y, end.y);
        const width = Math.abs(start.x - end.x);
        const height = Math.abs(start.y - end.y);
        return {
            left,
            top,
            width,
            height,
            right: left + width,
            bottom: top + height
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Math
        clamp01,
        clampValue,
        normalize,
        normalizeMetric,
        quantile,

        // Hash & Seed
        hashToUnit,
        stableSeed,
        stableZ,
        stableOffset,

        // String
        escapeHtml,
        parseOklchString,

        // Data
        resolveDefaults,
        buildDatasetKey,

        // Geometry
        getBoxRect
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════
// These ensure existing code continues to work without modification

window.clamp01 = UTILS.clamp01;
window.clampValue = UTILS.clampValue;
window.normalize = UTILS.normalize;
window.normalizeMetric = UTILS.normalizeMetric;
window.quantile = UTILS.quantile;
window.hashToUnit = UTILS.hashToUnit;
window.stableSeed = UTILS.stableSeed;
window.stableZ = UTILS.stableZ;
window.stableOffset = UTILS.stableOffset;
window.escapeHtml = UTILS.escapeHtml;
window.parseOklchString = UTILS.parseOklchString;
window.resolveDefaults = UTILS.resolveDefaults;
window.buildDatasetKey = UTILS.buildDatasetKey;
window.getBoxRect = UTILS.getBoxRect;

console.log('[Module] UTILS loaded - 14 pure functions');


// ═══ MODULE: modules/registry.js ═══
/**
 * @module registry
 * @description Centralized UI and command registration system
 * @responsibility Manage DOM element and command handler registration
 */

const REGISTRY = (function() {
    'use strict';

    // Private state
    const _items = new Map();
    const _commands = new Map();

    /**
     * Register a command handler or DOM element
     * @param {string} id - The identifier
     * @param {Function|Element} item - Handler function or DOM element
     * @param {Object} options - Additional options
     */
    function register(id, item, options = {}) {
        // CASE 1: Registering a Command Identifier + Handler Function
        // e.g. REGISTRY.register('cmd-files', () => toggleFiles(), { desc: '...' })
        if (typeof item === 'function') {
            _commands.set(id, { handler: item, options });

            // Auto-wire if DOM element exists with this ID
            const btn = document.getElementById(id);
            if (btn) {
                btn.onclick = (e) => {
                    item(e);
                };
                btn.setAttribute('data-command-id', id);
            }
            return;
        }

        // CASE 2: Registering a DOM Element directly
        let element = item;
        let elementId = id;

        // Overload: register(element) -> id comes from element.id
        if ((item instanceof Element) && arguments.length === 1) {
            element = item;
            elementId = element.id;
        }
        // Overload: register(id, element)
        else if (item instanceof Element) {
            element = item;
        }
        // Fallback: mismatched args
        else if (!element && (typeof id === 'object' && id instanceof Element)) {
            element = id;
            elementId = element.id;
        }

        if (!element || !element.setAttribute) {
            return;
        }

        if (!elementId) {
            return;
        }

        _items.set(elementId, element);
        element.setAttribute('data-registry-id', elementId);
    }

    /**
     * Get a registered element by ID (falls back to document.getElementById)
     * @param {string} id - The element ID
     * @returns {Element|null}
     */
    function get(id) {
        return _items.get(id) || document.getElementById(id);
    }

    /**
     * Get a registered command handler
     * @param {string} id - The command ID
     * @returns {Object|undefined} - { handler, options }
     */
    function getCommand(id) {
        return _commands.get(id);
    }

    /**
     * Execute a registered command
     * @param {string} id - The command ID
     * @param {Event} event - Optional event object
     * @returns {*} - Result of handler execution
     */
    function execute(id, event) {
        const cmd = _commands.get(id);
        if (cmd && typeof cmd.handler === 'function') {
            return cmd.handler(event);
        }
        console.warn(`[Registry] Command not found: ${id}`);
        return undefined;
    }

    /**
     * Check if a command is registered
     * @param {string} id - The command ID
     * @returns {boolean}
     */
    function hasCommand(id) {
        return _commands.has(id);
    }

    /**
     * Check if an element is registered
     * @param {string} id - The element ID
     * @returns {boolean}
     */
    function hasElement(id) {
        return _items.has(id);
    }

    /**
     * Get all registered command IDs
     * @returns {string[]}
     */
    function listCommands() {
        return Array.from(_commands.keys());
    }

    /**
     * Get all registered element IDs
     * @returns {string[]}
     */
    function listElements() {
        return Array.from(_items.keys());
    }

    // Public API
    return {
        register,
        get,
        getCommand,
        execute,
        hasCommand,
        hasElement,
        listCommands,
        listElements,
        // Expose maps for backward compatibility (read-only access pattern)
        get items() { return _items; },
        get commands() { return _commands; }
    };
})();

// Expose globally for backward compatibility
window.REGISTRY = REGISTRY;


// ═══ MODULE: modules/perf-monitor.js ═══
/**
 * @module perf-monitor
 * @description Real-time performance monitoring and FPS diagnostics
 * @responsibility Track frame delivery, detect dropped frames, display HUD
 */

// NOTE: Named _PerfMonitorImpl to avoid conflict with performance.js PERF
const _PerfMonitorImpl = (function () {
    'use strict';

    // Configuration
    const _config = {
        enabled: true,
        maxFrames: 60,
        droppedFrameThreshold: 50
    };

    // State
    const _state = {
        fps: 0,
        frameTime: 0,
        lastFrameTime: 0,
        frameTimes: [],
        renderCalls: 0,
        droppedFrames: 0,
        lastSecond: 0,
        framesThisSecond: 0,
        hudElement: null,
        monitoring: false,
        renderer: null, // Three.js renderer reference
        hardware: null
    };

    /**
     * Initialize the performance monitor
     */
    function init() {
        if (!_config.enabled) return;
        if (_state.hudElement) return; // Idempotent

        // Hardware info
        if (typeof HardwareInfo !== 'undefined') {
            _state.hardware = HardwareInfo.get();
        }

        // Create Enhanced HUD
        _state.hudElement = document.createElement('div');
        _state.hudElement.id = 'perf-hud';
        _state.hudElement.style.cssText = `
            position: fixed; top: 10px; right: 10px; z-index: 99999;
            background: rgba(10, 12, 16, 0.95); color: #eee; font-family: 'SF Mono', monospace;
            font-size: 10px; padding: 0; border-radius: 6px;
            border: 1px solid #333; min-width: 300px; /* Wider for 3 columns */
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            overflow: hidden;
        `;
        document.body.appendChild(_state.hudElement);
        _startMonitoring();
    }

    /**
     * Link a renderer for deep stats
     */
    function setRenderer(renderer) {
        _state.renderer = renderer;
    }

    /**
     * Start the monitoring loop
     */
    function _startMonitoring() {
        if (_state.monitoring) return;
        _state.monitoring = true;

        let frameCount = 0;

        const monitor = () => {
            if (!_state.monitoring) return;

            const now = performance.now();

            // Calculate frame time
            if (_state.lastFrameTime > 0) {
                _state.frameTime = now - _state.lastFrameTime;
                _state.frameTimes.push(_state.frameTime);
                if (_state.frameTimes.length > _config.maxFrames) {
                    _state.frameTimes.shift();
                }

                // Detect dropped frames
                if (_state.frameTime > _config.droppedFrameThreshold) {
                    _state.droppedFrames++;
                }
            }
            _state.lastFrameTime = now;

            // Calculate FPS every second
            const second = Math.floor(now / 1000);
            if (second !== _state.lastSecond) {
                _state.fps = _state.framesThisSecond;
                _state.framesThisSecond = 0;
                _state.lastSecond = second;

                // Low freq updates (memory, hardware)
                if (typeof HardwareInfo !== 'undefined') HardwareInfo.refresh();
            }
            _state.framesThisSecond++;

            // Throttle HUD DOM updates to 10fps to save CPU
            if (frameCount++ % 6 === 0) {
                _updateHUD();
            }

            requestAnimationFrame(monitor);
        };
        requestAnimationFrame(monitor);
    }

    /**
     * Update the HUD display (Enhanced)
     */
    function _updateHUD() {
        if (!_state.hudElement) return;

        const avgFrameTime = _state.frameTimes.length > 0
            ? (_state.frameTimes.reduce((a, b) => a + b, 0) / _state.frameTimes.length).toFixed(1)
            : '0.0';

        // 1. Performance Colors
        let fpsColor = '#4ade80';
        if (_state.fps < 30) fpsColor = '#facc15';
        if (_state.fps < 15) fpsColor = '#f87171';

        // 2. Memory
        let memString = '--';
        if (_state.hardware && _state.hardware.memory) {
            const used = (_state.hardware.memory.usedJSHeapSize / 1048576).toFixed(0);
            const total = (_state.hardware.memory.totalJSHeapSize / 1048576).toFixed(0);
            memString = `${used} / ${total} MB`;
        }

        // 3. Renderer Stats
        let renderInfo = { calls: 0, triangles: 0, geometries: 0 };
        if (_state.renderer && _state.renderer.info) {
            renderInfo.calls = _state.renderer.info.render.calls;
            renderInfo.triangles = _state.renderer.info.render.triangles;
            renderInfo.geometries = _state.renderer.info.memory.geometries;
        }

        // 4. GPU Name
        const gpuName = _state.hardware ? _state.hardware.gpu.replace('ANGLE (', '').replace(')', '') : 'Unknown GPU';

        // TEMPLATE
        _state.hudElement.innerHTML = `
            <div style="padding: 10px; border-right: 1px solid #333;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">PERFORMANCE</div>
                <div style="font-size:18px; color:${fpsColor}; font-weight:bold; letter-spacing:-0.5px">
                    ${_state.fps} <span style="font-size:10px; color:#666">FPS</span>
                </div>
                <div style="margin-top:2px">${avgFrameTime} ms</div>
                <div style="color:#f87171; margin-top:4px">Drops: ${_state.droppedFrames}</div>
                <div style="margin-top:8px; color:#aaa; font-size:9px">MEM: ${memString}</div>
            </div>
            <div style="padding: 10px;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">SCENE & HARDWARE</div>
                <div style="display:flex; justify-content:space-between"><span>Draw Calls:</span> <span>${renderInfo.calls}</span></div>
                <div style="display:flex; justify-content:space-between"><span>Triangles:</span> <span>${(renderInfo.triangles / 1000).toFixed(1)}k</span></div>
                <div style="display:flex; justify-content:space-between"><span>Geometries:</span> <span>${renderInfo.geometries}</span></div>
                
                <div style="margin-top:8px; padding-top:8px; border-top:1px solid #333; color:#666; font-size:9px; line-height:1.2">
                    ${gpuName.substring(0, 40)}...
                </div>
            </div>
        `;
    }

    /**
     * Reset statistics
     */
    function reset() {
        _state.fps = 0;
        _state.frameTime = 0;
        _state.frameTimes = [];
        _state.droppedFrames = 0;
        _state.framesThisSecond = 0;
    }

    /**
     * Log a performance resistance point
     * @param {string} location - Where the resistance occurred
     * @param {number} duration - Duration in milliseconds
     */
    function logResistance(location, duration) {
        if (duration > 16) {
            console.warn(`[PERF RESISTANCE] ${location}: ${duration.toFixed(1)}ms (>${Math.floor(duration / 16.67)} frames)`);
        }
    }

    /**
     * Stop monitoring
     */
    function stop() {
        _state.monitoring = false;
        if (_state.hudElement && _state.hudElement.parentNode) {
            _state.hudElement.parentNode.removeChild(_state.hudElement);
        }
        _state.hudElement = null;
    }

    /**
     * Toggle HUD visibility
     */
    function toggle() {
        if (_state.hudElement) {
            _state.hudElement.style.display =
                _state.hudElement.style.display === 'none' ? 'block' : 'none';
        }
    }

    /**
     * Enable/disable monitoring
     * @param {boolean} enabled
     */
    function setEnabled(enabled) {
        _config.enabled = enabled;
        if (!enabled) {
            stop();
        } else if (!_state.monitoring) {
            init();
        }
    }

    // Public API
    return {
        init,
        stop,
        reset,
        toggle,
        setEnabled,
        setRenderer,
        logResistance,
        // Read-only state access
        get fps() { return _state.fps; },
        get frameTime() { return _state.frameTime; },
        get droppedFrames() { return _state.droppedFrames; },
        get enabled() { return _config.enabled; },
        get monitoring() { return _state.monitoring; }
    };
})();

// Export as PERF_MONITOR (PERF is provided by performance.js)
const PERF_MONITOR = _PerfMonitorImpl;

// Expose globally - only PERF_MONITOR, PERF comes from performance.js
window.PERF_MONITOR = PERF_MONITOR;

// BACKWARD COMPAT: Expose logResistance globally as some modules expect it
window.logResistance = PERF_MONITOR.logResistance;


// ═══ MODULE: modules/core.js ═══
/**
 * CORE MODULE
 *
 * Foundation constants and utility functions for the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   CORE.SELECTION_SIZE_MULT      // Node size multiplier when selected
 *   CORE.PENDULUM                 // OKLCH color oscillator state
 *   CORE.amplify(value, gamma)    // Power law amplification
 *   CORE.amplifyContrast(value)   // S-curve contrast expansion
 */

const CORE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

    // OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
    const PENDULUM = {
        hue: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,        // Set from appearance.tokens
            gravity: null,        // Set from appearance.tokens
            length: 1.0,
            rotationSpeed: null   // Set from appearance.tokens
        },
        chroma: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,
            gravity: null,
            length: 1.0,
            center: null,
            amplitude: null
        },
        lightness: {
            phase: 0,
            speed: null,
            center: null,
            amplitude: null
        },
        ripple: {
            speed: null,
            scale: null
        },
        currentHue: Math.random() * 360,
        lastTime: 0,
        running: false
    };

    // =========================================================================
    // AMPLIFICATION UTILITIES
    // =========================================================================

    /**
     * Amplification function using power law: f(x) = x^(1/gamma)
     * Maps normalized [0,1] input to amplified [0,1] output
     * @param {number} value - Input value (0-1)
     * @param {number} gamma - Amplification factor (default from APPEARANCE_STATE)
     * @returns {number} Amplified value (0-1)
     */
    function amplify(value, gamma) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const g = gamma !== undefined ? gamma :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (g === 1) return value;
        // Clamp to valid range
        const v = Math.max(0, Math.min(1, value));
        // Power law: v^(1/gamma) - when gamma>1, small diffs become larger
        // Using 1/gamma so that higher slider = more amplification
        return Math.pow(v, 1 / g);
    }

    /**
     * Contrast amplification: expands values away from midpoint
     * Uses S-curve (tanh) for smooth contrast expansion
     * @param {number} value - Input value (0-1)
     * @param {number} strength - Contrast strength (default from APPEARANCE_STATE)
     * @returns {number} Contrast-enhanced value (0-1)
     */
    function amplifyContrast(value, strength) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const s = strength !== undefined ? strength :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (s === 1) return value;
        const v = Math.max(0, Math.min(1, value));
        // S-curve using tanh for smooth contrast expansion
        const centered = (v - 0.5) * 2;  // [-1, 1]
        const amplified = Math.tanh(centered * s) / Math.tanh(s);
        return (amplified + 1) / 2;  // Back to [0, 1]
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Constants
        SELECTION_SIZE_MULT,
        PENDULUM,

        // Utilities
        amplify,
        amplifyContrast
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'SELECTION_SIZE_MULT', {
    get: () => CORE.SELECTION_SIZE_MULT,
    configurable: true
});
Object.defineProperty(window, 'PENDULUM', {
    get: () => CORE.PENDULUM,
    configurable: true
});
Object.defineProperty(window, 'amplify', {
    get: () => CORE.amplify,
    configurable: true
});
Object.defineProperty(window, 'amplifyContrast', {
    get: () => CORE.amplifyContrast,
    configurable: true
});


// ═══ MODULE: modules/theory.js ═══
/**
 * THEORY MODULE - Standard Model of Code Theory Constants
 *
 * Pure data representing the Standard Model topology.
 * No dependencies. This is the canonical source of truth.
 *
 * @module THEORY
 * @version 1.0.0
 */

window.THEORY = (function() {
    'use strict';

    // =========================================================================
    // THE 16 ABSTRACTION LEVELS (vertical axis: L-3 to L12)
    // =========================================================================

    const SCALE_16_LEVELS = {
        // COSMOLOGICAL (L8-L12) - Beyond scope, shown as outer haze
        'L12': { name: 'UNIVERSE', symbol: '🌐', zone: 'COSMOLOGICAL', y: 1.4, color: { h: 260, s: 30, l: 25 } },
        'L11': { name: 'DOMAIN', symbol: '🏛️', zone: 'COSMOLOGICAL', y: 1.3, color: { h: 250, s: 35, l: 30 } },
        'L10': { name: 'ORGANIZATION', symbol: '🏢', zone: 'COSMOLOGICAL', y: 1.2, color: { h: 240, s: 40, l: 35 } },
        'L9': { name: 'PLATFORM', symbol: '☁️', zone: 'COSMOLOGICAL', y: 1.1, color: { h: 230, s: 45, l: 40 } },
        'L8': { name: 'ECOSYSTEM', symbol: '🔗', zone: 'COSMOLOGICAL', y: 1.0, color: { h: 220, s: 50, l: 45 } },
        // ARCHITECTURAL (L4-L7) - Primary visible zone (teal - virtual depths)
        'L7': { name: 'SYSTEM', symbol: '⬡', zone: 'ARCHITECTURAL', y: 0.7, color: { h: 175, s: 60, l: 52 } },
        'L6': { name: 'PACKAGE', symbol: '📦', zone: 'ARCHITECTURAL', y: 0.5, color: { h: 178, s: 62, l: 48 } },
        'L5': { name: 'FILE', symbol: '📄', zone: 'ARCHITECTURAL', y: 0.3, color: { h: 180, s: 65, l: 44 } },
        'L4': { name: 'CONTAINER', symbol: '⬢', zone: 'ARCHITECTURAL', y: 0.1, color: { h: 182, s: 68, l: 40 } },
        // SEMANTIC (L1-L3) - The operational core (silver/white - surface light)
        'L3': { name: 'NODE', symbol: '★', zone: 'SEMANTIC', y: -0.1, color: { h: 210, s: 25, l: 92 } },  // Brightest - fundamental unit
        'L2': { name: 'BLOCK', symbol: '▣', zone: 'SEMANTIC', y: -0.3, color: { h: 210, s: 30, l: 85 } },
        'L1': { name: 'STATEMENT', symbol: '─', zone: 'SEMANTIC', y: -0.5, color: { h: 210, s: 35, l: 78 } },
        // SYNTACTIC (L0) - The event horizon between meaning and data
        'L0': { name: 'TOKEN', symbol: '·', zone: 'SYNTACTIC', y: -0.7, color: { h: 60, s: 90, l: 55 } },  // Bright yellow - event horizon
        // PHYSICAL (L-1 to L-3) - The substrate (deep blue - ocean floor)
        'L-1': { name: 'CHARACTER', symbol: 'a', zone: 'PHYSICAL', y: -0.9, color: { h: 220, s: 70, l: 42 } },
        'L-2': { name: 'BYTE', symbol: '01', zone: 'PHYSICAL', y: -1.1, color: { h: 220, s: 75, l: 35 } },
        'L-3': { name: 'BIT/QUBIT', symbol: '⚡', zone: 'PHYSICAL', y: -1.3, color: { h: 220, s: 80, l: 28 } }  // Deepest
    };

    // =========================================================================
    // THE THREE PARALLEL LAYERS (shells around the structure)
    // =========================================================================

    const THREE_LAYERS = {
        'PHYSICAL': { order: 0, radius: 1.8, opacity: 0.15, color: { h: 220, s: 75, l: 35 }, description: 'Hardware, bits, memory, I/O' },
        'VIRTUAL': { order: 1, radius: 1.4, opacity: 0.25, color: { h: 175, s: 65, l: 45 }, description: 'Code, structures, algorithms' },
        'SEMANTIC': { order: 2, radius: 1.0, opacity: 0.35, color: { h: 210, s: 30, l: 88 }, description: 'Meaning, business logic, intent' }
    };

    // =========================================================================
    // STANDARD MODEL THEORY CONTENT - Semantic descriptions for tooltips
    // =========================================================================

    const SMC_THEORY = {
        // THE THREE FUNDAMENTAL LAYERS
        layers: {
            'PHYSICAL': {
                icon: '⚡',
                title: 'Physical Layer',
                subtitle: 'The Substrate',
                body: 'The hardware reality: electrons, circuits, memory cells. Everything that exists in physical space-time.',
                theory: '"Matter is the canvas upon which computation paints its patterns."',
                examples: ['CPU registers', 'RAM cells', 'disk sectors', 'network signals']
            },
            'VIRTUAL': {
                icon: '💠',
                title: 'Virtual Layer',
                subtitle: 'The Structure',
                body: 'Pure information structures: code, data, algorithms. The mathematical forms that live in computational space.',
                theory: '"Between the physical and the meaningful lies the virtual — pure form without matter or purpose."',
                examples: ['variables', 'functions', 'classes', 'data structures']
            },
            'SEMANTIC': {
                icon: '🎯',
                title: 'Semantic Layer',
                subtitle: 'The Meaning',
                body: 'Intent and purpose: business logic, user goals, system behavior. The "why" behind the code.',
                theory: '"Semantics is where computation meets human intention — the bridge between bits and understanding."',
                examples: ['user stories', 'business rules', 'API contracts', 'domain models']
            }
        },

        // ATOM FAMILIES
        families: {
            'LOG': {
                icon: '📊',
                title: 'Logic Family',
                subtitle: 'The Reasoners',
                body: 'Elements that transform data through computation: conditionals, loops, calculations.',
                theory: '"Logic atoms are the decision-makers — they take inputs and produce outputs through transformation."',
                examples: ['if/else', 'for loops', 'calculations', 'validators']
            },
            'DAT': {
                icon: '📦',
                title: 'Data Family',
                subtitle: 'The Containers',
                body: 'Elements that hold and organize information: variables, structures, databases.',
                theory: '"Data atoms store state — they are the nouns in the grammar of code."',
                examples: ['variables', 'arrays', 'objects', 'databases']
            },
            'ORG': {
                icon: '🏗️',
                title: 'Organization Family',
                subtitle: 'The Architects',
                body: 'Elements that structure code: modules, classes, packages. They create boundaries.',
                theory: '"Organization atoms create order from chaos — the folders in the file system of abstraction."',
                examples: ['modules', 'classes', 'packages', 'namespaces']
            },
            'EXE': {
                icon: '⚙️',
                title: 'Execution Family',
                subtitle: 'The Doers',
                body: 'Elements that perform actions: function calls, I/O, system operations.',
                theory: '"Execution atoms are the verbs — where potential becomes actual."',
                examples: ['function calls', 'API requests', 'file writes', 'renders']
            },
            'EXT': {
                icon: '🔌',
                title: 'External Family',
                subtitle: 'The Connectors',
                body: 'Elements that interface with the outside: APIs, imports, system calls.',
                theory: '"External atoms are portals — they connect isolated systems into larger ecosystems."',
                examples: ['imports', 'API calls', 'env vars', 'dependencies']
            }
        },

        // TIERS
        tiers: {
            'T0': {
                icon: '🔬',
                title: 'Tier 0 — Foundation',
                subtitle: 'Low-level primitives',
                body: 'The atomic building blocks: individual statements, expressions, basic operations.',
                theory: '"T0 is where code meets silicon — the ground floor of abstraction."',
                examples: ['assignments', 'operators', 'literals', 'basic types']
            },
            'T1': {
                icon: '🔧',
                title: 'Tier 1 — Components',
                subtitle: 'Functional units',
                body: 'Grouped functionality: functions, methods, small modules.',
                theory: '"T1 is the sweet spot — complex enough to be useful, simple enough to understand."',
                examples: ['functions', 'methods', 'handlers', 'utilities']
            },
            'T2': {
                icon: '🏛️',
                title: 'Tier 2 — Architecture',
                subtitle: 'System structure',
                body: 'High-level organization: classes, modules, services. The skeleton of the codebase.',
                theory: '"T2 defines the shape of software — patterns emerge that echo through every line."',
                examples: ['classes', 'modules', 'services', 'controllers']
            }
        },

        // SPECIAL ELEMENTS
        special: {
            'core': {
                icon: '✨',
                title: 'The Nexus',
                subtitle: 'Singularity Point',
                body: 'The center of the topology: where all paths converge.',
                theory: '"Every codebase has a heart — the central modules that everything depends upon."',
                examples: ['main.js', 'app.py', 'index.ts', 'core.rs']
            },
            'elevator': {
                icon: '🚀',
                title: 'Data Elevator',
                subtitle: 'Cross-tier Highway',
                body: 'Vertical connections that move data between abstraction levels.',
                theory: '"Elevators are the call stacks of architecture."',
                examples: ['API layers', 'ORMs', 'serializers', 'adapters']
            },
            'hub-star': {
                icon: '⭐',
                title: 'Hub Node',
                subtitle: 'High-connectivity Center',
                body: 'A node with many incoming connections. Often a critical dependency.',
                theory: '"Hubs are the load-bearing walls — remove them and everything collapses."',
                examples: ['utils', 'config', 'logger', 'database']
            }
        }
    };

    // =========================================================================
    // LEVEL ZONES - Which levels belong to which visual band
    // =========================================================================

    const LEVEL_ZONES = {
        'COSMOLOGICAL': { levels: ['L12', 'L11', 'L10', 'L9', 'L8'], opacity: 0.2, blur: true },
        'ARCHITECTURAL': { levels: ['L7', 'L6', 'L5', 'L4'], opacity: 0.6, blur: false },
        'SEMANTIC': { levels: ['L3', 'L2', 'L1'], opacity: 1.0, blur: false },        // Primary focus
        'SYNTACTIC': { levels: ['L0'], opacity: 0.8, blur: false },                   // Event horizon
        'PHYSICAL': { levels: ['L-1', 'L-2', 'L-3'], opacity: 0.4, blur: true }
    };

    // =========================================================================
    // VISUALIZATION PRESETS - Different ways to see the topology
    // =========================================================================

    const VIS_PRESETS = {
        'tier': {
            name: 'By Tier (T0/T1/T2)',
            description: 'Core → Architecture → External',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'family': {
            name: 'By Atom Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'layer': {
            name: 'By Layer',
            description: 'Physical → Virtual → Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'ring': {
            name: 'By Ring (Domain)',
            description: 'Domain architecture layers',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'file': {
            name: 'By File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'flow': {
            name: 'Markov Flow',
            description: 'Edge width = transition probability',
            colorBy: 'tier',
            sizeBy: 'entropy',
            edgeBy: 'weight'
        },
        'depth': {
            name: 'By Depth (Call Distance)',
            description: 'Distance from entry points',
            colorBy: 'depth',
            sizeBy: 'fanout',
            edgeBy: 'type'
        }
        // NOTE: Color schemes (viridis, plasma, thermal, etc.) are now in color-engine.js schemePaths
        // Access via COLOR.listSchemes(), COLOR.applyScheme(), COLOR.getSchemeColor()
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        SCALE_16_LEVELS,
        THREE_LAYERS,
        SMC_THEORY,
        LEVEL_ZONES,
        VIS_PRESETS,

        // Convenience getters
        getLevel: (id) => SCALE_16_LEVELS[id],
        getLayer: (id) => THREE_LAYERS[id],
        getZone: (id) => LEVEL_ZONES[id],
        getPreset: (id) => VIS_PRESETS[id],

        // Theory content accessors (for tooltips)
        getTheoryContent: (category, key) => SMC_THEORY[category]?.[key],
        getLayerTheory: (key) => SMC_THEORY.layers[key],
        getFamilyTheory: (key) => SMC_THEORY.families[key],
        getTierTheory: (key) => SMC_THEORY.tiers[key],
        getSpecialTheory: (key) => SMC_THEORY.special[key]
    };
})();

// =========================================================================
// BACKWARD COMPATIBILITY SHIMS
// =========================================================================

window.SCALE_16_LEVELS = THEORY.SCALE_16_LEVELS;
window.THREE_LAYERS = THEORY.THREE_LAYERS;
window.SMC_THEORY = THEORY.SMC_THEORY;
window.LEVEL_ZONES = THEORY.LEVEL_ZONES;
window.VIS_PRESETS = THEORY.VIS_PRESETS;

console.log('[Module] THEORY loaded - 5 constants, 8 accessors');


// ═══ MODULE: modules/node-accessors.js ═══
/**
 * NODE ACCESSORS MODULE
 *
 * Provides standardized access to node properties across the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   NODE.getTier(node)       // Returns 'T0', 'T1', 'T2', or 'UNKNOWN'
 *   NODE.getFamily(node)     // Returns 'LOG', 'DAT', 'ORG', 'EXE', 'EXT', or 'UNKNOWN'
 *   NODE.getRing(node)       // Returns ring/layer value
 *   NODE.getLayer(node)      // Returns D2_LAYER value
 *   NODE.getEffect(node)     // Returns D6_EFFECT value
 */

const NODE = (function() {
    'use strict';

    // =========================================================================
    // TIER SYSTEM
    // =========================================================================

    // Tier aliases: legacy names -> canonical T0/T1/T2
    const TIER_ALIASES = {
        'CORE': 'T0', 'T0': 'T0',
        'ARCH': 'T1', 'T1': 'T1',
        'EXT': 'T2', 'T2': 'T2',
        'DISCOVERED': 'T2',  // EXT.DISCOVERED -> T2
        'UNKNOWN': 'UNKNOWN'
    };

    function normalizeTier(tier) {
        if (!tier) return 'UNKNOWN';
        const upper = String(tier).toUpperCase();
        return TIER_ALIASES[upper] || upper;
    }

    // Prefer canonical node.tier field; fallback to atom prefix inference
    function getTier(node) {
        // If node is a string (backward compat: called with atomId), infer from prefix
        if (typeof node === 'string') {
            const atomId = node;
            if (!atomId) return 'UNKNOWN';
            if (atomId.startsWith('CORE.')) return 'T0';
            if (atomId.startsWith('ARCH.')) return 'T1';
            if (atomId.startsWith('EXT.')) return 'T2';
            return 'UNKNOWN';
        }
        // Prefer canonical field
        if (node.tier) {
            return normalizeTier(node.tier);
        }
        // Fallback: infer from atom prefix
        const atomId = String(node.atom || '');
        if (atomId.startsWith('CORE.')) return 'T0';
        if (atomId.startsWith('ARCH.')) return 'T1';
        if (atomId.startsWith('EXT.')) return 'T2';
        return 'UNKNOWN';
    }

    // =========================================================================
    // FAMILY SYSTEM
    // =========================================================================

    // Get atom family from canonical field or infer from atom prefix
    function getFamily(node) {
        // Prefer canonical field
        if (node.atom_family) {
            return String(node.atom_family).toUpperCase();
        }
        // Fallback: infer from atom (e.g., "LOG.FNC.M" -> "LOG")
        const atomId = String(node.atom || '');
        const dotIdx = atomId.indexOf('.');
        if (dotIdx > 0) {
            return atomId.substring(0, dotIdx).toUpperCase();
        }
        return 'UNKNOWN';
    }

    // =========================================================================
    // RING SYSTEM
    // =========================================================================

    function normalizeRing(value) {
        if (value === null || value === undefined) return null;
        const ring = String(value).trim().toUpperCase();
        if (!ring) return null;
        const aliases = {
            TEST: 'TESTING'
        };
        return aliases[ring] || ring;
    }

    function getRing(node) {
        const ring = node.ring || node.layer || 'UNKNOWN';
        return normalizeRing(ring) || 'UNKNOWN';
    }

    // =========================================================================
    // LAYER SYSTEM (D2_LAYER)
    // =========================================================================

    function getLayer(node) {
        if (!node) return 'Unknown';
        return node.layer || node.dimensions?.D2_LAYER || 'Unknown';
    }

    // =========================================================================
    // EFFECT SYSTEM (D6_EFFECT)
    // =========================================================================

    function getEffect(node) {
        if (!node) return 'Unknown';
        return node.effect || node.dimensions?.D6_EFFECT || 'Unknown';
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Tier
        getTier,
        normalizeTier,
        TIER_ALIASES,

        // Family
        getFamily,

        // Ring
        getRing,
        normalizeRing,

        // Layer
        getLayer,

        // Effect
        getEffect
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'getNodeTier', { get: () => NODE.getTier, configurable: true });
Object.defineProperty(window, 'getNodeAtomFamily', { get: () => NODE.getFamily, configurable: true });
Object.defineProperty(window, 'getNodeRing', { get: () => NODE.getRing, configurable: true });
Object.defineProperty(window, 'getNodeLayer', { get: () => NODE.getLayer, configurable: true });
Object.defineProperty(window, 'getNodeEffect', { get: () => NODE.getEffect, configurable: true });
Object.defineProperty(window, 'normalizeTier', { get: () => NODE.normalizeTier, configurable: true });
Object.defineProperty(window, 'normalizeRingValue', { get: () => NODE.normalizeRing, configurable: true });
Object.defineProperty(window, 'TIER_ALIASES', { get: () => NODE.TIER_ALIASES, configurable: true });


// ═══ MODULE: modules/node-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * NODE-HELPERS MODULE - Node classification and color functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node color mode selection, data enrichment helpers, and tier grouping.
 * Depends on: COLOR (ColorOrchestrator), NODE (node-accessors), DM, Graph
 *
 * @module NODE_HELPERS
 * @version 1.0.0
 */

window.NODE_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR BY MODE
    // ═══════════════════════════════════════════════════════════════════════

    // =========================================================================
    // MODE_ACCESSORS: Declarative map replacing the mega-switch
    // Each mode maps to a function: (node, Color) => colorString
    // =========================================================================

    const MODE_ACCESSORS = {
        // 1. ARCHITECTURE
        tier:           (n, C) => C.get('tier', window.getNodeTier(n)),
        layer:          (n, C) => C.get('layer', (n.layer || n.dimensions?.D2_LAYER || 'UNKNOWN').toUpperCase()),
        subsystem:      (n, C) => C.get('subsystem', getSubsystem(n)),
        boundary_score: (n, C) => C.getInterval('boundary_score', window.normalize(n.rpbl?.boundary ?? 1, 9)),
        phase:          (n, C) => C.get('phase', getPhase(n)),

        // 2. TAXONOMY
        atom:           (n, C) => C.get('atom', (n.kind || n.type || 'unknown').toLowerCase()),
        family:         (n, C) => C.get('family', window.getNodeAtomFamily(n)),
        role:           (n, C) => C.get('roleCategory', n.role_cat || 'Unknown'),
        roleCategory:   (n, C) => C.get('roleCategory', n.role_cat || getRoleCategory(n)),
        fileType:       (n, C) => C.get('fileType', getFileType(n)),

        // 3. METRICS
        complexity:     (n, C) => C.getInterval('complexity', window.normalize(n.complexity || 0, 20)),
        loc:            (n, C) => C.getInterval('loc', window.normalize(n.lines_of_code || 0, 500)),
        fan_in:         (n, C) => C.getInterval('fan_in', window.normalize(n.in_degree || 0, 20)),
        fan_out:        (n, C) => C.getInterval('fan_out', window.normalize(n.out_degree || 0, 20)),
        trust:          (n, C) => C.getInterval('trust', n.trust || n.confidence || 0),

        // 4. RPBL DNA
        responsibility: (n, C) => C.getInterval('responsibility', window.normalize(n.rpbl?.responsibility ?? 1, 9)),
        purity:         (n, C) => C.getInterval('purity', window.normalize(n.rpbl?.purity ?? 1, 9)),
        lifecycle_score:(n, C) => C.getInterval('lifecycle_score', window.normalize(n.rpbl?.lifecycle ?? 1, 9)),
        state:          (n, C) => C.get('state', (n.dimensions?.D5_STATE === 'Stateful') ? 'Stateful' : 'Stateless'),
        visibility:     (n, C) => C.get('visibility', n.dimensions?.D4_BOUNDARY === 'External' ? 'Public' : 'Private'),

        // 5. TOPOLOGY
        centrality:     (n, C) => C.getInterval('centrality', n.centrality || 0),
        rank:           (n, C) => C.getInterval('centrality', n.pagerank || 0),
        ring:           (n, C) => C.get('ring', window.getNodeRing(n)),

        // 6. EVOLUTION (Placeholders)
        churn:          (n, C) => C.getInterval('churn', Math.random() * 0.5),
        age:            (n, C) => C.getInterval('churn', 0.2)
    };

    function getNodeColorByMode(node) {
        const Color = window.Color;
        const NODE_COLOR_MODE = window.NODE_COLOR_MODE;
        const DM = window.DM;

        // Special case: CODOME boundary nodes (external callers)
        // Always use their explicit color_hint, regardless of color mode
        if (node.is_codome_boundary || node.kind === 'boundary') {
            if (node.color_hint) {
                return node.color_hint;
            }
            // Fallback color mapping by codome_source
            const CODOME_COLORS = {
                'test_entry': '#4CAF50',      // Green
                'entry_point': '#2196F3',     // Blue
                'framework_managed': '#9C27B0', // Purple
                'cross_language': '#FF9800',  // Orange
                'external_boundary': '#00BCD4', // Cyan
                'dynamic_target': '#E91E63'   // Pink
            };
            return CODOME_COLORS[node.codome_source] || '#FF9800';
        }

        // Special case: file coloring needs extra context
        if (NODE_COLOR_MODE === 'file') {
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx < 0) return Color.get('tier', 'UNKNOWN');
            const fileBoundaries = DM ? DM.getFileBoundaries() : [];
            const totalFiles = fileBoundaries.length;
            const fileInfo = fileBoundaries[fileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            return window.getFileColor(fileIdx, totalFiles, fileLabel);
        }

        // Use MODE_ACCESSORS map - O(1) lookup instead of if-chain
        const accessor = MODE_ACCESSORS[NODE_COLOR_MODE];
        if (accessor) return accessor(node, Color);

        // Default fallback
        return Color.get('tier', window.getNodeTier(node));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA ENRICHMENT HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getSubsystem(node) {
        if (!node.file_path) return 'Unknown';
        if (node.file_path.includes('/api/')) return 'Ingress';
        if (node.file_path.includes('/db/') || node.file_path.includes('repository')) return 'Persistence';
        if (node.file_path.includes('/core/') || node.file_path.includes('domain')) return 'Domain';
        if (node.file_path.includes('/ui/') || node.file_path.includes('frontend')) return 'Presentation';
        if (node.file_path.includes('config')) return 'Config';
        return 'Domain';
    }

    function getPhase(node) {
        const kind = (node.kind || '').toLowerCase();
        if (kind.includes('data') || kind.includes('entity') || kind.includes('schema')) return 'DATA';
        if (kind.includes('function') || kind.includes('logic')) return 'LOGIC';
        if (kind.includes('module') || kind.includes('package')) return 'ORGANIZATION';
        if (kind.includes('script') || kind.includes('main')) return 'EXECUTION';
        return 'LOGIC';
    }

    function getFileType(node) {
        const p = node.file_path || node.id || '';
        const ext = p.split('.').pop().toLowerCase();
        return ext || 'unknown';
    }

    function getRoleCategory(node) {
        const r = (node.role || '').toLowerCase();
        if (r.includes('service') || r.includes('manager')) return 'Orchestration';
        if (r.includes('repo') || r.includes('store')) return 'Storage';
        if (r.includes('controller') || r.includes('handler')) return 'Ingress';
        if (r.includes('util') || r.includes('helper')) return 'Utility';
        return 'Unknown';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR APPLICATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeColors(nodes) {
        const DM = window.DM;
        const fileBoundaries = DM ? DM.getFileBoundaries() : [];
        nodes.forEach(node => {
            if (node && node.isFileNode) {
                if (!node.color) {
                    const totalFiles = fileBoundaries.length;
                    const fileInfo = fileBoundaries[node.fileIdx] || {};
                    const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                    node.color = window.getFileColor(node.fileIdx, totalFiles, fileLabel);
                }
                return;
            }
            if (window.fileMode) {
                return;
            }
            // For boundary nodes, always apply their specific color
            if (node.is_codome_boundary || node.kind === 'boundary') {
                node.color = getNodeColorByMode(node);
                return;
            }
            node.color = getNodeColorByMode(node);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SIZE MODE
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeSizeMode(mode) {
        const Graph = window.Graph;
        if (!Graph) return;
        const scale = window.APPEARANCE_STATE?.nodeScale || 1;
        const BOUNDARY_NODE_SIZE_MULTIPLIER = 1.5; // Boundary nodes 1.5x larger

        const isBoundaryNode = (n) => n.is_codome_boundary || n.kind === 'boundary';
        const sizeWithBoundaryCheck = (baseSize) =>
            isBoundaryNode({ is_codome_boundary: arguments[0]?.is_codome_boundary, kind: arguments[0]?.kind })
                ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER
                : baseSize;

        switch (mode) {
            case 'uniform':
                Graph.nodeVal(n => (isBoundaryNode(n) ? 1.5 : 1) * scale);
                break;
            case 'degree':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, ((n.in_degree || 0) + (n.out_degree || 0)) * 0.5);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'fanout':
                Graph.nodeVal(n => {
                    const baseSize = n.val || n.fanout || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'complexity':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, (n.complexity || n.loc || 10) * 0.05);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            default:
                Graph.nodeVal(n => {
                    const baseSize = n.val || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER/DEPTH/SIMILARITY HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNodeTierValue(node) {
        if (!node) return 1;
        const tier = window.getNodeTier(node);
        if (tier === 'T0') return 0;
        if (tier === 'T1') return 1;
        if (tier === 'T2') return 2;
        return 1;
    }

    function getNodeDepth(node) {
        if (node && typeof node.y === 'number') {
            return Math.abs(node.y) / 500;
        }
        return 0.5;
    }

    function getSemanticSimilarity(srcNode, tgtNode) {
        if (!srcNode || !tgtNode) return 0.5;
        let score = 0;
        if (srcNode.type === tgtNode.type) score += 0.4;
        if (srcNode.fileIdx === tgtNode.fileIdx) score += 0.3;
        if (window.getNodeTier(srcNode) === window.getNodeTier(tgtNode)) score += 0.2;
        if (srcNode.ring === tgtNode.ring) score += 0.1;
        return score;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER GROUPING
    // ═══════════════════════════════════════════════════════════════════════

    function groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = window.getNodeTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getColorByMode: getNodeColorByMode,
        getSubsystem: getSubsystem,
        getPhase: getPhase,
        getFileType: getFileType,
        getRoleCategory: getRoleCategory,
        applyColors: applyNodeColors,
        applySizeMode: applyNodeSizeMode,
        getTierValue: getNodeTierValue,
        getDepth: getNodeDepth,
        getSemanticSimilarity: getSemanticSimilarity,
        groupByTier: groupNodesByTier
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getNodeColorByMode = NODE_HELPERS.getColorByMode;
window.getSubsystem = NODE_HELPERS.getSubsystem;
window.getPhase = NODE_HELPERS.getPhase;
window.getFileType = NODE_HELPERS.getFileType;
window.getRoleCategory = NODE_HELPERS.getRoleCategory;
window.applyNodeColors = NODE_HELPERS.applyColors;
window.applyNodeSizeMode = NODE_HELPERS.applySizeMode;
window.getNodeTierValue = NODE_HELPERS.getTierValue;
window.getNodeDepth = NODE_HELPERS.getDepth;
window.getSemanticSimilarity = NODE_HELPERS.getSemanticSimilarity;
window.groupNodesByTier = NODE_HELPERS.groupByTier;

console.log('[Module] NODE_HELPERS loaded - 11 functions');


// ═══ MODULE: modules/color-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * COLOR-HELPERS MODULE - Color utilities and conversions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Topology colors, color normalization, file hue generation.
 * Depends on: UTILS (parseOklchString, hashToUnit, clampValue), COLOR (oklchColor)
 *
 * @module COLOR_HELPERS
 * @version 1.0.0
 */

window.COLOR_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // TOPOLOGY COLOR LOOKUP
    // ═══════════════════════════════════════════════════════════════════════

    function getTopoColor(category, key) {
        const APPEARANCE_CONFIG = window.APPEARANCE_CONFIG;
        if (!APPEARANCE_CONFIG || !APPEARANCE_CONFIG.color) return { l: 50, c: 0, h: 0 };

        let tokenKey = key;
        let section = 'atom-family'; // Default

        // Map legacy/UI keys to Token keys
        if (category === 'tiers') {
            section = 'atom';
            if (key === 'T0') tokenKey = 't0-core';
            else if (key === 'T1') tokenKey = 't1-arch';
            else if (key === 'T2') tokenKey = 't2-eco';
            else if (key === 'UNKNOWN') tokenKey = 'unknown';
        } else if (category === 'rings') {
            section = 'ring';
            if (key === 'KERNEL') tokenKey = 'DOMAIN';
            if (key === 'CORE') tokenKey = 'APPLICATION';
            if (key === 'SERVICE') tokenKey = 'PRESENTATION';
            if (key === 'ADAPTER') tokenKey = 'INTERFACE';
        } else if (category === 'families') {
            section = 'atom-family';
        }

        // Lookup token
        const tokenStr = APPEARANCE_CONFIG.color[section]?.[tokenKey] || APPEARANCE_CONFIG.color[section]?.['UNKNOWN'];

        // Parse OKLCH
        const parsed = window.parseOklchString(tokenStr);
        if (!parsed) return { l: 50, c: 0, h: 0 }; // Fallback gray

        // Normalize to internal l,c,h format (lowercase)
        return { l: parsed.L * 100, c: parsed.C, h: parsed.H };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLOR NORMALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeColorInput(color, fallback = 'rgb(128, 128, 128)') {
        if (color === null || color === undefined) {
            return fallback;
        }
        if (typeof color !== 'string') {
            return color;
        }
        const parsed = window.parseOklchString(color);
        if (parsed) {
            return window.oklchColor(parsed.L, parsed.C, parsed.H, parsed.A);
        }
        return color;
    }

    function toColorNumber(color, fallback = '#777777') {
        // Returns CSS hex string (polished-compatible) instead of JS hex int
        if (typeof color === 'number') {
            return '#' + color.toString(16).padStart(6, '0');
        }
        if (typeof color !== 'string') {
            return fallback;
        }
        const normalized = normalizeColorInput(color);
        if (typeof normalized === 'string') {
            color = normalized;
        }
        if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl')) {
            return color;  // Already valid CSS color
        }
        try {
            const hex = new THREE.Color(color).getHex();
            return '#' + hex.toString(16).padStart(6, '0');
        } catch (err) {
            return fallback;
        }
    }

    function dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILE COLOR GENERATION
    // ═══════════════════════════════════════════════════════════════════════

    function getFileHue(fileIdx, totalFiles, fileName) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const strategy = FILE_COLOR_CONFIG.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return window.hashToUnit(seed) * 360;
        }
        const angle = FILE_COLOR_CONFIG.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const COLOR_TWEAKS = window.COLOR_TWEAKS || {};
        const saturation = FILE_COLOR_CONFIG.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (FILE_COLOR_CONFIG.lightness ?? 50);
        const hue = getFileHue(fileIdx, totalFiles, fileName);
        if (typeof FILE_COLOR_CONFIG.chroma === 'number') {
            return window.oklchColor(lightness, FILE_COLOR_CONFIG.chroma, hue);
        }
        const adjustedHue = hue + (COLOR_TWEAKS.hueShift || 0);
        const adjustedLightness = window.clampValue(lightness + (COLOR_TWEAKS.lightnessShift || 0), 0, 100);
        return `hsl(${adjustedHue}, ${saturation}%, ${adjustedLightness}%)`;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getTopoColor: getTopoColor,
        normalizeInput: normalizeColorInput,
        toNumber: toColorNumber,
        dim: dimColor,
        getFileHue: getFileHue,
        getFileColor: getFileColor
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getTopoColor = COLOR_HELPERS.getTopoColor;
window.normalizeColorInput = COLOR_HELPERS.normalizeInput;
window.toColorNumber = COLOR_HELPERS.toNumber;
window.dimColor = COLOR_HELPERS.dim;
window.getFileHue = COLOR_HELPERS.getFileHue;
window.getFileColor = COLOR_HELPERS.getFileColor;

console.log('[Module] COLOR_HELPERS loaded - 6 functions');


// ═══ MODULE: modules/color-engine.js ═══
/**
 * COLOR ENGINE MODULE
 *
 * Centralized Color Intelligence System using OKLCH color space.
 * Single source of truth for ALL colors in the visualization.
 * Everything reads from here. OKLCH transforms apply here.
 *
 * Usage:
 *   COLOR.get('tier', 'T0')              // Get hex color for tier T0
 *   COLOR.getInterval('markov', 0.5)     // Get interpolated color
 *   COLOR.setTransform('hueShift', 30)   // Shift all hues by 30 degrees
 *   COLOR.subscribe(callback)            // React to transform changes
 */

const COLOR = (function () {
    'use strict';

    // =========================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =========================================================================

    const palette = {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        atom: {
            // Function-like (Green-Cyan)
            'function': { h: 160, c: 0.20, l: 0.65, label: 'Function', semantic: 'logic' },
            'method': { h: 175, c: 0.20, l: 0.62, label: 'Method', semantic: 'logic' },
            'closure': { h: 190, c: 0.20, l: 0.60, label: 'Closure', semantic: 'logic' },
            // Class-like (Blue-Purple)
            'class': { h: 260, c: 0.22, l: 0.60, label: 'Class', semantic: 'structure' },
            'interface': { h: 280, c: 0.20, l: 0.65, label: 'Interface', semantic: 'abstraction' },
            'struct': { h: 240, c: 0.20, l: 0.60, label: 'Struct', semantic: 'data' },
            // Module/Package (Orange-Yellow)
            'module': { h: 45, c: 0.22, l: 0.70, label: 'Module', semantic: 'container' },
            'package': { h: 30, c: 0.24, l: 0.65, label: 'Package', semantic: 'container' },
            // Variables/Fields (Pink-Red)
            'variable': { h: 340, c: 0.18, l: 0.65, label: 'Variable', semantic: 'state' },
            'field': { h: 350, c: 0.18, l: 0.62, label: 'Field', semantic: 'state' },
            // Unknown
            'unknown': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        roleCategory: {
            'Query': { h: 190, c: 0.20, l: 0.65, label: 'Query', semantic: 'read' },         // Cyan
            'Command': { h: 25, c: 0.24, l: 0.60, label: 'Command', semantic: 'write' },     // Orange/Red
            'Factory': { h: 280, c: 0.22, l: 0.60, label: 'Factory', semantic: 'create' },   // Purple
            'Storage': { h: 140, c: 0.20, l: 0.65, label: 'Storage', semantic: 'persist' },  // Green
            'Orchestration': { h: 240, c: 0.22, l: 0.60, label: 'Orchestration', semantic: 'manage' }, // Blue
            'Validation': { h: 45, c: 0.24, l: 0.70, label: 'Validation', semantic: 'check' }, // Yellow
            'Transform': { h: 320, c: 0.20, l: 0.60, label: 'Transform', semantic: 'change' }, // Pink
            'Event': { h: 260, c: 0.22, l: 0.65, label: 'Event', semantic: 'async' },        // Violet
            'Utility': { h: 200, c: 0.10, l: 0.70, label: 'Utility', semantic: 'helper' },   // Light Blue
            'Internal': { h: 0, c: 0.00, l: 0.60, label: 'Internal', semantic: 'private' },  // Gray
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        subsystem: {
            'Ingress': { h: 220, c: 0.24, l: 0.60, label: 'Ingress', semantic: 'entry' },
            'Egress': { h: 20, c: 0.24, l: 0.60, label: 'Egress', semantic: 'exit' },
            'Domain': { h: 260, c: 0.24, l: 0.55, label: 'Domain Core', semantic: 'core' },
            'Persistence': { h: 142, c: 0.22, l: 0.65, label: 'Persistence', semantic: 'store' },
            'Async': { h: 300, c: 0.22, l: 0.60, label: 'Async', semantic: 'bg' },
            'Presentation': { h: 190, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'ui' },
            'Security': { h: 0, c: 0.26, l: 0.55, label: 'Security', semantic: 'guard' },
            'Observability': { h: 60, c: 0.22, l: 0.75, label: 'Observability', semantic: 'monitor' },
            'Config': { h: 290, c: 0.18, l: 0.65, label: 'config', semantic: 'setup' },
            'Delivery': { h: 30, c: 0.20, l: 0.70, label: 'Delivery', semantic: 'ops' },
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        phase: {
            'DATA': { h: 142, c: 0.22, l: 0.65, label: 'Data', semantic: 'structure' },
            'LOGIC': { h: 240, c: 0.24, l: 0.60, label: 'Logic', semantic: 'flow' },
            'ORGANIZATION': { h: 280, c: 0.22, l: 0.60, label: 'Organization', semantic: 'arch' },
            'EXECUTION': { h: 20, c: 0.26, l: 0.60, label: 'Execution', semantic: 'run' }
        },
        state: {
            'Stateless': { h: 220, c: 0.20, l: 0.70, label: 'Stateless', semantic: 'pure' }, // Light Blue
            'Stateful': { h: 20, c: 0.24, l: 0.60, label: 'Stateful', semantic: 'impure' }   // Orange
        },
        effect: {
            'Pure': { h: 142, c: 0.22, l: 0.70, label: 'Pure', semantic: 'safe' },          // Green
            'SideEffect': { h: 340, c: 0.22, l: 0.60, label: 'Side Effect', semantic: 'risk' } // Pink/Red
        },
        visibility: {
            'Public': { h: 220, c: 0.20, l: 0.65, label: 'Public', semantic: 'open' },
            'Private': { h: 0, c: 0.05, l: 0.55, label: 'Private', semantic: 'closed' },
            'Internal': { h: 280, c: 0.15, l: 0.60, label: 'Internal', semantic: 'module' }
        },
        fileType: {
            'js': { h: 60, c: 0.24, l: 0.70, label: 'JavaScript', semantic: 'code' },    // Yellow
            'ts': { h: 240, c: 0.22, l: 0.60, label: 'TypeScript', semantic: 'code' },    // Blue
            'py': { h: 220, c: 0.20, l: 0.62, label: 'Python', semantic: 'code' },        // Blue
            'go': { h: 190, c: 0.22, l: 0.68, label: 'Go', semantic: 'code' },            // Cyan
            'rs': { h: 30, c: 0.24, l: 0.60, label: 'Rust', semantic: 'code' },           // Orange
            'java': { h: 40, c: 0.24, l: 0.62, label: 'Java', semantic: 'code' },         // Orange/Red
            'c': { h: 210, c: 0.18, l: 0.60, label: 'C', semantic: 'code' },             // Blue
            'cpp': { h: 210, c: 0.20, l: 0.55, label: 'C++', semantic: 'code' },          // Blue
            'h': { h: 280, c: 0.16, l: 0.60, label: 'Header', semantic: 'code' },         // Purple
            'html': { h: 20, c: 0.25, l: 0.60, label: 'HTML', semantic: 'markup' },       // Orange
            'css': { h: 230, c: 0.24, l: 0.60, label: 'CSS', semantic: 'style' },         // Blue
            'json': { h: 60, c: 0.18, l: 0.75, label: 'JSON', semantic: 'data' },         // Yellow
            'yaml': { h: 300, c: 0.18, l: 0.65, label: 'YAML', semantic: 'config' },      // Magenta
            'md': { h: 0, c: 0.04, l: 0.70, label: 'Markdown', semantic: 'doc' },         // Gray
            'unknown': { h: 0, c: 0.02, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    };

    // =========================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =========================================================================

    const transform = {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    };

    // =========================================================================
    // INTERVAL MAPPINGS: For numeric data -> color gradients
    // =========================================================================

    const intervals = {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        },
        complexity: {
            stops: [
                { value: 0.0, h: 142, c: 0.18, l: 0.70 },  // Low complexity (0) - Green
                { value: 0.3, h: 100, c: 0.18, l: 0.75 },  // Moderate (5-10) - Yellow-Green
                { value: 0.6, h: 50, c: 0.20, l: 0.70 },   // High (10-20) - Orange
                { value: 1.0, h: 15, c: 0.24, l: 0.60 }    // Very High (20+) - Red
            ]
        },
        churn: {
            stops: [
                { value: 0.0, h: 230, c: 0.10, l: 0.45 },  // Stale/Cold - Blue
                { value: 0.5, h: 300, c: 0.14, l: 0.60 },  // Active - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // Hot - Orange/Red
            ]
        },
        loc: {
            stops: [
                { value: 0.0, h: 200, c: 0.10, l: 0.75 },  // Small - Light Blue
                { value: 0.3, h: 240, c: 0.18, l: 0.60 },  // Medium - Blue
                { value: 0.7, h: 280, c: 0.20, l: 0.50 },  // Large - Purple
                { value: 1.0, h: 320, c: 0.22, l: 0.40 }   // Massive - Dark Purple
            ]
        },
        trust: {
            stops: [
                { value: 0.0, h: 0, c: 0.24, l: 0.50 },    // Untrusted - Red
                { value: 0.5, h: 60, c: 0.20, l: 0.70 },   // Warning - Yellow
                { value: 1.0, h: 142, c: 0.22, l: 0.65 }   // Trusted - Green
            ]
        },
        responsibility: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Single Purpose (1) - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.75 },   // Moderate (5) - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // God Object (9) - Red
            ]
        },
        purity: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Pure (1) - Green
                { value: 0.5, h: 220, c: 0.18, l: 0.65 },  // Mixed (5) - Blue
                { value: 1.0, h: 320, c: 0.24, l: 0.55 }   // I/O Heavy (9) - Purple/Red
            ]
        },
        boundary_score: {
            stops: [
                { value: 0.0, h: 240, c: 0.15, l: 0.65 },  // Internal (1) - Blue
                { value: 0.5, h: 280, c: 0.18, l: 0.60 },  // Module (5) - Purple
                { value: 1.0, h: 20, c: 0.24, l: 0.60 }    // External API (9) - Orange
            ]
        },
        lifecycle_score: {
            stops: [
                { value: 0.0, h: 180, c: 0.15, l: 0.70 },  // Ephemeral (1) - Cyan
                { value: 0.5, h: 220, c: 0.18, l: 0.60 },  // Managed (5) - Blue
                { value: 1.0, h: 280, c: 0.22, l: 0.50 }   // Singleton (9) - Purple
            ]
        },
        centrality: {
            stops: [
                { value: 0.0, h: 240, c: 0.05, l: 0.40 },  // Periphery - Gray/Blue
                { value: 0.5, h: 280, c: 0.20, l: 0.60 },  // Bridge - Purple
                { value: 1.0, h: 340, c: 0.25, l: 0.65 }   // Core - Pink/Red
            ]
        },
        fan_in: {
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.65 },  // Low - Blue
                { value: 0.5, h: 300, c: 0.18, l: 0.60 },  // Med - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // High - Orange
            ]
        },
        fan_out: {
            stops: [
                { value: 0.0, h: 142, c: 0.15, l: 0.65 },  // Low - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.70 },   // Med - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // High - Red
            ]
        }
    };

    // =========================================================================
    // SCHEME PATHS: 33 Named Color Gradients (OKLCH 3D Paths)
    // Each scheme is a path through OKLCH color space mapping normalized values to colors
    // =========================================================================

    const schemePaths = {
        // =====================================================================
        // PART A: FAMOUS SCIENTIFIC GRADIENTS (15 schemes)
        // Source: matplotlib/viridis family - perceptually uniform
        // =====================================================================

        // === SEQUENTIAL (monotonic lightness) ===
        viridis: {
            name: 'Viridis',
            semantic: 'The gold standard - blue→green→yellow',
            stops: [
                { value: 0.0, h: 280, c: 0.12, l: 0.25 },  // Dark purple
                { value: 0.25, h: 240, c: 0.16, l: 0.40 }, // Blue
                { value: 0.5, h: 170, c: 0.18, l: 0.55 },  // Teal
                { value: 0.75, h: 120, c: 0.20, l: 0.70 }, // Green
                { value: 1.0, h: 65, c: 0.22, l: 0.90 }    // Yellow
            ]
        },
        plasma: {
            name: 'Plasma',
            semantic: 'Purple→pink→orange→yellow arc',
            stops: [
                { value: 0.0, h: 280, c: 0.15, l: 0.20 },  // Deep purple
                { value: 0.25, h: 300, c: 0.22, l: 0.40 }, // Magenta
                { value: 0.5, h: 340, c: 0.25, l: 0.55 },  // Pink-red
                { value: 0.75, h: 30, c: 0.28, l: 0.72 },  // Orange
                { value: 1.0, h: 60, c: 0.24, l: 0.92 }    // Bright yellow
            ]
        },
        magma: {
            name: 'Magma',
            semantic: 'Black→purple→orange→white (lava)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.08 },  // Near black
                { value: 0.25, h: 300, c: 0.18, l: 0.30 }, // Deep purple
                { value: 0.5, h: 340, c: 0.24, l: 0.50 },  // Magenta
                { value: 0.75, h: 30, c: 0.26, l: 0.75 },  // Orange
                { value: 1.0, h: 60, c: 0.08, l: 0.98 }    // Near white
            ]
        },
        inferno: {
            name: 'Inferno',
            semantic: 'Black→purple→red→yellow (fire)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.05 },  // Black
                { value: 0.2, h: 300, c: 0.16, l: 0.25 },  // Purple
                { value: 0.4, h: 350, c: 0.24, l: 0.45 },  // Red-purple
                { value: 0.6, h: 20, c: 0.28, l: 0.60 },   // Red-orange
                { value: 0.8, h: 50, c: 0.26, l: 0.78 },   // Orange-yellow
                { value: 1.0, h: 65, c: 0.18, l: 0.95 }    // Bright yellow
            ]
        },
        cividis: {
            name: 'Cividis',
            semantic: 'Blue→yellow (colorblind optimized)',
            stops: [
                { value: 0.0, h: 240, c: 0.10, l: 0.25 },  // Dark blue
                { value: 0.33, h: 220, c: 0.08, l: 0.45 }, // Steel blue
                { value: 0.66, h: 80, c: 0.08, l: 0.65 },  // Olive
                { value: 1.0, h: 60, c: 0.14, l: 0.88 }    // Yellow
            ]
        },
        turbo: {
            name: 'Turbo',
            semantic: 'Improved rainbow (no banding)',
            stops: [
                { value: 0.0, h: 260, c: 0.18, l: 0.35 },  // Blue-purple
                { value: 0.2, h: 210, c: 0.22, l: 0.55 },  // Cyan-blue
                { value: 0.4, h: 150, c: 0.24, l: 0.65 },  // Green
                { value: 0.6, h: 60, c: 0.26, l: 0.75 },   // Yellow
                { value: 0.8, h: 30, c: 0.28, l: 0.65 },   // Orange
                { value: 1.0, h: 0, c: 0.24, l: 0.50 }     // Red
            ]
        },
        mako: {
            name: 'Mako',
            semantic: 'Deep ocean blue→teal',
            stops: [
                { value: 0.0, h: 260, c: 0.08, l: 0.12 },  // Abyss
                { value: 0.33, h: 240, c: 0.14, l: 0.35 }, // Deep blue
                { value: 0.66, h: 200, c: 0.18, l: 0.58 }, // Ocean blue
                { value: 1.0, h: 170, c: 0.16, l: 0.82 }   // Light teal
            ]
        },
        rocket: {
            name: 'Rocket',
            semantic: 'Dark→red→white (heat)',
            stops: [
                { value: 0.0, h: 280, c: 0.06, l: 0.10 },  // Dark
                { value: 0.33, h: 340, c: 0.20, l: 0.35 }, // Purple-red
                { value: 0.66, h: 15, c: 0.26, l: 0.60 },  // Red-orange
                { value: 1.0, h: 30, c: 0.08, l: 0.95 }    // Near white
            ]
        },

        // === DIVERGING (center-outward) ===
        coolwarm: {
            name: 'Coolwarm',
            semantic: 'Blue↔neutral↔red (diverging)',
            stops: [
                { value: 0.0, h: 230, c: 0.22, l: 0.45 },  // Cool blue
                { value: 0.25, h: 220, c: 0.12, l: 0.60 }, // Light blue
                { value: 0.5, h: 0, c: 0.02, l: 0.75 },    // Neutral gray
                { value: 0.75, h: 20, c: 0.14, l: 0.60 },  // Light red
                { value: 1.0, h: 15, c: 0.24, l: 0.45 }    // Warm red
            ]
        },
        spectral: {
            name: 'Spectral',
            semantic: 'Full rainbow diverging',
            stops: [
                { value: 0.0, h: 10, c: 0.22, l: 0.50 },   // Red
                { value: 0.25, h: 40, c: 0.24, l: 0.70 },  // Orange-yellow
                { value: 0.5, h: 60, c: 0.20, l: 0.85 },   // Yellow (center)
                { value: 0.75, h: 140, c: 0.20, l: 0.65 }, // Green
                { value: 1.0, h: 240, c: 0.18, l: 0.50 }   // Blue
            ]
        },

        // === APPLICATION-SPECIFIC ===
        thermal: {
            name: 'Thermal',
            semantic: 'Cold→hot temperature map',
            stops: [
                { value: 0.0, h: 240, c: 0.18, l: 0.30 },  // Cold blue
                { value: 0.25, h: 200, c: 0.20, l: 0.45 }, // Cool cyan
                { value: 0.5, h: 60, c: 0.22, l: 0.65 },   // Warm yellow
                { value: 0.75, h: 30, c: 0.26, l: 0.58 },  // Hot orange
                { value: 1.0, h: 0, c: 0.28, l: 0.50 }     // Burning red
            ]
        },
        nightvision: {
            name: 'Night Vision',
            semantic: 'Phosphor green display',
            stops: [
                { value: 0.0, h: 140, c: 0.02, l: 0.05 },  // Black
                { value: 0.33, h: 140, c: 0.12, l: 0.25 }, // Dark green
                { value: 0.66, h: 130, c: 0.22, l: 0.55 }, // Bright green
                { value: 1.0, h: 120, c: 0.28, l: 0.85 }   // Glowing green
            ]
        },
        ocean: {
            name: 'Ocean',
            semantic: 'Bathymetry depth map',
            stops: [
                { value: 0.0, h: 250, c: 0.12, l: 0.15 },  // Abyss
                { value: 0.33, h: 230, c: 0.18, l: 0.35 }, // Deep
                { value: 0.66, h: 200, c: 0.20, l: 0.55 }, // Mid-depth
                { value: 1.0, h: 180, c: 0.16, l: 0.80 }   // Shallow
            ]
        },
        terrain: {
            name: 'Terrain',
            semantic: 'Water→land→mountain',
            stops: [
                { value: 0.0, h: 220, c: 0.16, l: 0.40 },  // Water blue
                { value: 0.3, h: 140, c: 0.18, l: 0.55 },  // Lowland green
                { value: 0.5, h: 80, c: 0.16, l: 0.60 },   // Plains yellow-green
                { value: 0.7, h: 40, c: 0.14, l: 0.50 },   // Hills brown
                { value: 1.0, h: 0, c: 0.04, l: 0.90 }     // Snow white
            ]
        },
        electric: {
            name: 'Electric',
            semantic: 'Neon cyberpunk glow',
            stops: [
                { value: 0.0, h: 280, c: 0.25, l: 0.30 },  // Deep purple
                { value: 0.33, h: 320, c: 0.30, l: 0.50 }, // Hot pink
                { value: 0.66, h: 190, c: 0.28, l: 0.65 }, // Electric cyan
                { value: 1.0, h: 60, c: 0.26, l: 0.85 }    // Neon yellow
            ]
        },

        // =====================================================================
        // PART B: ROLE-SEMANTIC GRADIENTS (18 schemes)
        // Named after canonical roles with meaningful color journeys
        // =====================================================================

        // === GROUP 1: QUERIES & ACCESS (Cool blues/cyans - passive reads) ===
        query: {
            name: 'Query',
            semantic: 'Retrieve data calmly',
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },  // Deep blue - start
                { value: 0.5, h: 200, c: 0.15, l: 0.55 },  // Sky blue - middle
                { value: 1.0, h: 190, c: 0.20, l: 0.70 }   // Light cyan - found
            ]
        },
        finder: {
            name: 'Finder',
            semantic: 'Search and seek',
            stops: [
                { value: 0.0, h: 200, c: 0.05, l: 0.35 },  // Dim - searching
                { value: 0.3, h: 180, c: 0.12, l: 0.50 },  // Teal - hunting
                { value: 0.7, h: 160, c: 0.18, l: 0.65 },  // Cyan-green - close
                { value: 1.0, h: 140, c: 0.24, l: 0.75 }   // Bright green - found!
            ]
        },

        // === GROUP 2: COMMANDS & MUTATIONS (Warm - active writes) ===
        command: {
            name: 'Command',
            semantic: 'Execute with authority',
            stops: [
                { value: 0.0, h: 30, c: 0.15, l: 0.45 },   // Amber ready
                { value: 0.5, h: 20, c: 0.22, l: 0.58 },   // Orange active
                { value: 1.0, h: 10, c: 0.28, l: 0.65 }    // Red-orange fired
            ]
        },
        creator: {
            name: 'Creator',
            semantic: 'Bring into existence',
            stops: [
                { value: 0.0, h: 180, c: 0.10, l: 0.40 },  // Seed teal
                { value: 0.4, h: 150, c: 0.18, l: 0.55 },  // Sprout green
                { value: 0.8, h: 120, c: 0.24, l: 0.68 },  // Growth lime
                { value: 1.0, h: 90, c: 0.28, l: 0.75 }    // Full bloom yellow-green
            ]
        },
        destroyer: {
            name: 'Destroyer',
            semantic: 'Remove from existence',
            stops: [
                { value: 0.0, h: 0, c: 0.08, l: 0.60 },    // Pale warning
                { value: 0.4, h: 10, c: 0.18, l: 0.50 },   // Red alert
                { value: 0.7, h: 350, c: 0.26, l: 0.40 },  // Crimson
                { value: 1.0, h: 340, c: 0.20, l: 0.25 }   // Dark destruction
            ]
        },

        // === GROUP 3: FACTORIES (Construction - blue→green) ===
        factory: {
            name: 'Factory',
            semantic: 'Assembly line production',
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.45 },  // Blueprint blue
                { value: 0.3, h: 200, c: 0.16, l: 0.55 },  // Processing
                { value: 0.6, h: 170, c: 0.20, l: 0.62 },  // Assembly
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Product green
            ]
        },

        // === GROUP 4: STORAGE (Solid, grounded - deep blues/purples) ===
        repository: {
            name: 'Repository',
            semantic: 'Deep data vault',
            stops: [
                { value: 0.0, h: 240, c: 0.12, l: 0.30 },  // Database depths
                { value: 0.5, h: 230, c: 0.18, l: 0.45 },  // Data layer
                { value: 1.0, h: 220, c: 0.22, l: 0.60 }   // Accessible
            ]
        },
        cache: {
            name: 'Cache',
            semantic: 'Fast temporary',
            stops: [
                { value: 0.0, h: 300, c: 0.08, l: 0.50 },  // Magenta flash
                { value: 0.5, h: 320, c: 0.16, l: 0.62 },  // Pink speed
                { value: 1.0, h: 340, c: 0.22, l: 0.75 }   // Hot pink hit
            ]
        },

        // === GROUP 5: ORCHESTRATION (Purple/magenta - control flow) ===
        service: {
            name: 'Service',
            semantic: 'Coordinate operations',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Purple quiet
                { value: 0.5, h: 280, c: 0.16, l: 0.55 },  // Active violet
                { value: 1.0, h: 290, c: 0.22, l: 0.68 }   // Bright orchid
            ]
        },
        orchestrator: {
            name: 'Orchestrator',
            semantic: 'See all, conduct all',
            stops: [
                { value: 0.0, h: 200, c: 0.12, l: 0.40 },  // Start blue
                { value: 0.25, h: 270, c: 0.18, l: 0.50 }, // Through purple
                { value: 0.5, h: 330, c: 0.22, l: 0.58 },  // To pink
                { value: 0.75, h: 30, c: 0.24, l: 0.62 },  // Through orange
                { value: 1.0, h: 60, c: 0.26, l: 0.70 }    // End gold (full spectrum)
            ]
        },

        // === GROUP 6: VALIDATION (Yellow/green - pass/fail semantics) ===
        validator: {
            name: 'Validator',
            semantic: 'Check and verify',
            stops: [
                { value: 0.0, h: 0, c: 0.20, l: 0.50 },    // Red fail
                { value: 0.4, h: 45, c: 0.22, l: 0.65 },   // Yellow warning
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Green pass
            ]
        },
        guard: {
            name: 'Guard',
            semantic: 'Protect and defend',
            stops: [
                { value: 0.0, h: 350, c: 0.18, l: 0.40 },  // Dark red blocked
                { value: 0.5, h: 30, c: 0.20, l: 0.55 },   // Orange caution
                { value: 1.0, h: 120, c: 0.22, l: 0.65 }   // Green allowed
            ]
        },

        // === GROUP 7: TRANSFORMATION (Rainbow arc - any to any) ===
        transformer: {
            name: 'Transformer',
            semantic: 'Complete metamorphosis',
            stops: [
                { value: 0.0, h: 220, c: 0.14, l: 0.45 },  // Blue input
                { value: 0.3, h: 280, c: 0.18, l: 0.52 },  // Purple process
                { value: 0.6, h: 340, c: 0.22, l: 0.58 },  // Pink transition
                { value: 1.0, h: 30, c: 0.26, l: 0.65 }    // Orange output
            ]
        },
        parser: {
            name: 'Parser',
            semantic: 'Decode from wire',
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.85 },    // White wire
                { value: 0.5, h: 180, c: 0.10, l: 0.70 },  // Decoding
                { value: 1.0, h: 160, c: 0.20, l: 0.55 }   // Data teal
            ]
        },

        // === GROUP 8: EVENTS (Signals - purple/yellow pulses) ===
        handler: {
            name: 'Handler',
            semantic: 'React to event',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Waiting purple
                { value: 0.5, h: 290, c: 0.18, l: 0.55 },  // Triggered
                { value: 1.0, h: 310, c: 0.26, l: 0.68 }   // Handling pink
            ]
        },
        emitter: {
            name: 'Emitter',
            semantic: 'Broadcast signal',
            stops: [
                { value: 0.0, h: 50, c: 0.18, l: 0.55 },   // Yellow charge
                { value: 0.5, h: 45, c: 0.24, l: 0.68 },   // Bright emit
                { value: 1.0, h: 40, c: 0.30, l: 0.78 }    // Golden broadcast
            ]
        },

        // === GROUP 9: UTILITIES (Neutral supporting - grays/pastels) ===
        utility: {
            name: 'Utility',
            semantic: 'General tool',
            stops: [
                { value: 0.0, h: 220, c: 0.04, l: 0.45 },  // Gray-blue tool
                { value: 0.5, h: 200, c: 0.08, l: 0.58 },  // Soft cyan
                { value: 1.0, h: 180, c: 0.12, l: 0.72 }   // Light teal
            ]
        },
        lifecycle: {
            name: 'Lifecycle',
            semantic: 'Birth to death cycle',
            stops: [
                { value: 0.0, h: 120, c: 0.20, l: 0.65 },  // Birth green
                { value: 0.25, h: 60, c: 0.22, l: 0.70 },  // Youth yellow
                { value: 0.5, h: 30, c: 0.24, l: 0.60 },   // Maturity orange
                { value: 0.75, h: 0, c: 0.20, l: 0.50 },   // Aging red
                { value: 1.0, h: 280, c: 0.10, l: 0.35 }   // Death purple
            ]
        },

        // =====================================================================
        // PART C: OKLCH GEOMETRY GENERATORS (Function-based paths)
        // These use mathematical functions instead of discrete stops.
        // Each has a `generator` function: (t) => { h, c, l }
        // =====================================================================

        // === LOOPS (Full 360° hue cycles) ===
        'rainbow-loop': {
            name: 'Rainbow Loop',
            semantic: 'Full hue circle at constant L/C',
            generator: (t) => ({
                h: t * 360,           // Full hue rotation
                c: 0.20,              // Constant chroma
                l: 0.65               // Constant lightness
            })
        },
        'rainbow-bright': {
            name: 'Rainbow Bright',
            semantic: 'Vivid rainbow with high chroma',
            generator: (t) => ({
                h: t * 360,
                c: 0.28,              // High chroma for vivid colors
                l: 0.70
            })
        },
        'rainbow-dark': {
            name: 'Rainbow Dark',
            semantic: 'Subdued rainbow for dark themes',
            generator: (t) => ({
                h: t * 360,
                c: 0.18,
                l: 0.45               // Lower lightness
            })
        },

        // === ARCS (Partial hue sweeps) ===
        'arc-warm': {
            name: 'Warm Arc',
            semantic: 'Red→Yellow→Orange (warm sector)',
            generator: (t) => ({
                h: 0 + t * 60,        // 0° to 60° (red to yellow)
                c: 0.24,
                l: 0.55 + t * 0.15    // Slight lightness increase
            })
        },
        'arc-cool': {
            name: 'Cool Arc',
            semantic: 'Cyan→Blue→Purple (cool sector)',
            generator: (t) => ({
                h: 180 + t * 100,     // 180° to 280° (cyan to purple)
                c: 0.22,
                l: 0.50 + t * 0.15
            })
        },
        'arc-nature': {
            name: 'Nature Arc',
            semantic: 'Green→Teal→Cyan (nature)',
            generator: (t) => ({
                h: 120 + t * 60,      // 120° to 180° (green to cyan)
                c: 0.20,
                l: 0.60 + t * 0.10
            })
        },

        // === SPIRALS (Hue + varying L or C) ===
        'spiral-up': {
            name: 'Spiral Up',
            semantic: 'Hue rotates as lightness increases',
            generator: (t) => ({
                h: t * 270,           // 3/4 hue rotation
                c: 0.18,
                l: 0.30 + t * 0.55    // Dark to light
            })
        },
        'spiral-down': {
            name: 'Spiral Down',
            semantic: 'Hue rotates as lightness decreases',
            generator: (t) => ({
                h: t * 270,
                c: 0.20,
                l: 0.85 - t * 0.55    // Light to dark
            })
        },
        'spiral-chroma': {
            name: 'Spiral Chroma',
            semantic: 'Hue rotates as saturation increases',
            generator: (t) => ({
                h: t * 360,
                c: 0.06 + t * 0.22,   // Gray to vivid
                l: 0.60
            })
        },

        // === SINUSOIDAL (Wave patterns) ===
        'wave-lightness': {
            name: 'Wave Lightness',
            semantic: 'Sinusoidal lightness oscillation',
            generator: (t) => ({
                h: t * 180,           // Half hue rotation
                c: 0.20,
                l: 0.50 + Math.sin(t * Math.PI * 2) * 0.20  // Wave between 0.30 and 0.70
            })
        },
        'wave-chroma': {
            name: 'Wave Chroma',
            semantic: 'Sinusoidal saturation oscillation',
            generator: (t) => ({
                h: t * 180,
                c: 0.15 + Math.sin(t * Math.PI * 2) * 0.12, // Wave between 0.03 and 0.27
                l: 0.60
            })
        },
        'pulse': {
            name: 'Pulse',
            semantic: 'Both L and C oscillate together',
            generator: (t) => {
                const wave = Math.sin(t * Math.PI * 3); // 1.5 full waves
                return {
                    h: t * 120,       // Partial hue sweep
                    c: 0.15 + wave * 0.10,
                    l: 0.55 + wave * 0.15
                };
            }
        },

        // === LINEAR RAMPS (Simple mathematical paths) ===
        'ramp-hue': {
            name: 'Hue Ramp',
            semantic: 'Pure hue change, constant L/C',
            generator: (t) => ({
                h: 220 + t * 140,     // Blue to pink (220° to 360°)
                c: 0.22,
                l: 0.60
            })
        },
        'ramp-lightness': {
            name: 'Lightness Ramp',
            semantic: 'Dark to light, constant H/C',
            generator: (t) => ({
                h: 220,               // Fixed blue
                c: 0.18,
                l: 0.25 + t * 0.60    // 0.25 to 0.85
            })
        },
        'ramp-chroma': {
            name: 'Chroma Ramp',
            semantic: 'Gray to vivid, constant H/L',
            generator: (t) => ({
                h: 280,               // Fixed purple
                c: 0.02 + t * 0.26,   // 0.02 to 0.28
                l: 0.60
            })
        },

        // === SPECIAL GEOMETRIC PATHS ===
        'helix': {
            name: 'Helix',
            semantic: 'Full 3D path through OKLCH cylinder',
            generator: (t) => ({
                h: t * 540,           // 1.5 hue rotations
                c: 0.10 + t * 0.15,   // Increasing chroma
                l: 0.30 + t * 0.50    // Rising lightness
            })
        },
        'convergent': {
            name: 'Convergent',
            semantic: 'Colors converge toward gray',
            generator: (t) => ({
                h: t * 180,           // Half rotation
                c: 0.26 * (1 - t),    // Chroma decreases to 0
                l: 0.55
            })
        },
        'divergent': {
            name: 'Divergent',
            semantic: 'Colors diverge from gray',
            generator: (t) => ({
                h: 180 + t * 180,     // Second half of hue wheel
                c: 0.26 * t,          // Chroma increases from 0
                l: 0.55
            })
        },
        'bicone': {
            name: 'Bicone',
            semantic: 'Center peak, edges dark (HSL-like)',
            generator: (t) => {
                // Lightness peaks at center, dark at edges
                const l = t < 0.5 ? 0.30 + t * 0.70 : 0.65 - (t - 0.5) * 0.70;
                return {
                    h: t * 360,
                    c: 0.20,
                    l: Math.max(0.30, l)
                };
            }
        }
    };

    // Current active scheme
    let _activeScheme = null;

// =========================================================================
// SUBSCRIBERS: Reactive notifications
// =========================================================================

let _subscribers = [];

function subscribe(callback) {
    _subscribers.push(callback);
    return () => {
        _subscribers = _subscribers.filter(cb => cb !== callback);
    };
}

function _notifySubscribers(event, data) {
    _subscribers.forEach(cb => cb(event, data));
}

// =========================================================================
// OKLCH -> HEX CONVERSION
// =========================================================================

function _toHex(oklch) {
    const { h, c, l } = oklch;

    // Convert OKLCH to approximate RGB
    const hRad = h * Math.PI / 180;
    const a = c * Math.cos(hRad);
    const b = c * Math.sin(hRad);

    // Simplified OKLab to linear RGB (approximate)
    const L = l;
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    const l3 = l_ * l_ * l_;
    const m3 = m_ * m_ * m_;
    const s3 = s_ * s_ * s_;

    let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
    let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
    let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

    // Clamp and convert to sRGB
    const toSRGB = (x) => {
        x = Math.max(0, Math.min(1, x));
        return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
    };

    r = Math.round(toSRGB(r) * 255);
    g = Math.round(toSRGB(g) * 255);
    bl = Math.round(toSRGB(bl) * 255);

    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    bl = Math.max(0, Math.min(255, bl));

    return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
}

/**
 * Convert HEX color to OKLCH
 * @param {string} hex - Hex color string (#RGB, #RRGGBB, or #RRGGBBAA)
 * @returns {object} {h, c, l} OKLCH values
 */
function hexToOklch(hex) {
    // Parse hex to RGB
    let r = 0, g = 0, b = 0;

    if (!hex || typeof hex !== 'string') {
        return { h: 0, c: 0, l: 0.5 }; // Gray fallback
    }

    // Remove # if present
    hex = hex.replace(/^#/, '');

    // Handle different hex formats
    if (hex.length === 3) {
        // #RGB -> #RRGGBB
        r = parseInt(hex[0] + hex[0], 16);
        g = parseInt(hex[1] + hex[1], 16);
        b = parseInt(hex[2] + hex[2], 16);
    } else if (hex.length >= 6) {
        r = parseInt(hex.slice(0, 2), 16);
        g = parseInt(hex.slice(2, 4), 16);
        b = parseInt(hex.slice(4, 6), 16);
    } else {
        return { h: 0, c: 0, l: 0.5 }; // Invalid hex, gray fallback
    }

    // Normalize to 0-1
    r /= 255;
    g /= 255;
    b /= 255;

    // Convert sRGB to linear RGB
    const toLinear = (x) => x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    r = toLinear(r);
    g = toLinear(g);
    b = toLinear(b);

    // Linear RGB to OKLab (via LMS)
    const l_ = Math.cbrt(0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b);
    const m_ = Math.cbrt(0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b);
    const s_ = Math.cbrt(0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b);

    const L = 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_;
    const a = 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_;
    const bLab = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_;

    // OKLab to OKLCH
    const C = Math.sqrt(a * a + bLab * bLab);
    let H = Math.atan2(bLab, a) * 180 / Math.PI;
    if (H < 0) H += 360;

    return {
        h: H,
        c: C,
        l: L
    };
}

function _applyTransform(oklch) {
    const t = transform;

    // Apply transforms
    let h = (oklch.h + t.hueShift + 360) % 360;
    let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
    let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

    // Apply amplifier to chroma for contrast
    if (t.amplifier !== 1) {
        c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
    }

    return _toHex({ h, c, l });
}

// =========================================================================
// CORE API
// =========================================================================

/**
 * Get color with transforms applied
 * @param {string} dimension - Palette dimension (tier, family, ring, layer, edgeType)
 * @param {string} category - Category within dimension
 * @returns {string} Hex color string
 */
function get(dimension, category) {
    const base = palette[dimension]?.[category];
    if (!base) return _toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray
    return _applyTransform(base);
}

/**
 * Get color for a numeric value using interval mapping
 * @param {string} intervalName - Interval name (markov, weight, confidence)
 * @param {number} value - Value (0-1)
 * @returns {string} Hex color string
 */
function getInterval(intervalName, value) {
    const v = Math.max(0, Math.min(1, value));

    // =========================================================================
    // SCHEME OVERRIDE: If an active scheme is selected, use it for ALL intervals
    // This makes the 33 named schemes (viridis, plasma, thermal, etc.) work
    // =========================================================================
    if (_activeScheme && schemePaths[_activeScheme]) {
        return getSchemeColor(_activeScheme, v);
    }

    // Fall back to hardcoded interval if no scheme active
    const interval = intervals[intervalName];
    if (!interval) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const stops = interval.stops;

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const t = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * t,
        c: lower.c + (upper.c - lower.c) * t,
        l: lower.l + (upper.l - lower.l) * t
    };

    return _applyTransform(interpolated);
}

/**
 * Interpolate between two hex colors in OKLCH space
 * @param {string} color1 - Hex color 1
 * @param {string} color2 - Hex color 2
 * @param {number} t - Interpolation factor (0-1)
 * @returns {string} Hex result
 */
function interpolate(color1, color2, t) {
    // We assume input hexes can be approximated back to OKLCH or treated as sRGB->OKLCH
    // For simplicity in this engine which mostly generates from OKLCH, we'll assume
    // specific OKLCH-derived palettes unless provided raw hex.
    // If we really need robust hex->oklch, we need a converter.
    // BUT, for edge gradients in app.js, we often have raw HSL or OKLCH objects.
    // Let's support passing Objects {h,c,l} or hex strings (naive interpolation for hex if needed).
    // Best approach: app.js should use COLOR.get() to get objects if possible, or we expose a helper
    // that takes our internal palette objects.

    // Actually, let's keep it simple: assume app.js will partial refactoring.
    // We will accept object {h,c,l} inputs for maximum precision.
    const c1 = (typeof color1 === 'string') ? parseOklchString(color1) || { h: 0, c: 0, l: 0.5 } : color1;
    const c2 = (typeof color2 === 'string') ? parseOklchString(color2) || { h: 0, c: 0, l: 0.5 } : color2;

    t = Math.max(0, Math.min(1, t));

    // Shortest path hue interpolation
    let h1 = c1.h || c1.H || 0;
    let h2 = c2.h || c2.H || 0;
    let dh = h2 - h1;
    if (Math.abs(dh) > 180) {
        if (dh > 0) h1 += 360;
        else h2 += 360;
    }

    const h = (h1 + (h2 - h1) * t) % 360;
    const c = (c1.c !== undefined ? c1.c : c1.C) + ((c2.c !== undefined ? c2.c : c2.C) - (c1.c !== undefined ? c1.c : c1.C)) * t;
    const l = (c1.l !== undefined ? c1.l : c1.L) + ((c2.l !== undefined ? c2.l : c2.L) - (c1.l !== undefined ? c1.l : c1.L)) * t;

    return _applyTransform({ h, c, l });
}

/**
 * Get raw OKLCH values (for advanced use)
 */
function getRaw(dimension, category) {
    return palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
}

/**
 * Get all categories for a dimension
 */
function getCategories(dimension) {
    return Object.keys(palette[dimension] || {});
}

/**
 * Get label for a category
 */
function getLabel(dimension, category) {
    return palette[dimension]?.[category]?.label || category;
}

// =========================================================================
// TRANSFORM CONTROLS
// =========================================================================

function setTransform(key, value) {
    if (key in transform) {
        transform[key] = value;
        _notifySubscribers('transform-change', { key, value });
    }
}

function setAllTransforms(transforms) {
    Object.assign(transform, transforms);
    _notifySubscribers('transform-change', transforms);
}

function resetTransforms() {
    transform.hueShift = 0;
    transform.chromaScale = 1.0;
    transform.lightnessShift = 0;
    transform.amplifier = 1.0;
    _notifySubscribers('transform-change', transform);
}

function getTransform() {
    return { ...transform };
}

// =========================================================================
// SCHEME API: Named Color Gradients
// =========================================================================

/**
 * List all available scheme names
 * @returns {string[]} Array of scheme names
 */
function listSchemes() {
    return Object.keys(schemePaths);
}

/**
 * Get scheme definition
 * @param {string} schemeName - Name of the scheme
 * @returns {object|null} Scheme definition with name, semantic, and stops
 */
function getScheme(schemeName) {
    return schemePaths[schemeName] || null;
}

/**
 * Get color at position t (0-1) along a scheme path
 * Supports both:
 *   - stops: Array of discrete points (interpolated)
 *   - generator: Function (t) => { h, c, l } (direct mathematical path)
 *
 * @param {string} schemeName - Name of the scheme
 * @param {number} t - Position along path (0-1)
 * @returns {string} Hex color string
 */
function getSchemeColor(schemeName, t) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const v = Math.max(0, Math.min(1, t));

    // GENERATOR MODE: Mathematical function (OKLCH geometry)
    if (scheme.generator && typeof scheme.generator === 'function') {
        const oklch = scheme.generator(v);
        return _applyTransform(oklch);
    }

    // STOPS MODE: Discrete points with interpolation
    const stops = scheme.stops;
    if (!stops || stops.length === 0) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const interp = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * interp,
        c: lower.c + (upper.c - lower.c) * interp,
        l: lower.l + (upper.l - lower.l) * interp
    };

    return _applyTransform(interpolated);
}

/**
 * Apply a scheme as the active color scheme
 * This sets transforms and notifies subscribers
 * @param {string} schemeName - Name of the scheme
 */
function applyScheme(schemeName) {
    // Allow null/undefined to clear the active scheme
    if (!schemeName) {
        _activeScheme = null;
        _notifySubscribers('scheme-change', { scheme: null, definition: null });
        console.log('[COLOR] Cleared active scheme, using default intervals');
        return;
    }

    const scheme = schemePaths[schemeName];
    if (!scheme) {
        console.warn('[COLOR] Unknown scheme:', schemeName);
        return;
    }

    _activeScheme = schemeName;
    _notifySubscribers('scheme-change', { scheme: schemeName, definition: scheme });
    console.log('[COLOR] Applied scheme:', schemeName, '-', scheme.semantic);
}

/**
 * Get the currently active scheme name
 * @returns {string|null} Active scheme name or null
 */
function getActiveScheme() {
    return _activeScheme;
}

/**
 * Generate a CSS gradient string for a scheme (for UI previews)
 * @param {string} schemeName - Name of the scheme
 * @param {string} direction - CSS gradient direction (default: 'to right')
 * @returns {string} CSS linear-gradient string
 */
function getSchemeGradientCSS(schemeName, direction = 'to right') {
    const scheme = schemePaths[schemeName];
    if (!scheme) return 'linear-gradient(to right, #333, #666)';

    const colorStops = scheme.stops.map(stop => {
        const color = _applyTransform(stop);
        const percent = Math.round(stop.value * 100);
        return `${color} ${percent}%`;
    });

    return `linear-gradient(${direction}, ${colorStops.join(', ')})`;
}

/**
 * Get scheme metadata (name, semantic description)
 * @param {string} schemeName - Name of the scheme
 * @returns {object} {name, semantic}
 */
function getSchemeInfo(schemeName) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return { name: schemeName, semantic: 'Unknown' };
    return { name: scheme.name, semantic: scheme.semantic };
}

// =========================================================================
// DEBUG
// =========================================================================

function debug() {
    console.log('[COLOR] Transform state:', transform);
    console.log('[COLOR] Palette dimensions:', Object.keys(palette));
    console.log('[COLOR] Interval mappings:', Object.keys(intervals));
    console.log('[COLOR] Schemes:', Object.keys(schemePaths).length, 'available');
    console.log('[COLOR] Active scheme:', _activeScheme);
}

// =========================================================================
// PUBLIC API
// =========================================================================

return {
    // Core API
    get,
    getInterval,
    getRaw,
    getCategories,
    getLabel,
    interpolate,

    // OKLCH Conversion (for UPB integration)
    toHex: _toHex,
    hexToOklch,

    // Transform controls
    setTransform,
    setAllTransforms,
    resetTransforms,
    getTransform,

    // Scheme API (33 named color gradients)
    listSchemes,
    getScheme,
    getSchemeColor,
    applyScheme,
    getActiveScheme,
    getSchemeGradientCSS,
    getSchemeInfo,

    // Subscriptions
    subscribe,

    // Internal access (for migration)
    palette,
    intervals,
    transform,
    schemePaths,

    // Debug
    debug
};
}) ();

// Export to window for global access
window.COLOR = COLOR;

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'ColorOrchestrator', { get: () => COLOR, configurable: true });
Object.defineProperty(window, 'Color', { get: () => COLOR, configurable: true });

console.log('[Module] COLOR loaded - OKLCH color engine with', Object.keys(COLOR.schemePaths || {}).length, 'schemes');


// ═══ MODULE: modules/refresh-throttle.js ═══
/**
 * REFRESH THROTTLE MODULE
 *
 * Prevents excessive Graph.refresh() calls that can cause performance issues.
 * Implements frame-budget-aware throttling at 60fps max.
 *
 * Fixes ARCH-003: Unthrottled Graph.refresh() calls
 *
 * Usage:
 *   REFRESH.throttled()     // Request a throttled refresh
 *   REFRESH.force()         // Force immediate refresh (use sparingly)
 *   REFRESH.stats           // Get refresh statistics
 */

const REFRESH = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        minInterval: 16,      // 60fps max (1000ms / 60 = 16.67ms)
        maxPending: 3,        // Max queued refresh requests before forcing
        logThreshold: 100     // Log warning if more than N refreshes/second
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _pending = false;
    let _lastRefresh = 0;
    let _rafId = null;
    let _pendingCount = 0;

    // Statistics
    let _stats = {
        totalCalls: 0,
        throttledCalls: 0,
        actualRefreshes: 0,
        lastSecondRefreshes: 0,
        currentSecondRefreshes: 0,
        lastSecond: 0
    };

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Request a throttled graph refresh.
     * Multiple calls within the same frame are coalesced into one refresh.
     */
    function throttled() {
        _stats.totalCalls++;
        _pendingCount++;

        // Track calls per second for diagnostics
        const now = performance.now();
        const currentSecond = Math.floor(now / 1000);
        if (currentSecond !== _stats.lastSecond) {
            _stats.lastSecondRefreshes = _stats.currentSecondRefreshes;
            _stats.currentSecondRefreshes = 0;
            _stats.lastSecond = currentSecond;

            // Warn if too many refreshes
            if (_stats.lastSecondRefreshes > CONFIG.logThreshold) {
                console.warn(`[REFRESH] High refresh rate: ${_stats.lastSecondRefreshes}/s`);
            }
        }

        // If already pending, don't queue another
        if (_pending) {
            _stats.throttledCalls++;

            // Force refresh if too many pending
            if (_pendingCount >= CONFIG.maxPending) {
                _doRefresh();
            }
            return;
        }

        // Check if enough time has passed since last refresh
        const elapsed = now - _lastRefresh;
        if (elapsed >= CONFIG.minInterval) {
            // Enough time passed, refresh immediately
            _doRefresh();
        } else {
            // Schedule refresh for next frame
            _pending = true;
            _rafId = requestAnimationFrame(() => {
                _pending = false;
                _doRefresh();
            });
        }
    }

    /**
     * Force an immediate refresh, bypassing throttle.
     * Use sparingly - for critical updates only.
     */
    function force() {
        // Cancel any pending throttled refresh
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _doRefresh();
    }

    /**
     * Internal: Perform the actual refresh
     */
    function _doRefresh() {
        _lastRefresh = performance.now();
        _pendingCount = 0;
        _stats.actualRefreshes++;
        _stats.currentSecondRefreshes++;

        // Call the global Graph.refresh() if available
        if (typeof Graph !== 'undefined' && Graph && Graph.refresh) {
            Graph.refresh();
        }
    }

    /**
     * Cancel any pending refresh
     */
    function cancel() {
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _pendingCount = 0;
    }

    /**
     * Reset statistics
     */
    function resetStats() {
        _stats = {
            totalCalls: 0,
            throttledCalls: 0,
            actualRefreshes: 0,
            lastSecondRefreshes: 0,
            currentSecondRefreshes: 0,
            lastSecond: 0
        };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        throttled,
        force,
        cancel,
        resetStats,

        // Config (read-only access, can be modified via setConfig)
        get config() { return { ...CONFIG }; },
        setConfig(key, value) {
            if (key in CONFIG) {
                CONFIG[key] = value;
            }
        },

        // Statistics
        get stats() {
            return {
                ..._stats,
                throttleRatio: _stats.totalCalls > 0
                    ? (_stats.throttledCalls / _stats.totalCalls * 100).toFixed(1) + '%'
                    : '0%',
                pending: _pending,
                pendingCount: _pendingCount
            };
        },

        // Debug
        debug() {
            console.log('[REFRESH] Stats:', this.stats);
            console.log('[REFRESH] Config:', CONFIG);
        }
    };
})();


// ═══ MODULE: modules/legend-manager.js ═══
/**
 * LEGEND MANAGER MODULE
 *
 * Manages legend data, counts, and visibility for all visualization dimensions.
 * Delegates all color operations to the COLOR module.
 *
 * Depends on: COLOR, NODE
 *
 * Usage:
 *   LEGEND.init(nodes, links)           // Initialize with graph data
 *   LEGEND.getLegendData('tier')        // Get legend items for a dimension
 *   LEGEND.getColor('tier', 'T0')       // Get color (delegates to COLOR)
 *   LEGEND.subscribe(callback)          // React to legend changes
 */

const LEGEND = (function() {
    'use strict';

    // =========================================================================
    // DIMENSION METADATA
    // =========================================================================

    const dimensions = {
        tier: {
            name: 'TIERS',
            icon: '◐',
            extract: (node) => NODE.getTier(node)
        },
        family: {
            name: 'FAMILIES',
            icon: '⬡',
            extract: (node) => NODE.getFamily(node)
        },
        ring: {
            name: 'RINGS',
            icon: '◎',
            extract: (node) => NODE.getRing(node)
        },
        layer: {
            name: 'LAYERS',
            icon: '☰',
            extract: (node) => NODE.getLayer(node).toUpperCase()
        },
        effect: {
            name: 'EFFECTS',
            icon: '⚡',
            extract: (node) => NODE.getEffect(node)
        },
        edgeType: {
            name: 'EDGE TYPES',
            icon: '→',
            extract: (link) => (link.edge_type || link.type || 'unknown').toLowerCase()
        },
        edgeFamily: {
            name: 'EDGE FAMILIES',
            icon: '⇢',
            extract: (link) => (link.family || 'Dependency')
        }
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _counts = {};
    let _subscribers = [];

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Initialize legend with nodes and links data
     */
    function init(nodes, links) {
        _computeCounts(nodes, links);
        return LEGEND;
    }

    /**
     * Compute counts for all dimensions
     */
    function _computeCounts(nodes, links) {
        _counts = {};

        // Node dimensions
        ['tier', 'family', 'ring', 'layer', 'effect'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (nodes || []).forEach(node => {
                const cat = extract(node);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        // Edge dimensions
        ['edgeType', 'edgeFamily'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (links || []).forEach(link => {
                const cat = extract(link);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        console.log('[LEGEND] Counts computed:', Object.keys(_counts));
        _notifySubscribers('counts-updated', _counts);
    }

    /**
     * Get legend data for a dimension
     * Returns array of { id, label, color, count, dimension }
     */
    function getLegendData(dimension) {
        const counts = _counts[dimension] || {};

        return Object.keys(counts)
            .filter(cat => counts[cat] > 0)
            .sort((a, b) => (counts[b] || 0) - (counts[a] || 0))
            .map(cat => ({
                id: cat,
                label: COLOR.getLabel(dimension, cat),
                color: COLOR.get(dimension, cat),
                count: counts[cat] || 0,
                dimension: dimension
            }));
    }

    /**
     * Get color for a dimension/category (delegates to COLOR)
     */
    function getColor(dimension, category) {
        return COLOR.get(dimension, category);
    }

    /**
     * Get counts for a dimension
     */
    function getCounts(dimension) {
        return _counts[dimension] || {};
    }

    /**
     * Get all available dimensions
     */
    function getDimensions() {
        return Object.keys(dimensions);
    }

    /**
     * Get dimension metadata
     */
    function getDimensionMeta(dimension) {
        return dimensions[dimension] || null;
    }

    // =========================================================================
    // SUBSCRIPTIONS
    // =========================================================================

    function subscribe(callback) {
        _subscribers.push(callback);
        return () => {
            _subscribers = _subscribers.filter(cb => cb !== callback);
        };
    }

    function _notifySubscribers(event, data) {
        _subscribers.forEach(cb => cb(event, data));
    }

    // =========================================================================
    // DOM RENDERING
    // =========================================================================

    /**
     * Render a legend section to the DOM
     * @param {string} containerId - DOM container ID
     * @param {string} dimension - Dimension to render (tier, family, etc.)
     * @param {Set} stateSet - Filter state set (items to show)
     * @param {Function} onUpdate - Callback when filter changes
     */
    function renderSection(containerId, dimension, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        const legendData = getLegendData(dimension);
        if (!legendData || legendData.length === 0) return;

        // Build legend items
        legendData.forEach(item => {
            const el = document.createElement('div');
            el.className = 'topo-legend-item' + (stateSet && !stateSet.has(item.id) ? ' filtered' : '');
            el.dataset.category = item.id;
            el.dataset.dimension = dimension;

            // Color swatch
            const swatch = document.createElement('span');
            swatch.className = 'topo-legend-swatch';
            swatch.style.backgroundColor = item.color;

            // Label with count
            const label = document.createElement('span');
            label.className = 'topo-legend-label';
            label.textContent = item.id;

            const count = document.createElement('span');
            count.className = 'topo-legend-count';
            count.textContent = `(${item.count})`;

            el.appendChild(swatch);
            el.appendChild(label);
            el.appendChild(count);

            // Click to toggle filter
            if (stateSet) {
                el.addEventListener('click', () => {
                    if (stateSet.has(item.id)) {
                        stateSet.delete(item.id);
                        el.classList.add('filtered');
                    } else {
                        stateSet.add(item.id);
                        el.classList.remove('filtered');
                    }
                    if (onUpdate) onUpdate();
                });
            }

            container.appendChild(el);
        });

        console.log(`[Legend] Rendered ${dimension}: ${legendData.length} items`);
    }

    /**
     * Render all legend sections
     * @param {Object} filters - VIS_FILTERS object with filter Sets
     * @param {Function} onUpdate - Callback when any filter changes (typically refreshGraph)
     */
    function renderAll(filters, onUpdate) {
        // Render node legends
        renderSection('topo-tiers', 'tier', filters?.tiers, onUpdate);
        renderSection('topo-families', 'family', filters?.families, onUpdate);
        renderSection('topo-rings', 'ring', filters?.rings, onUpdate);
        renderSection('topo-layers', 'layer', filters?.layers, onUpdate);
        renderSection('topo-effects', 'effect', filters?.effects, onUpdate);

        // Render edge legends
        renderSection('topo-edges', 'edgeType', filters?.edges, onUpdate);
        renderSection('topo-edge-families', 'edgeFamily', filters?.edgeFamilies, onUpdate);

        console.log('[Legend] All sections rendered');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        getLegendData,
        getColor,
        getCounts,
        getDimensions,
        getDimensionMeta,
        subscribe,
        renderSection,
        renderAll,

        // Direct access to dimensions (for migration)
        dimensions,

        // Computed counts
        get counts() { return _counts; }
    };
})();

// Backward compatibility - LegendManager class wrapper
class LegendManager {
    constructor() {
        this.dimensions = LEGEND.dimensions;
        this.counts = {};
        this._subscribers = [];
    }

    init(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
        return this;
    }

    _computeCounts(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
    }

    getLegendData(dimension) {
        return LEGEND.getLegendData(dimension);
    }

    getColor(dimension, category) {
        return LEGEND.getColor(dimension, category);
    }

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    }

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    }
}

// Global Legend instance - defined by app.js (not duplicated here to avoid redeclaration)
// Legend is accessed as a global variable provided by app.js

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

// renderLegendSection calls LEGEND.renderSection with Legend (global) as source
window.renderLegendSection = function(containerId, dimension, stateSet, onUpdate) {
    LEGEND.renderSection(containerId, dimension, stateSet, onUpdate);
};

// renderAllLegends uses VIS_FILTERS and refreshGraph from app.js globals
// Includes 100ms debounce to prevent DOM thrashing during rapid updates
let _legendDebounceTimer = null;
window.renderAllLegends = function() {
    if (_legendDebounceTimer) clearTimeout(_legendDebounceTimer);
    _legendDebounceTimer = setTimeout(() => {
        _legendDebounceTimer = null;
        const VIS_FILTERS = window.VIS_FILTERS;
        const refreshGraph = window.refreshGraph;
        if (VIS_FILTERS && refreshGraph) {
            LEGEND.renderAll(VIS_FILTERS, refreshGraph);
        } else {
            console.warn('[Legend] VIS_FILTERS or refreshGraph not available');
        }
    }, 100);
};

console.log('[Module] LEGEND loaded - 10 functions');


// ═══ MODULE: modules/data-manager.js ═══
/**
 * DATA MANAGER MODULE
 *
 * Single gate for ALL data access in the visualization.
 * Replaces direct access to FULL_GRAPH and Graph.graphData().
 * Provides O(1) indexed lookups and cached aggregations.
 *
 * Depends on: NODE, COLOR, LEGEND
 *
 * Usage:
 *   DATA.init(graphData)                // Initialize with payload data
 *   DATA.getNodes()                     // Get all raw nodes
 *   DATA.getNode(id)                    // O(1) node lookup
 *   DATA.getNodesByTier('T0')           // O(1) tier lookup
 *   DATA.getEdgesFrom(nodeId)           // O(1) edge lookup
 *   DATA.getTierCounts()                // Cached aggregation
 */

const DATA = (function() {
    'use strict';

    // =========================================================================
    // RAW DATA (immutable after init)
    // =========================================================================

    const raw = {
        nodes: [],
        links: [],
        fileBoundaries: [],
        markov: {},
        kpis: {},
        meta: {},
        physics: {},
        config: {},
        codome_boundaries: null
    };

    // =========================================================================
    // ANALYTICS DATA (all Collider sections)
    // =========================================================================

    const analytics = {
        counts: {},
        stats: {},
        coverage: {},
        performance: {},
        classification: {},
        auto_discovery: {},
        ecosystem_discovery: {},
        dependencies: {},
        architecture: {},
        topology: {},
        execution_flow: {},
        data_flow: {},
        knots: {},
        warnings: [],
        recommendations: [],
        theory_completeness: {},
        distributions: {},
        edge_types: {},
        rpbl_profile: {},
        purpose_field: {},
        top_hubs: [],
        orphans_list: [],
        files: [],
        semantics: {},
        llm_enrichment: {},
        brain_download: {},
        ai_insights: null
    };

    // =========================================================================
    // INDEXES (O(1) lookups - built once)
    // =========================================================================

    const index = {
        nodeById: new Map(),           // id -> node
        nodesByTier: new Map(),        // tier -> [nodes]
        nodesByFamily: new Map(),      // family -> [nodes]
        nodesByRing: new Map(),        // ring -> [nodes]
        nodesByLayer: new Map(),       // layer -> [nodes]
        nodesByEffect: new Map(),      // effect -> [nodes]
        nodesByFile: new Map(),        // fileIdx -> [nodes]
        edgesBySource: new Map(),      // nodeId -> [edges from]
        edgesByTarget: new Map(),      // nodeId -> [edges to]
        edgeByKey: new Map(),          // "src|tgt" -> edge
        fileByIndex: new Map(),        // idx -> fileBoundary
        markovBySource: new Map()      // nodeId -> sorted edges by weight
    };

    // =========================================================================
    // CACHED AGGREGATIONS (computed once, invalidated on filter)
    // =========================================================================

    const cache = {
        tierCounts: null,
        familyCounts: null,
        ringCounts: null,
        layerCounts: null,
        effectCounts: null,
        edgeTypeCounts: null,
        edgeFamilyCounts: null,
        edgeRanges: null
    };

    // =========================================================================
    // CURRENT STATE (filtered view)
    // =========================================================================

    const filtered = {
        nodes: [],
        links: []
    };

    // Legend manager instance
    let _legend = null;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function init(data) {
        // Store raw data
        raw.nodes = Array.isArray(data?.nodes) ? data.nodes : [];
        raw.links = Array.isArray(data?.links) ? data.links : [];
        raw.fileBoundaries = Array.isArray(data?.file_boundaries) ? data.file_boundaries : [];
        raw.markov = data?.markov || {};
        raw.kpis = data?.kpis || {};
        raw.meta = data?.meta || {};
        raw.physics = data?.physics || {};
        raw.config = data?.config || {};
        raw.codome_boundaries = data?.codome_boundaries || null;

        // Store analytics data
        Object.keys(analytics).forEach(key => {
            if (data?.[key] !== undefined) {
                analytics[key] = data[key];
            }
        });

        // Merge CODOME boundaries into main nodes and edges arrays
        _mergeCodomeBooudaries();

        // Build all indexes
        _buildAllIndexes();

        // Initialize legend
        _legend = new LegendManager();
        _legend.init(raw.nodes, raw.links);

        // Set global Legend reference
        if (typeof Legend !== 'undefined') {
            Legend = _legend;
        }

        console.log('%c[DATA] Initialized', 'color: #4ade80; font-weight: bold',
            `${raw.nodes.length} nodes, ${raw.links.length} edges, ${raw.fileBoundaries.length} files`);

        return DATA;
    }

    // =========================================================================
    // CODOME BOUNDARY MERGING
    // =========================================================================

    function _mergeCodomeBooudaries() {
        if (!raw.codome_boundaries) return;

        const boundaryNodes = raw.codome_boundaries.boundary_nodes || [];
        const inferredEdges = raw.codome_boundaries.inferred_edges || [];

        if (boundaryNodes.length === 0 && inferredEdges.length === 0) {
            return;
        }

        // Mark boundary nodes with _fromCodome flag
        boundaryNodes.forEach(node => {
            if (node && typeof node === 'object') {
                node._fromCodome = true;
            }
        });

        // Mark inferred edges with _fromCodome flag
        inferredEdges.forEach(edge => {
            if (edge && typeof edge === 'object') {
                edge._fromCodome = true;
            }
        });

        // Merge boundary nodes into main nodes array
        raw.nodes = raw.nodes.concat(boundaryNodes);

        // Merge inferred edges into main links array
        raw.links = raw.links.concat(inferredEdges);

        console.log('%c[DATA] CODOME boundaries merged', 'color: #60a5fa; font-weight: bold',
            `+${boundaryNodes.length} boundary nodes, +${inferredEdges.length} inferred edges`);
    }

    // =========================================================================
    // INDEX BUILDING
    // =========================================================================

    function _buildAllIndexes() {
        _buildNodeIndex();
        _buildSemanticIndexes();
        _buildEdgeIndexes();
        _buildFileIndex();
        _buildMarkovIndex();
        _invalidateCache();
    }

    function _buildNodeIndex() {
        index.nodeById.clear();
        for (const node of raw.nodes) {
            if (node?.id) {
                index.nodeById.set(node.id, node);
            }
        }
    }

    function _buildSemanticIndexes() {
        index.nodesByTier.clear();
        index.nodesByFamily.clear();
        index.nodesByRing.clear();
        index.nodesByLayer.clear();
        index.nodesByEffect.clear();
        index.nodesByFile.clear();

        for (const node of raw.nodes) {
            if (!node) continue;

            // Tier index
            const tier = NODE.getTier(node);
            if (!index.nodesByTier.has(tier)) {
                index.nodesByTier.set(tier, []);
            }
            index.nodesByTier.get(tier).push(node);

            // Family index
            const family = NODE.getFamily(node);
            if (!index.nodesByFamily.has(family)) {
                index.nodesByFamily.set(family, []);
            }
            index.nodesByFamily.get(family).push(node);

            // Ring index
            const ring = NODE.getRing(node);
            if (!index.nodesByRing.has(ring)) {
                index.nodesByRing.set(ring, []);
            }
            index.nodesByRing.get(ring).push(node);

            // Layer index
            const layer = NODE.getLayer(node);
            if (!index.nodesByLayer.has(layer)) {
                index.nodesByLayer.set(layer, []);
            }
            index.nodesByLayer.get(layer).push(node);

            // Effect index
            const effect = NODE.getEffect(node);
            if (!index.nodesByEffect.has(effect)) {
                index.nodesByEffect.set(effect, []);
            }
            index.nodesByEffect.get(effect).push(node);

            // File index
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx >= 0) {
                if (!index.nodesByFile.has(fileIdx)) {
                    index.nodesByFile.set(fileIdx, []);
                }
                index.nodesByFile.get(fileIdx).push(node);
            }
        }
    }

    function _buildEdgeIndexes() {
        index.edgesBySource.clear();
        index.edgesByTarget.clear();
        index.edgeByKey.clear();

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');

            if (srcId) {
                if (!index.edgesBySource.has(srcId)) {
                    index.edgesBySource.set(srcId, []);
                }
                index.edgesBySource.get(srcId).push(link);
            }

            if (tgtId) {
                if (!index.edgesByTarget.has(tgtId)) {
                    index.edgesByTarget.set(tgtId, []);
                }
                index.edgesByTarget.get(tgtId).push(link);
            }

            if (srcId && tgtId) {
                index.edgeByKey.set(`${srcId}|${tgtId}`, link);
            }
        }
    }

    function _buildFileIndex() {
        index.fileByIndex.clear();
        for (let i = 0; i < raw.fileBoundaries.length; i++) {
            index.fileByIndex.set(i, raw.fileBoundaries[i]);
        }
    }

    function _buildMarkovIndex() {
        index.markovBySource.clear();
        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const mw = link.markov_weight || 0;
            if (srcId && mw > 0) {
                if (!index.markovBySource.has(srcId)) {
                    index.markovBySource.set(srcId, []);
                }
                index.markovBySource.get(srcId).push(link);
            }
        }
        // Sort each list by markov weight descending
        for (const [, edges] of index.markovBySource) {
            edges.sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0));
        }
    }

    function _invalidateCache() {
        Object.keys(cache).forEach(key => {
            cache[key] = null;
        });
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }

    // =========================================================================
    // RAW DATA ACCESSORS
    // =========================================================================

    function getNodes() { return raw.nodes; }
    function getLinks() { return raw.links; }
    function getFileBoundaries() { return raw.fileBoundaries; }
    function getMarkov() { return raw.markov; }
    function getKpis() { return raw.kpis; }
    function getMeta() { return raw.meta; }
    function getPhysics() { return raw.physics; }
    function getConfig() { return raw.config; }
    function getCodomeBooudaries() { return raw.codome_boundaries; }
    function getAnalytics(key) { return analytics[key]; }

    // =========================================================================
    // INDEXED LOOKUPS (O(1))
    // =========================================================================

    function getNode(id) {
        return index.nodeById.get(id) || null;
    }

    function getNodesByTier(tier) {
        return index.nodesByTier.get(tier) || [];
    }

    function getNodesByFamily(family) {
        return index.nodesByFamily.get(family) || [];
    }

    function getNodesByRing(ring) {
        return index.nodesByRing.get(ring) || [];
    }

    function getNodesByLayer(layer) {
        return index.nodesByLayer.get(layer) || [];
    }

    function getNodesByEffect(effect) {
        return index.nodesByEffect.get(effect) || [];
    }

    function getNodesByFile(fileIdx) {
        return index.nodesByFile.get(fileIdx) || [];
    }

    function getEdgesFrom(nodeId) {
        return index.edgesBySource.get(nodeId) || [];
    }

    function getEdgesTo(nodeId) {
        return index.edgesByTarget.get(nodeId) || [];
    }

    function getEdgeBetween(srcId, tgtId) {
        return index.edgeByKey.get(`${srcId}|${tgtId}`) || null;
    }

    function getFile(idx) {
        return index.fileByIndex.get(idx) || null;
    }

    function getTopMarkovEdges(nodeId, k = 5) {
        const edges = index.markovBySource.get(nodeId) || [];
        return edges.slice(0, k);
    }

    function isHighEntropyNode(nodeId) {
        const highEntropy = raw.markov?.high_entropy_nodes || [];
        return highEntropy.some(h => h.node === nodeId);
    }

    // =========================================================================
    // FILTERED DATA
    // =========================================================================

    function setFiltered(nodes, links) {
        filtered.nodes = nodes || [];
        filtered.links = links || [];
    }

    function getVisibleNodes() {
        if (filtered.nodes.length > 0) {
            return filtered.nodes;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().nodes || [])
            : [];
    }

    function getVisibleLinks() {
        if (filtered.links.length > 0) {
            return filtered.links;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().links || [])
            : [];
    }

    // =========================================================================
    // AGGREGATIONS (cached)
    // =========================================================================

    function getTierCounts() {
        if (!cache.tierCounts) {
            cache.tierCounts = new Map();
            for (const [tier, nodes] of index.nodesByTier) {
                cache.tierCounts.set(tier, nodes.length);
            }
        }
        return cache.tierCounts;
    }

    function getFamilyCounts() {
        if (!cache.familyCounts) {
            cache.familyCounts = new Map();
            for (const [family, nodes] of index.nodesByFamily) {
                cache.familyCounts.set(family, nodes.length);
            }
        }
        return cache.familyCounts;
    }

    function getRingCounts() {
        if (!cache.ringCounts) {
            cache.ringCounts = new Map();
            for (const [ring, nodes] of index.nodesByRing) {
                cache.ringCounts.set(ring, nodes.length);
            }
        }
        return cache.ringCounts;
    }

    function getLayerCounts() {
        if (!cache.layerCounts) {
            cache.layerCounts = new Map();
            for (const [layer, nodes] of index.nodesByLayer) {
                cache.layerCounts.set(layer, nodes.length);
            }
        }
        return cache.layerCounts;
    }

    function getEffectCounts() {
        if (!cache.effectCounts) {
            cache.effectCounts = new Map();
            for (const [effect, nodes] of index.nodesByEffect) {
                cache.effectCounts.set(effect, nodes.length);
            }
        }
        return cache.effectCounts;
    }

    function getEdgeTypeCounts() {
        if (!cache.edgeTypeCounts) {
            cache.edgeTypeCounts = new Map();
            for (const link of raw.links) {
                const type = link.edge_type || link.type || 'unknown';
                cache.edgeTypeCounts.set(type, (cache.edgeTypeCounts.get(type) || 0) + 1);
            }
        }
        return cache.edgeTypeCounts;
    }

    function getEdgeFamilyCounts() {
        if (!cache.edgeFamilyCounts) {
            cache.edgeFamilyCounts = new Map();
            for (const link of raw.links) {
                const family = link.family || 'Dependency';
                cache.edgeFamilyCounts.set(family, (cache.edgeFamilyCounts.get(family) || 0) + 1);
            }
        }
        return cache.edgeFamilyCounts;
    }

    function getEdgeRanges() {
        if (!cache.edgeRanges) {
            let minW = Infinity, maxW = -Infinity;
            let minC = Infinity, maxC = -Infinity;
            for (const link of raw.links) {
                const w = link.weight ?? 1;
                const c = link.confidence ?? 1;
                if (w < minW) minW = w;
                if (w > maxW) maxW = w;
                if (c < minC) minC = c;
                if (c > maxC) maxC = c;
            }
            cache.edgeRanges = {
                weight: { min: minW === Infinity ? 0 : minW, max: maxW === -Infinity ? 1 : maxW },
                confidence: { min: minC === Infinity ? 0 : minC, max: maxC === -Infinity ? 1 : maxC }
            };
        }
        return cache.edgeRanges;
    }

    /**
     * Get min/max range for a source property across a specific scope.
     * NOT cached - calculates fresh each call (scopes change dynamically).
     *
     * @param {string} sourceKey - Property name (e.g., 'token_estimate', 'in_degree')
     * @param {string} scope - 'global' | 'visible' | 'selection'
     * @returns { min: number, max: number } Range object
     */
    function getRange(sourceKey, scope = 'global') {
        // Get node set based on scope
        let nodes;
        switch (scope) {
            case 'selection':
                nodes = (typeof SELECTION !== 'undefined' && SELECTION.getSelectedNodes)
                    ? SELECTION.getSelectedNodes()
                    : [];
                break;
            case 'visible':
                nodes = getVisibleNodes();
                break;
            case 'global':
            default:
                nodes = raw.nodes;
                break;
        }

        // Extract numeric values
        const values = [];
        for (const node of nodes) {
            const val = _getNodeValue(node, sourceKey);
            if (typeof val === 'number' && !Number.isNaN(val)) {
                values.push(val);
            }
        }

        // Return safe range
        if (values.length === 0) {
            return { min: 0, max: 1 };
        }

        return {
            min: Math.min(...values),
            max: Math.max(...values)
        };
    }

    /**
     * Extract a value from a node for a given source key.
     * Handles nested properties and computed values.
     */
    function _getNodeValue(node, sourceKey) {
        if (!node || !sourceKey) return undefined;

        // Direct property
        if (node[sourceKey] !== undefined) {
            return node[sourceKey];
        }

        // Nested in metrics
        if (node.metrics && node.metrics[sourceKey] !== undefined) {
            return node.metrics[sourceKey];
        }

        // Computed values
        switch (sourceKey) {
            case 'in_degree':
                return (getEdgesTo(node.id) || []).length;
            case 'out_degree':
                return (getEdgesFrom(node.id) || []).length;
            case 'degree':
                return (getEdgesTo(node.id) || []).length + (getEdgesFrom(node.id) || []).length;
            default:
                return undefined;
        }
    }

    // =========================================================================
    // SELF-TEST
    // =========================================================================

    function selfTest() {
        const errors = [];
        const warnings = [];
        const seenIds = new Set();

        for (const node of raw.nodes) {
            if (!node?.id) {
                errors.push('Node missing id');
                continue;
            }
            if (seenIds.has(node.id)) {
                errors.push(`Duplicate node id: ${node.id}`);
                continue;
            }
            seenIds.add(node.id);
        }

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');
            if (srcId && !index.nodeById.has(srcId)) {
                warnings.push(`Edge source not in graph: ${srcId}`);
            }
            if (tgtId && !index.nodeById.has(tgtId)) {
                warnings.push(`Edge target not in graph: ${tgtId}`);
            }
        }

        const status = errors.length === 0 ? 'PASS' : 'FAIL';
        const style = errors.length === 0
            ? 'color: #4ade80; font-weight: bold'
            : 'color: #f87171; font-weight: bold';

        console.log(`%c[DATA] Self-Test: ${status}`, style);
        console.log(`  Raw: ${raw.nodes.length} nodes, ${raw.links.length} edges`);
        console.log(`  Indexes: nodeById=${index.nodeById.size}, tiers=${index.nodesByTier.size}`);

        if (errors.length > 0) console.error('[DATA] Errors:', errors);
        if (warnings.length > 0) {
            console.warn('[DATA] Warnings:', warnings.slice(0, 5));
            if (warnings.length > 5) console.warn(`  ... and ${warnings.length - 5} more`);
        }

        return { errors, warnings, pass: errors.length === 0 };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Init
        init,

        // Raw data
        getNodes,
        getLinks,
        getFileBoundaries,
        getMarkov,
        getKpis,
        getMeta,
        getPhysics,
        getConfig,
        getCodomeBooudaries,
        getAnalytics,

        // Indexed lookups
        getNode,
        getNodesByTier,
        getNodesByFamily,
        getNodesByRing,
        getNodesByLayer,
        getNodesByEffect,
        getNodesByFile,
        getEdgesFrom,
        getEdgesTo,
        getEdgeBetween,
        getFile,
        getTopMarkovEdges,
        isHighEntropyNode,

        // Filtered data
        setFiltered,
        getVisibleNodes,
        getVisibleLinks,

        // Aggregations
        getTierCounts,
        getFamilyCounts,
        getRingCounts,
        getLayerCounts,
        getEffectCounts,
        getEdgeTypeCounts,
        getEdgeFamilyCounts,
        getEdgeRanges,
        getRange,

        // Self-test
        selfTest,

        // Direct access (for migration)
        raw,
        index,
        cache,
        filtered,

        // Legend reference
        get legend() { return _legend; },

        // Color access (convenience)
        get color() { return COLOR; }
    };
})();

// Backward compatibility - DataManager class wrapper
class DataManager {
    constructor() {
        this.raw = DATA.raw;
        this.analytics = {};
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = null;
        this.color = COLOR;
    }

    init(data) {
        DATA.init(data);
        this.raw = DATA.raw;
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = DATA.legend;
        return this;
    }

    // Delegate all methods to DATA module
    getNodes() { return DATA.getNodes(); }
    getLinks() { return DATA.getLinks(); }
    getFileBoundaries() { return DATA.getFileBoundaries(); }
    getMarkov() { return DATA.getMarkov(); }
    getKpis() { return DATA.getKpis(); }
    getMeta() { return DATA.getMeta(); }
    getCodomeBooudaries() { return DATA.getCodomeBooudaries(); }
    getNode(id) { return DATA.getNode(id); }
    getNodesByTier(tier) { return DATA.getNodesByTier(tier); }
    getNodesByFamily(family) { return DATA.getNodesByFamily(family); }
    getNodesByRing(ring) { return DATA.getNodesByRing(ring); }
    getNodesByFile(fileIdx) { return DATA.getNodesByFile(fileIdx); }
    getEdgesFrom(nodeId) { return DATA.getEdgesFrom(nodeId); }
    getEdgesTo(nodeId) { return DATA.getEdgesTo(nodeId); }
    getEdgeBetween(srcId, tgtId) { return DATA.getEdgeBetween(srcId, tgtId); }
    getFile(idx) { return DATA.getFile(idx); }
    getTopMarkovEdges(nodeId, k) { return DATA.getTopMarkovEdges(nodeId, k); }
    isHighEntropyNode(nodeId) { return DATA.isHighEntropyNode(nodeId); }
    setFiltered(nodes, links) { DATA.setFiltered(nodes, links); }
    getVisibleNodes() { return DATA.getVisibleNodes(); }
    getVisibleLinks() { return DATA.getVisibleLinks(); }
    getTierCounts() { return DATA.getTierCounts(); }
    getFamilyCounts() { return DATA.getFamilyCounts(); }
    getRingCounts() { return DATA.getRingCounts(); }
    getLayerCounts() { return DATA.getLayerCounts(); }
    getEffectCounts() { return DATA.getEffectCounts(); }
    getEdgeTypeCounts() { return DATA.getEdgeTypeCounts(); }
    getEdgeFamilyCounts() { return DATA.getEdgeFamilyCounts(); }
    getEdgeRanges() { return DATA.getEdgeRanges(); }
    getRange(sourceKey, scope) { return DATA.getRange(sourceKey, scope); }
    selfTest() { return DATA.selfTest(); }

    // Internal methods
    _buildAllIndexes() {}
    _buildNodeIndex() {}
    _buildSemanticIndexes() {}
    _buildEdgeIndexes() {}
    _buildFileIndex() {}
    _buildMarkovIndex() {}
    _invalidateCache() {}
    _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }
    _getNodeTier(node) { return NODE.getTier(node); }
    _getNodeFamily(node) { return NODE.getFamily(node); }
    _getNodeRing(node) { return NODE.getRing(node); }
    _getNodeLayer(node) { return NODE.getLayer(node); }
    _getNodeEffect(node) { return NODE.getEffect(node); }
}

// Global DM instance - defined by app.js (not duplicated here to avoid redeclaration)
// DM is accessed as a global variable provided by app.js

// Parity check function
function runDmParity(dm, data) {
    if (!dm) return;
    const checks = [];
    const rawNodes = Array.isArray(data?.nodes) ? data.nodes.length : 0;
    const rawEdges = Array.isArray(data?.links) ? data.links.length : 0;
    const dmNodes = dm.raw.nodes.length;
    const dmEdges = dm.raw.links.length;

    checks.push({ name: 'Node count', dm: dmNodes, old: rawNodes, pass: dmNodes === rawNodes });
    checks.push({ name: 'Edge count', dm: dmEdges, old: rawEdges, pass: dmEdges === rawEdges });
    checks.push({ name: 'Node index size', dm: dm.index.nodeById.size, old: rawNodes, pass: dm.index.nodeById.size === rawNodes });

    const allPass = checks.every(c => c.pass);
    const style = allPass ? 'color: #4ade80; font-weight: bold' : 'color: #f87171; font-weight: bold';
    console.log(`%c[DM Parity] ${allPass ? 'ALL PASS' : 'MISMATCH'}`, style);
    checks.forEach(c => {
        const icon = c.pass ? '✓' : '✗';
        console.log(`  ${icon} ${c.name}: DM=${c.dm}, Raw=${c.old}`);
    });
}


// ═══ MODULE: modules/vis-state.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VIS-STATE MODULE - Unified visualization state management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Single source of truth for visualization state. All controls funnel through
 * applyState() to ensure consistency.
 *
 * KEY DESIGN DECISIONS:
 * 1. Palette selection NEVER auto-switches colorBy mode
 * 2. Palette is "armed" - it applies when colorBy changes to interval mode
 * 3. Presets are macros that call applyState() with multiple properties
 * 4. syncUIFromState() updates all UI elements to match state
 *
 * @module VIS_STATE
 * @version 1.0.0
 */

window.VIS_STATE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CATEGORICAL vs INTERVAL MODE CLASSIFICATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Categorical modes use discrete color palettes (tier, family, atom...)
     * Interval modes use continuous gradients (complexity, fan_in, loc...)
     */
    const CATEGORICAL_MODES = new Set([
        'tier', 'family', 'atom', 'ring', 'layer', 'role', 'roleCategory',
        'subsystem', 'phase', 'fileType', 'file', 'state', 'visibility'
    ]);

    const INTERVAL_MODES = new Set([
        'complexity', 'loc', 'fan_in', 'fan_out', 'trust',
        'responsibility', 'purity', 'lifecycle_score', 'boundary_score',
        'centrality', 'rank', 'churn', 'age', 'depth'
    ]);

    function isIntervalMode(mode) {
        return INTERVAL_MODES.has(mode);
    }

    function isCategoricalMode(mode) {
        return CATEGORICAL_MODES.has(mode);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATE OBJECT - Single source of truth
    // ═══════════════════════════════════════════════════════════════════════

    const state = {
        colorBy: 'fan_in',         // Default to interval mode to show OKLCH schemes
        sizeBy: 'fanout',          // 'uniform', 'degree', 'fanout', 'complexity'
        edgeBy: 'type',            // 'type', 'resolution', 'weight', 'gradient-tier', etc.
        palette: 'helix',          // OKLCH helix path - visually striking default
        paletteType: 'interval'    // Derived: 'categorical' or 'interval'
    };

    // ═══════════════════════════════════════════════════════════════════════
    // VIEW PRESETS - Macros that set multiple properties at once
    // ═══════════════════════════════════════════════════════════════════════

    const VIEW_PRESETS = {
        tier: {
            label: 'Tier',
            description: 'T0/T1/T2 architectural height',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        family: {
            label: 'Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        layer: {
            label: 'Layer',
            description: 'Physical/Virtual/Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        ring: {
            label: 'Ring',
            description: 'Domain architecture rings',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        file: {
            label: 'File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        flow: {
            label: 'Flow',
            description: 'Markov transition probability',
            colorBy: 'fan_in',  // Use interval mode for flow
            sizeBy: 'degree',
            edgeBy: 'weight',
            special: 'flow'    // Triggers flow visualization
        }
    };

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY STATE - Central function all controls use
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply state changes. This is THE function all UI controls call.
     *
     * @param {Object} nextState - Partial state to merge
     * @param {string} reason - Debug label for console (e.g., 'preset:tier', 'control:colorBy')
     */
    function applyState(nextState, reason = 'unknown') {
        const prevColorBy = state.colorBy;
        const prevPalette = state.palette;

        // Merge new state
        if (nextState.colorBy !== undefined) state.colorBy = nextState.colorBy;
        if (nextState.sizeBy !== undefined) state.sizeBy = nextState.sizeBy;
        if (nextState.edgeBy !== undefined) state.edgeBy = nextState.edgeBy;
        if (nextState.palette !== undefined) state.palette = nextState.palette;

        // Derive paletteType from colorBy
        state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';

        console.log(`[VIS_STATE] applyState(${reason}):`, {
            colorBy: state.colorBy,
            sizeBy: state.sizeBy,
            edgeBy: state.edgeBy,
            palette: state.palette,
            paletteType: state.paletteType
        });

        // ─── Apply color mode ───
        if (nextState.colorBy !== undefined && nextState.colorBy !== prevColorBy) {
            _applyColorMode(state.colorBy);
        }

        // ─── Apply size mode ───
        if (nextState.sizeBy !== undefined) {
            _applySizeMode(state.sizeBy);
        }

        // ─── Apply edge mode ───
        if (nextState.edgeBy !== undefined) {
            _applyEdgeMode(state.edgeBy);
        }

        // ─── Apply palette (only if in interval mode) ───
        if (nextState.palette !== undefined || nextState.colorBy !== undefined) {
            _applyPalette();
        }

        // ─── Handle special modes (flow) ───
        if (nextState.special === 'flow') {
            _enableFlowMode();
        } else if (prevColorBy === 'flow' && nextState.colorBy !== 'flow') {
            _disableFlowMode();
        }

        // ─── Sync UI to match state ───
        syncUIFromState();

        // ─── Refresh visualization ───
        _refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INTERNAL APPLY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════

    function _applyColorMode(mode) {
        // Update globals for backward compatibility
        window.NODE_COLOR_MODE = mode;

        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.colorMode = mode;
            window.APPEARANCE_STATE.currentPreset = mode;
        }

        // Disable flow mode if switching away from flow
        if (mode !== 'flow' && typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _applySizeMode(mode) {
        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.sizeMode = mode;
        }

        if (typeof window.applyNodeSizeMode === 'function') {
            window.applyNodeSizeMode(mode);
        } else if (typeof window.NODE_HELPERS !== 'undefined') {
            window.NODE_HELPERS.applySizeMode(mode);
        }
    }

    function _applyEdgeMode(mode) {
        if (typeof window.EDGE_GRADIENT_MODE !== 'undefined') {
            // Edge gradient modes
            if (mode.startsWith('gradient-')) {
                window.EDGE_GRADIENT_MODE = mode.replace('gradient-', '');
            }
        }

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
    }

    function _applyPalette() {
        // Only apply scheme coloring if in interval mode
        if (state.paletteType === 'interval' && state.palette) {
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(state.palette);
            }
        } else {
            // In categorical mode, clear active scheme
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(null);
            }
        }
    }

    function _enableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && !window.flowMode) {
            if (typeof window.toggleFlowMode === 'function') {
                window.toggleFlowMode();
            }
        }
    }

    function _disableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _refreshGraph() {
        // Recompute node colors
        const DM = window.DM;
        const Graph = window.Graph;
        const nodes = DM ? DM.getNodes() : (Graph?.graphData ? Graph.graphData().nodes : []);

        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render with new function reference to force update
        if (Graph) {
            Graph.nodeColor(n => n.color);
        }

        // Refresh edge gradients
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        // Re-render legends
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SYNC UI FROM STATE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all UI elements to reflect current state.
     * Called after every applyState() and on initialization.
     */
    function syncUIFromState() {
        // ─── View Preset buttons ───
        document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
            const presetKey = btn.dataset.preset;
            const preset = VIEW_PRESETS[presetKey];
            const isActive = preset && preset.colorBy === state.colorBy;
            btn.classList.toggle('active', isActive);
        });

        // ─── Color Mode buttons (PRESET_CONFIG grid) ───
        document.querySelectorAll('.color-btn[data-preset]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.preset === state.colorBy);
        });

        // ─── Size Mode buttons ───
        document.querySelectorAll('[data-size-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.sizeMode === state.sizeBy);
        });

        // ─── Edge Mode buttons ───
        document.querySelectorAll('[data-edge-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.edgeMode === state.edgeBy);
        });

        // ─── Palette buttons ───
        document.querySelectorAll('.scheme-btn[data-scheme]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.scheme === state.palette);
        });

        // ─── Palette panel enabled/disabled state ───
        const schemesPanel = document.getElementById('section-schemes');
        if (schemesPanel) {
            const isDisabled = state.paletteType === 'categorical';
            schemesPanel.classList.toggle('disabled', isDisabled);

            // Update scheme buttons opacity/interactivity
            schemesPanel.querySelectorAll('.scheme-btn').forEach(btn => {
                btn.disabled = isDisabled;
                btn.style.opacity = isDisabled ? '0.4' : '1';
                btn.style.pointerEvents = isDisabled ? 'none' : 'auto';
            });

            // Show hint when disabled
            let hint = schemesPanel.querySelector('.scheme-hint');
            if (isDisabled) {
                if (!hint) {
                    hint = document.createElement('div');
                    hint.className = 'scheme-hint';
                    hint.style.cssText = 'padding: 8px; font-size: 10px; opacity: 0.6; text-align: center; font-style: italic;';
                    hint.textContent = 'Switch to a metric mode (Fan-In, Complexity, etc.) to enable color schemes';
                    schemesPanel.insertBefore(hint, schemesPanel.firstChild);
                }
            } else if (hint) {
                hint.remove();
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVENIENCE METHODS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply a view preset by name
     */
    function applyPreset(presetKey) {
        const preset = VIEW_PRESETS[presetKey];
        if (!preset) {
            console.warn('[VIS_STATE] Unknown preset:', presetKey);
            return;
        }

        applyState({
            colorBy: preset.colorBy,
            sizeBy: preset.sizeBy,
            edgeBy: preset.edgeBy,
            special: preset.special
        }, `preset:${presetKey}`);
    }

    /**
     * Set color mode only
     */
    function setColorBy(mode) {
        applyState({ colorBy: mode }, `colorBy:${mode}`);
    }

    /**
     * Set size mode only
     */
    function setSizeBy(mode) {
        applyState({ sizeBy: mode }, `sizeBy:${mode}`);
    }

    /**
     * Set edge mode only
     */
    function setEdgeBy(mode) {
        applyState({ edgeBy: mode }, `edgeBy:${mode}`);
    }

    /**
     * Set palette (arms the palette, applies if in interval mode)
     */
    function setPalette(schemeName) {
        applyState({ palette: schemeName }, `palette:${schemeName}`);
    }

    /**
     * Get current state (read-only copy)
     */
    function getState() {
        return { ...state };
    }

    /**
     * Initialize from saved preferences or defaults
     */
    function init() {
        try {
            const savedScheme = localStorage.getItem('collider_scheme');
            const savedColorMode = localStorage.getItem('collider_color_mode');

            if (savedScheme) state.palette = savedScheme;
            if (savedColorMode) state.colorBy = savedColorMode;

            state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';
        } catch (e) { /* ignore localStorage errors */ }

        // Apply initial state to globals (critical for NODE_COLOR_MODE)
        _applyColorMode(state.colorBy);
        _applyPalette();

        console.log('[VIS_STATE] Initialized:', state);
    }

    /**
     * Save current preferences
     */
    function savePreferences() {
        try {
            localStorage.setItem('collider_scheme', state.palette);
            localStorage.setItem('collider_color_mode', state.colorBy);
        } catch (e) { /* ignore */ }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // State access
        getState,
        isIntervalMode,
        isCategoricalMode,

        // Main API
        applyState,
        applyPreset,
        syncUIFromState,

        // Convenience setters
        setColorBy,
        setSizeBy,
        setEdgeBy,
        setPalette,

        // Lifecycle
        init,
        savePreferences,

        // Constants
        VIEW_PRESETS,
        CATEGORICAL_MODES,
        INTERVAL_MODES
    };
})();

console.log('[Module] VIS_STATE loaded - unified visualization state');


// ═══ MODULE: modules/ui-manager.js ═══
/**
 * @module ui-manager
 * @description Orchestrates the "One Dock" unified interface
 * @responsibility Manage sidebar, dock, modes, and filters UI
 * @depends_on vis-state, data-manager, refresh-throttle
 */

const UI_MANAGER = (function() {
    'use strict';

    // Private state
    let _data = null;
    let _initialized = false;

    /**
     * Initialize the UI Manager
     * @param {Object} data - Graph data object
     */
    function init(data) {
        _data = data;
        _setupSidebar();
        _setupDock();
        _setupModes();
        _populateFilters();
        _updateStatus();
        _initialized = true;
    }

    /**
     * Setup sidebar toggle and accordion behavior
     */
    function _setupSidebar() {
        const sidebar = document.getElementById('sidebar');
        const btnFilters = document.getElementById('btn-filters');
        const btnClose = document.getElementById('sidebar-close');

        const toggle = () => {
            sidebar.classList.toggle('open');
            _updateFilterBadge();
        };

        if (btnFilters) btnFilters.onclick = (e) => {
            e.stopPropagation();
            toggle();
        };
        if (btnClose) btnClose.onclick = () => sidebar.classList.remove('open');

        // Accordion Logic
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.onclick = () => {
                const accordion = header.parentElement;
                accordion.classList.toggle('open');
            };
        });
    }

    /**
     * Setup dock controls
     */
    function _setupDock() {
        // Reset Layout
        const btnReset = document.getElementById('btn-reset-layout');
        if (btnReset) btnReset.onclick = () => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.zoomToFit(1000);
            }
        };

        // Dimensions Toggle (2D/3D - stub)
        const btnDim = document.getElementById('btn-dimensions');
        if (btnDim) btnDim.onclick = () => {
            console.log("Dimension toggle requested");
        };

        // Report Button
        const btnReport = document.getElementById('btn-report');
        if (btnReport) btnReport.onclick = () => {
            const reportPanel = document.getElementById('report-panel');
            if (reportPanel) {
                const isHidden = reportPanel.style.display === 'none';
                reportPanel.style.display = isHidden ? 'block' : 'none';
                btnReport.classList.toggle('active', isHidden);
            }
        };
    }

    /**
     * Setup mode buttons (explore, files, flow)
     */
    function _setupModes() {
        const modes = ['explore', 'files', 'flow'];

        const setMode = (mode) => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.getElementById(`mode-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');

            document.querySelectorAll('.mode-control-group').forEach(g => g.style.display = 'none');
            const group = document.getElementById(`${mode}-controls`);
            if (group) group.style.display = 'flex';
        };

        modes.forEach(mode => {
            const btn = document.getElementById(`mode-${mode}`);
            if (btn) btn.onclick = () => setMode(mode);
        });

        // Files Sub-controls wiring
        const bindToggle = (id, onClick) => {
            const el = document.getElementById(id);
            if (el) el.onclick = (e) => {
                e.target.classList.toggle('active');
                if (onClick) onClick(e.target.classList.contains('active'));
            };
        };

        bindToggle('btn-file-hulls', (_active) => {
            // Toggle hull visibility
        });
    }

    /**
     * Populate filter chips for all categories
     */
    function _populateFilters() {
        if (!_data) return;

        // Helper: Create Filter Chips
        const createChips = (containerId, counts, activeSet) => {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            counts.forEach(([key, count]) => {
                const chip = document.createElement('div');
                const isActive = activeSet.has(key);
                chip.className = `filter-chip ${isActive ? 'active' : ''}`;
                chip.innerHTML = `${key} <span class="chip-count">${count}</span>`;
                chip.onclick = () => {
                    if (activeSet.has(key)) activeSet.delete(key);
                    else activeSet.add(key);

                    chip.classList.toggle('active');
                    _updateFilterBadge();
                    // Call refreshGraph if available
                    if (typeof refreshGraph === 'function') refreshGraph();
                };
                container.appendChild(chip);
            });

            const type = containerId.replace('filter-', '');
            const countEl = document.getElementById(`count-${type}`);
            if (countEl) countEl.innerText = activeSet.size;
        };

        // Get accessor functions
        const getNodeRing = typeof window.getNodeRing === 'function' ? window.getNodeRing :
            (typeof NODE !== 'undefined' ? NODE.getRing : (n => n.ring || 'Unknown'));
        const getNodeTier = typeof window.getNodeTier === 'function' ? window.getNodeTier :
            (typeof NODE !== 'undefined' ? NODE.getTier : (n => n.tier || 'Unknown'));
        const getNodeAtomFamily = typeof window.getNodeAtomFamily === 'function' ? window.getNodeAtomFamily :
            (typeof NODE !== 'undefined' ? NODE.getFamily : (n => n.atom_family || 'Unknown'));
        const normalizeRingValue = typeof window.normalizeRingValue === 'function' ? window.normalizeRingValue :
            (typeof NODE !== 'undefined' ? NODE.normalizeRing : (v => v));
        const collectCounts = typeof window.collectCounts === 'function' ? window.collectCounts :
            _defaultCollectCounts;

        // Get VIS_FILTERS
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set(), edges: new Set(), families: new Set() };

        // 1. LAYERS (Rings)
        const ringCounts = collectCounts(_data.nodes, getNodeRing);
        const rawRingDefaults = _data.controls?.filters?.rings || [];
        const ringDefaults = rawRingDefaults
            .map(v => normalizeRingValue(v))
            .filter(v => v !== null);

        if (VIS_FILTERS.rings.size === 0 && ringDefaults.length > 0) {
            const availableRings = new Set(ringCounts.map(([ring]) => ring));
            const matchedRings = ringDefaults.filter(r => availableRings.has(r));
            if (matchedRings.length > 0) {
                matchedRings.forEach(r => VIS_FILTERS.rings.add(r));
            } else {
                const familyCounts = collectCounts(_data.nodes, getNodeAtomFamily);
                const availableFamilies = new Set(familyCounts.map(([family]) => family));
                const matchedFamilies = ringDefaults.filter(f => availableFamilies.has(f));
                if (matchedFamilies.length > 0 && VIS_FILTERS.families.size === 0) {
                    matchedFamilies.forEach(f => VIS_FILTERS.families.add(f));
                    console.warn('[Filters] Ring defaults matched families; applying as family filters.');
                }
            }
        }
        createChips('filter-rings', ringCounts, VIS_FILTERS.rings);

        // 2. TIERS
        const tierCounts = collectCounts(_data.nodes, getNodeTier);
        createChips('filter-tiers', tierCounts, VIS_FILTERS.tiers);

        // 3. ROLES
        const roleCounts = collectCounts(_data.nodes, n => String(n.role || 'Unknown'));
        createChips('filter-roles', roleCounts, VIS_FILTERS.roles);

        // 4. EDGES
        const edgeCounts = collectCounts(_data.links, l => String(l.edge_type || l.type || 'default'));
        createChips('filter-edges', edgeCounts, VIS_FILTERS.edges);

        // 5. DATAMAPS
        _populateDatamaps();

        _updateFilterBadge();
    }

    /**
     * Default collectCounts implementation
     */
    function _defaultCollectCounts(items, accessor) {
        const counts = new Map();
        items.forEach(item => {
            const key = accessor(item);
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    /**
     * Populate datamap chips
     */
    function _populateDatamaps() {
        const container = document.getElementById('filter-datamaps');
        if (!container) return;
        container.innerHTML = '';

        const controls = _data.controls || {};
        const resolveDatamapConfigs = typeof window.resolveDatamapConfigs === 'function'
            ? window.resolveDatamapConfigs
            : () => [];
        const configs = resolveDatamapConfigs(controls);
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS || new Set();
        const setDatamap = typeof window.setDatamap === 'function' ? window.setDatamap : () => {};

        configs.forEach(cfg => {
            const chip = document.createElement('div');
            const isActive = ACTIVE_DATAMAPS.has(cfg.id);
            chip.className = `filter-chip ${isActive ? 'active' : ''}`;
            chip.style.width = '100%';
            chip.style.marginBottom = '4px';
            chip.innerHTML = `${cfg.label}`;

            chip.onclick = () => {
                setDatamap(cfg.id);
                Array.from(container.children).forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            };
            container.appendChild(chip);
        });

        const countEl = document.getElementById('count-datamaps');
        if (countEl) countEl.innerText = configs.length;
    }

    /**
     * Update filter badge count
     */
    function _updateFilterBadge() {
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set() };

        let total = 0;
        total += VIS_FILTERS.rings.size;
        total += VIS_FILTERS.tiers.size;
        total += VIS_FILTERS.roles.size;

        const badge = document.getElementById('filter-badge');
        const miniBadge = document.getElementById('filter-badge-mini');

        if (badge) badge.innerText = total;
        if (miniBadge) {
            miniBadge.innerText = total;
            miniBadge.classList.toggle('visible', total > 0);
        }

        const summary = document.getElementById('filter-summary');
        if (summary) {
            summary.innerText = total > 0 ? `${total} filters active` : "No filters active";
        }
    }

    /**
     * Update status display (node/edge counts)
     */
    function _updateStatus() {
        if (_data && _data.nodes) {
            const n = _data.nodes.length;
            const e = _data.links.length;
            const statusNodes = document.getElementById('status-nodes');
            const statusEdges = document.getElementById('status-edges');

            if (statusNodes) statusNodes.innerText = n;
            if (statusEdges) statusEdges.innerText = e;
        }
    }

    /**
     * Refresh filters (re-populate from current data)
     */
    function refreshFilters() {
        _populateFilters();
    }

    /**
     * Update badge count (public interface)
     */
    function updateFilterBadge() {
        _updateFilterBadge();
    }

    // Public API
    return {
        init,
        refreshFilters,
        updateFilterBadge,
        get data() { return _data; },
        get initialized() { return _initialized; }
    };
})();

// Backward compatibility - expose as UIManager
const UIManager = {
    data: null,
    init(data) {
        this.data = data;
        UI_MANAGER.init(data);
    },
    setupSidebar() { /* Now internal */ },
    setupDock() { /* Now internal */ },
    setupModes() { /* Now internal */ },
    populateFilters() { UI_MANAGER.refreshFilters(); },
    populateDatamaps() { UI_MANAGER.refreshFilters(); },
    updateFilterBadge() { UI_MANAGER.updateFilterBadge(); },
    updateStatus() { /* Now internal */ }
};

// Expose globally
window.UI_MANAGER = UI_MANAGER;
window.UIManager = UIManager;


// ═══ MODULE: modules/physics.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * PHYSICS MODULE - Force simulation controls
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Physics presets, sliders, and force parameter management.
 * Depends on: Graph, PHYSICS_STATE, PHYSICS_PRESETS (globals)
 *
 * @module PHYSICS
 * @version 1.0.0
 */

window.PHYSICS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS STATE
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsState() {
        const Graph = window.Graph;
        const PHYSICS_STATE = window.PHYSICS_STATE;
        if (!Graph) return;
        try {
            Graph.d3Force('charge')?.strength(PHYSICS_STATE.charge);
            Graph.d3Force('link')?.distance(PHYSICS_STATE.linkDistance);
            Graph.d3Force('center')?.strength(PHYSICS_STATE.centerStrength);
            Graph.d3VelocityDecay?.(PHYSICS_STATE.velocityDecay);
            Graph.d3ReheatSimulation();
        } catch (e) {
            console.warn('[Physics] Could not apply:', e.message);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS PRESET
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsPreset(presetName) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const preset = PHYSICS_PRESETS[presetName];
        if (!preset) return;
        Object.assign(PHYSICS_STATE, {
            charge: preset.charge,
            linkDistance: preset.linkDistance,
            centerStrength: preset.centerStrength,
            velocityDecay: preset.velocityDecay
        });
        applyPhysicsState();
        updatePhysicsSliders();
        window.showModeToast(`Physics: ${preset.label}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE PHYSICS SLIDERS
    // ═══════════════════════════════════════════════════════════════════════

    function updatePhysicsSliders() {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const sliders = {
            'physics-charge': PHYSICS_STATE.charge,
            'physics-link-distance': PHYSICS_STATE.linkDistance,
            'physics-center': PHYSICS_STATE.centerStrength,
            'physics-damping': PHYSICS_STATE.velocityDecay
        };
        for (const [id, value] of Object.entries(sliders)) {
            const input = document.getElementById(id);
            const display = document.getElementById(id + '-value');
            if (input) input.value = value;
            if (display) display.textContent = typeof value === 'number' && value % 1 !== 0 ? value.toFixed(2) : value;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // BUILD PHYSICS CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function buildPhysicsControls(containerId) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const container = document.getElementById(containerId);
        if (!container) return;

        // Preset buttons
        const presetRow = document.createElement('div');
        presetRow.className = 'physics-presets';
        presetRow.style.cssText = 'display:flex;gap:4px;margin-bottom:8px;flex-wrap:wrap;';
        Object.entries(PHYSICS_PRESETS).forEach(([key, preset]) => {
            const btn = document.createElement('button');
            btn.className = 'preset-btn physics-preset-btn';
            btn.textContent = preset.label;
            btn.style.cssText = 'font-size:9px;padding:2px 6px;';
            btn.onclick = () => applyPhysicsPreset(key);
            presetRow.appendChild(btn);
        });
        container.appendChild(presetRow);

        // Sliders
        const sliderDefs = [
            {
                id: 'physics-charge',
                label: 'REPULSION',
                min: -500,
                max: 50,
                step: 10,
                value: PHYSICS_STATE.charge,
                onChange: (val) => { PHYSICS_STATE.charge = val; applyPhysicsState(); }
            },
            {
                id: 'physics-link-distance',
                label: 'LINK DIST',
                min: 10,
                max: 200,
                step: 5,
                value: PHYSICS_STATE.linkDistance,
                onChange: (val) => { PHYSICS_STATE.linkDistance = val; applyPhysicsState(); }
            },
            {
                id: 'physics-center',
                label: 'CENTER PULL',
                min: 0,
                max: 0.3,
                step: 0.01,
                value: PHYSICS_STATE.centerStrength,
                onChange: (val) => { PHYSICS_STATE.centerStrength = val; applyPhysicsState(); }
            },
            {
                id: 'physics-damping',
                label: 'DAMPING',
                min: 0,
                max: 1,
                step: 0.05,
                value: PHYSICS_STATE.velocityDecay,
                onChange: (val) => { PHYSICS_STATE.velocityDecay = val; applyPhysicsState(); }
            }
        ];

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row';

            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            valueDisplay.textContent = def.step < 1 ? def.value.toFixed(2) : def.value;
            header.appendChild(label);
            header.appendChild(valueDisplay);

            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = def.value;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = def.step < 1 ? val.toFixed(2) : val;
                def.onChange(val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);
            container.appendChild(wrapper);
        });

        console.log('[Physics] Controls initialized');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        applyState: applyPhysicsState,
        applyPreset: applyPhysicsPreset,
        updateSliders: updatePhysicsSliders,
        buildControls: buildPhysicsControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.applyPhysicsState = PHYSICS.applyState;
window.applyPhysicsPreset = PHYSICS.applyPreset;
window.updatePhysicsSliders = PHYSICS.updateSliders;
window.buildPhysicsControls = PHYSICS.buildControls;

console.log('[Module] PHYSICS loaded - 4 functions');


// ═══ MODULE: modules/datamap.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DATAMAP MODULE - Data mapping and filtering
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Datamap configuration, matching, and UI control updates.
 * Depends on: DM, VIS_FILTERS, ACTIVE_DATAMAPS, NODE (node-accessors)
 *
 * @module DATAMAP
 * @version 1.0.0
 */

window.DATAMAP = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NORMALIZE DATAMAP CONFIG
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeDatamapConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const id = String(raw.id || raw.key || raw.label || '').trim();
        if (!id) return null;
        const normalizeList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => String(item).toUpperCase());
        };
        const normalizeTierList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => window.normalizeTier(item));
        };
        const match = raw.match || {};
        return {
            id: id.toUpperCase(),
            label: String(raw.label || raw.id || id).toUpperCase(),
            match: {
                atom_families: normalizeList(match.atom_families),
                atom_prefixes: normalizeList(match.atom_prefixes),
                tiers: normalizeTierList(match.tiers),
                rings: normalizeList(match.rings),
                roles: normalizeList(match.roles)
            },
            default: Boolean(raw.default)
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // RESOLVE DATAMAP CONFIGS
    // ═══════════════════════════════════════════════════════════════════════

    function resolveDatamapConfigs(controlsConfig) {
        const fromTokens = Array.isArray(controlsConfig.datamaps) ? controlsConfig.datamaps : [];
        const normalized = fromTokens
            .map(normalizeDatamapConfig)
            .filter(Boolean);
        if (normalized.length) return normalized;

        const fallback = controlsConfig.buttons?.datamaps || {};
        return Object.entries(fallback).map(([label, config]) => {
            const prefix = config.filter || null;
            return normalizeDatamapConfig({
                id: label.toUpperCase(),
                label: label.toUpperCase(),
                match: prefix ? { atom_prefixes: [prefix] } : {},
                default: false
            });
        }).filter(Boolean);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP MATCHING
    // ═══════════════════════════════════════════════════════════════════════

    function datamapMatches(node, config) {
        const match = config.match || {};
        const atomId = String(node.atom || '');
        const atomFamily = window.getNodeAtomFamily(node);
        const tier = window.getNodeTier(node);
        const ring = window.getNodeRing(node);
        const role = String(node.role || 'Unknown').toUpperCase();

        if (Array.isArray(match.atom_families) && match.atom_families.length) {
            if (!match.atom_families.includes(atomFamily)) return false;
        }

        if (Array.isArray(match.atom_prefixes) && match.atom_prefixes.length) {
            const matchesFamily = match.atom_prefixes.includes(atomFamily);
            const matchesPrefix = match.atom_prefixes.some(prefix => atomId.startsWith(prefix));
            if (!matchesFamily && !matchesPrefix) return false;
        }

        if (Array.isArray(match.tiers) && match.tiers.length) {
            if (!match.tiers.includes(tier)) return false;
        }

        if (Array.isArray(match.rings) && match.rings.length) {
            if (!match.rings.includes(ring)) return false;
        }

        if (Array.isArray(match.roles) && match.roles.length) {
            if (!match.roles.includes(role)) return false;
        }
        return true;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET DATAMAP
    // ═══════════════════════════════════════════════════════════════════════

    function setDatamap(prefix) {
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const nextSet = new Set(ACTIVE_DATAMAPS);
        if (!prefix) {
            nextSet.clear();
        } else if (nextSet.has(prefix)) {
            nextSet.delete(prefix);
        } else {
            nextSet.add(prefix);
        }

        if (!window.DM) {
            window.ACTIVE_DATAMAPS = nextSet;
            updateDatamapControls();
            return;
        }

        const subset = window.filterGraph(null, window.CURRENT_DENSITY, nextSet, window.VIS_FILTERS);
        if (!subset.nodes.length) {
            window.showToast('No nodes for that datamap selection.');
            updateDatamapControls();
            return;
        }

        window.ACTIVE_DATAMAPS = nextSet;
        updateDatamapControls();
        window.refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET NODE COLOR MODE
    // ═══════════════════════════════════════════════════════════════════════

    function setNodeColorMode(mode) {
        window.NODE_COLOR_MODE = mode;
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
        window.refreshGraph();
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY DATAMAP (ALIAS)
    // ═══════════════════════════════════════════════════════════════════════

    function applyDatamap(prefix) {
        setDatamap(prefix);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE DATAMAP CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function updateDatamapControls() {
        const DM = window.DM;
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const DATAMAP_UI = window.DATAMAP_UI;
        const DATAMAP_CONFIGS = window.DATAMAP_CONFIGS;
        const GRAPH_MODE = window.GRAPH_MODE;
        const VIS_FILTERS = window.VIS_FILTERS;

        if (!DM) return;
        const datamapEnabled = GRAPH_MODE === 'atoms';
        const base = window.filterGraph(null, window.CURRENT_DENSITY, new Set(), VIS_FILTERS);
        const nodes = base.nodes || [];
        const totalCount = nodes.length;

        const allUI = DATAMAP_UI.get('__ALL__');
        if (allUI) {
            allUI.input.checked = ACTIVE_DATAMAPS.size === 0;
            if (allUI.count) {
                allUI.count.textContent = datamapEnabled ? String(totalCount) : '--';
            }
            allUI.input.disabled = !datamapEnabled;
            allUI.wrapper.classList.toggle('disabled', !datamapEnabled);
            allUI.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.size === 0);
        }

        DATAMAP_CONFIGS.forEach((config) => {
            const count = nodes.reduce((acc, node) => acc + (datamapMatches(node, config) ? 1 : 0), 0);
            const ui = DATAMAP_UI.get(config.id);
            if (!ui) return;
            if (ui.count) {
                ui.count.textContent = datamapEnabled ? String(count) : '--';
            }
            ui.input.disabled = !datamapEnabled || count === 0;
            ui.wrapper.classList.toggle('disabled', !datamapEnabled || count === 0);
            ui.input.checked = ACTIVE_DATAMAPS.has(config.id);
            ui.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.has(config.id));
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        normalizeConfig: normalizeDatamapConfig,
        resolveConfigs: resolveDatamapConfigs,
        matches: datamapMatches,
        set: setDatamap,
        setColorMode: setNodeColorMode,
        apply: applyDatamap,
        updateControls: updateDatamapControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.normalizeDatamapConfig = DATAMAP.normalizeConfig;
window.resolveDatamapConfigs = DATAMAP.resolveConfigs;
window.datamapMatches = DATAMAP.matches;
window.setDatamap = DATAMAP.set;
window.setNodeColorMode = DATAMAP.setColorMode;
window.applyDatamap = DATAMAP.apply;
window.updateDatamapControls = DATAMAP.updateControls;

console.log('[Module] DATAMAP loaded - 7 functions');


// ═══ MODULE: modules/groups.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * GROUPS MODULE - Node grouping functionality
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Group creation, storage, rendering, and management.
 * Depends on: GROUPS, ACTIVE_GROUP_ID, SELECTED_NODE_IDS, GROUPS_STORAGE_KEY
 *
 * @module GROUPS_MODULE
 * @version 1.0.0
 */

window.GROUPS_MODULE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    function loadGroups() {
        window.GROUPS = [];
        try {
            const stored = localStorage.getItem(window.GROUPS_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    window.GROUPS = parsed;
                }
            }
        } catch (e) {
            // localStorage unavailable
        }
        window.GROUPS = window.GROUPS.filter(group => group && group.id && Array.isArray(group.node_ids));
        window.GROUPS.forEach(group => {
            if (group.visible === undefined) group.visible = true;
        });
    }

    function saveGroups() {
        try {
            localStorage.setItem(window.GROUPS_STORAGE_KEY, JSON.stringify(window.GROUPS));
        } catch (e) {
            // localStorage unavailable
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNextGroupColor() {
        const hue = (window.GROUPS.length * 137.5) % 360;
        return window.hslColor(hue, 65, 55);
    }

    function getGroupById(groupId) {
        return window.GROUPS.find(group => group.id === groupId) || null;
    }

    function getPrimaryGroupForNode(nodeId) {
        const visibleGroups = window.GROUPS.filter(group =>
            group.visible !== false && Array.isArray(group.node_ids) && group.node_ids.includes(nodeId)
        );
        if (!visibleGroups.length) return null;
        if (window.ACTIVE_GROUP_ID) {
            const active = visibleGroups.find(group => group.id === window.ACTIVE_GROUP_ID);
            if (active) return active;
        }
        return visibleGroups[0];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP LIST RENDERING
    // ═══════════════════════════════════════════════════════════════════════

    function renderGroupList() {
        const container = document.getElementById('group-list');
        if (!container) return;
        container.innerHTML = '';

        if (!window.GROUPS.length) {
            const empty = document.createElement('div');
            empty.style.fontSize = '9px';
            empty.style.color = 'rgba(255,255,255,0.4)';
            empty.textContent = 'No groups yet';
            container.appendChild(empty);
            return;
        }

        window.GROUPS.forEach(group => {
            const row = document.createElement('div');
            row.className = 'group-item';
            row.classList.toggle('active', group.id === window.ACTIVE_GROUP_ID);

            const dot = document.createElement('span');
            dot.className = 'group-color';
            dot.style.background = group.color || '#6fe8ff';

            const name = document.createElement('span');
            name.className = 'group-name';
            name.textContent = group.name || 'Group';

            const count = document.createElement('span');
            count.className = 'group-count';
            count.textContent = String((group.node_ids || []).length);

            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.className = 'group-toggle';
            toggle.checked = group.visible !== false;
            toggle.onchange = (e) => {
                e.stopPropagation();
                group.visible = toggle.checked;
                saveGroups();
                window.updateSelectionVisuals();
                renderGroupList();
            };

            row.onclick = (e) => {
                if (e.target === toggle) return;
                window.ACTIVE_GROUP_ID = group.id;
                renderGroupList();
                window.setSelection(group.node_ids || []);
                window.updateSelectionVisuals();
            };

            row.appendChild(dot);
            row.appendChild(name);
            row.appendChild(count);
            row.appendChild(toggle);
            container.appendChild(row);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP BUTTON STATE
    // ═══════════════════════════════════════════════════════════════════════

    function updateGroupButtonState() {
        const btn = document.getElementById('btn-create-group');
        if (!btn) return;
        const hasSelection = window.SELECTED_NODE_IDS.size > 0;
        btn.classList.toggle('disabled', !hasSelection);
        btn.disabled = !hasSelection;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CREATE GROUP FROM SELECTION
    // ═══════════════════════════════════════════════════════════════════════

    function createGroupFromSelection() {
        if (window.SELECTED_NODE_IDS.size === 0) return;
        const nodeIds = Array.from(window.SELECTED_NODE_IDS);
        const groupId = `group_${Date.now().toString(36)}`;
        const groupName = `Group ${window.GROUPS.length + 1}`;
        const groupColor = getNextGroupColor();
        window.GROUPS.push({
            id: groupId,
            name: groupName,
            color: groupColor,
            node_ids: nodeIds,
            visible: true
        });
        window.ACTIVE_GROUP_ID = groupId;
        saveGroups();
        renderGroupList();
        window.updateSelectionVisuals();
        window.showToast(`Created ${groupName} (${nodeIds.length})`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        load: loadGroups,
        save: saveGroups,
        getNextColor: getNextGroupColor,
        getById: getGroupById,
        getPrimaryForNode: getPrimaryGroupForNode,
        renderList: renderGroupList,
        updateButtonState: updateGroupButtonState,
        createFromSelection: createGroupFromSelection
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.loadGroups = GROUPS_MODULE.load;
window.saveGroups = GROUPS_MODULE.save;
window.getNextGroupColor = GROUPS_MODULE.getNextColor;
window.getGroupById = GROUPS_MODULE.getById;
window.getPrimaryGroupForNode = GROUPS_MODULE.getPrimaryForNode;
window.renderGroupList = GROUPS_MODULE.renderList;
window.updateGroupButtonState = GROUPS_MODULE.updateButtonState;
window.createGroupFromSelection = GROUPS_MODULE.createFromSelection;

console.log('[Module] GROUPS_MODULE loaded - 8 functions');


// ═══ MODULE: modules/hover.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HOVER MODULE - Node hover and click interactions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node hover panel updates, click handling, and interaction management.
 * Depends on: HOVERED_NODE, VIS_FILTERS, GRAPH_MODE, DM, Graph
 *
 * @module HOVER
 * @version 1.0.0
 */

window.HOVER = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE HOVER PANEL
    // ═══════════════════════════════════════════════════════════════════════

    function updateHoverPanel(node) {
        const hoverPanel = document.getElementById('hover-panel');
        const placeholder = document.getElementById('hover-placeholder');
        if (!hoverPanel) return;

        if (!node) {
            hoverPanel.classList.remove('has-node');
            if (placeholder) placeholder.style.display = '';
            return;
        }

        hoverPanel.classList.add('has-node');
        if (placeholder) placeholder.style.display = 'none';

        // Helper to set element text safely
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val ?? '--';
        };

        // Basic info
        setEl('hover-name', node.label || node.id || 'Unknown');
        setEl('hover-type', node.type || node.kind || '--');
        setEl('hover-file', node.file_path || '--');

        // Tier/Ring/Family
        setEl('hover-tier', window.getNodeTier ? window.getNodeTier(node) : (node.tier || '--'));
        setEl('hover-ring', window.getNodeRing ? window.getNodeRing(node) : (node.ring || '--'));
        setEl('hover-family', window.getNodeAtomFamily ? window.getNodeAtomFamily(node) : (node.atom_family || '--'));

        // Metrics
        setEl('hover-complexity', node.complexity ?? '--');
        setEl('hover-loc', node.lines_of_code ?? node.loc ?? '--');
        setEl('hover-fanin', node.in_degree ?? '--');
        setEl('hover-fanout', node.out_degree ?? '--');

        // Role
        setEl('hover-role', node.role || '--');

        // Code preview (if available)
        const codeEl = document.getElementById('hover-code');
        if (codeEl) {
            const code = node.body_source || node.body || '';
            codeEl.textContent = code ? code.substring(0, 500) : '// no source';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE HOVER
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeHover(node, data) {
        const filePanel = document.getElementById('file-panel');
        window.HOVERED_NODE = node || null;

        // Always update hover panel
        updateHoverPanel(node);

        // Guard: file-panel may not exist
        if (!filePanel) return;

        const VIS_FILTERS = window.VIS_FILTERS;
        if (!VIS_FILTERS.metadata.showFilePanel) {
            filePanel.classList.remove('visible');
            return;
        }

        if (!node) {
            setTimeout(() => {
                if (!window.fileMode) filePanel.classList.remove('visible');
            }, 300);
            return;
        }

        // Get file info from boundaries
        const boundaries = data.file_boundaries || [];
        const fileIdx = node.fileIdx;

        if (fileIdx < 0 || fileIdx >= boundaries.length) {
            return;
        }

        const fileInfo = boundaries[fileIdx];

        // Update panel content
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        };
        setEl('file-name', fileInfo.file_name || 'unknown');
        setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
        setEl('file-purpose', fileInfo.purpose || '--');
        setEl('file-atom-count', fileInfo.atom_count || 0);
        setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
        setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
        setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

        // Code preview from node body
        const code = node.body || '// no source available';
        setEl('file-code', code);

        // Show panel
        filePanel.classList.add('visible');
        if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE CLICK
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeClick(node, event) {
        if (!node) return;
        const additive = event && event.shiftKey;
        if (additive) {
            window.toggleSelection(node);
            return;
        }
        if (node.id) {
            window.setSelection([node.id]);
        }
        const GRAPH_MODE = window.GRAPH_MODE;
        if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
            window.toggleFileExpand(node.fileIdx);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updatePanel: updateHoverPanel,
        onNodeHover: handleNodeHover,
        onNodeClick: handleNodeClick
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateHoverPanel = HOVER.updatePanel;
window.handleNodeHover = HOVER.onNodeHover;
window.handleNodeClick = HOVER.onNodeClick;

console.log('[Module] HOVER loaded - 3 functions');


// ═══ MODULE: modules/flow.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * FLOW MODULE - Flow visualization mode with presets
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Flow mode highlights high-entropy nodes and edge transition probabilities.
 * Cycles through visual presets (EMBER, OCEAN, PLASMA, MATRIX, PULSE, AURORA).
 * Depends on: Graph, DM, THEME_CONFIG, APPEARANCE_CONFIG, FLOW_CONFIG
 *
 * @module FLOW
 * @version 1.0.0
 */

window.FLOW = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // PRESET COLOR/VALUE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getFlowPresetColor(presetName, property, fallback) {
        const schemes = (window.THEME_CONFIG && window.THEME_CONFIG.colors && window.THEME_CONFIG.colors.schemes) || {};
        const scheme = schemes[presetName.toLowerCase()] || {};
        return scheme[property] || fallback;
    }

    function getFlowPresetValue(presetName, property, fallback) {
        const presets = (typeof window.APPEARANCE_CONFIG !== 'undefined' && window.APPEARANCE_CONFIG && window.APPEARANCE_CONFIG['flow-presets']) || {};
        const preset = presets[presetName.toLowerCase()] || {};
        const value = preset[property];
        return (value !== undefined && value !== null) ? value : fallback;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FLOW PRESETS
    // ═══════════════════════════════════════════════════════════════════════

    const PRESETS = [
        {
            name: 'EMBER',
            highlightColor: getFlowPresetColor('EMBER', 'highlightColor', getFlowPresetValue('ember', 'highlightColor', '#ff8c00')),
            particleColor: getFlowPresetColor('EMBER', 'particleColor', getFlowPresetValue('ember', 'particleColor', '#ffaa00')),
            dimColor: getFlowPresetColor('EMBER', 'dimColor', getFlowPresetValue('ember', 'dimColor', '#331100')),
            edgeColor: getFlowPresetColor('EMBER', 'edgeColor', getFlowPresetValue('ember', 'edgeColor', '#ff6600')),
            particleCount: getFlowPresetValue('ember', 'particleCount', 3),
            particleWidth: getFlowPresetValue('ember', 'particleWidth', 2.5),
            particleSpeed: getFlowPresetValue('ember', 'particleSpeed', 0.008),
            edgeWidthScale: getFlowPresetValue('ember', 'edgeWidthScale', 3.0),
            sizeMultiplier: getFlowPresetValue('ember', 'sizeMultiplier', 1.8),
            edgeOpacityMin: getFlowPresetValue('ember', 'edgeOpacityMin', 0.3),
            dimOpacity: getFlowPresetValue('ember', 'dimOpacity', 0.05)
        },
        {
            name: 'OCEAN',
            highlightColor: getFlowPresetColor('OCEAN', 'highlightColor', getFlowPresetValue('ocean', 'highlightColor', '#00d4ff')),
            particleColor: getFlowPresetColor('OCEAN', 'particleColor', getFlowPresetValue('ocean', 'particleColor', '#4df0ff')),
            dimColor: getFlowPresetColor('OCEAN', 'dimColor', getFlowPresetValue('ocean', 'dimColor', '#001122')),
            edgeColor: getFlowPresetColor('OCEAN', 'edgeColor', getFlowPresetValue('ocean', 'edgeColor', '#0088cc')),
            particleCount: getFlowPresetValue('ocean', 'particleCount', 4),
            particleWidth: getFlowPresetValue('ocean', 'particleWidth', 2.0),
            particleSpeed: getFlowPresetValue('ocean', 'particleSpeed', 0.006),
            edgeWidthScale: getFlowPresetValue('ocean', 'edgeWidthScale', 2.5),
            sizeMultiplier: getFlowPresetValue('ocean', 'sizeMultiplier', 1.6),
            edgeOpacityMin: getFlowPresetValue('ocean', 'edgeOpacityMin', 0.25),
            dimOpacity: getFlowPresetValue('ocean', 'dimOpacity', 0.03)
        },
        {
            name: 'PLASMA',
            highlightColor: getFlowPresetColor('PLASMA', 'highlightColor', getFlowPresetValue('plasma', 'highlightColor', '#ff00ff')),
            particleColor: getFlowPresetColor('PLASMA', 'particleColor', getFlowPresetValue('plasma', 'particleColor', '#ff66ff')),
            dimColor: getFlowPresetColor('PLASMA', 'dimColor', getFlowPresetValue('plasma', 'dimColor', '#110011')),
            edgeColor: getFlowPresetColor('PLASMA', 'edgeColor', getFlowPresetValue('plasma', 'edgeColor', '#cc00cc')),
            particleCount: getFlowPresetValue('plasma', 'particleCount', 5),
            particleWidth: getFlowPresetValue('plasma', 'particleWidth', 3.0),
            particleSpeed: getFlowPresetValue('plasma', 'particleSpeed', 0.012),
            edgeWidthScale: getFlowPresetValue('plasma', 'edgeWidthScale', 4.0),
            sizeMultiplier: getFlowPresetValue('plasma', 'sizeMultiplier', 2.0),
            edgeOpacityMin: getFlowPresetValue('plasma', 'edgeOpacityMin', 0.35),
            dimOpacity: getFlowPresetValue('plasma', 'dimOpacity', 0.04)
        },
        {
            name: 'MATRIX',
            highlightColor: getFlowPresetColor('MATRIX', 'highlightColor', getFlowPresetValue('matrix', 'highlightColor', '#00ff00')),
            particleColor: getFlowPresetColor('MATRIX', 'particleColor', getFlowPresetValue('matrix', 'particleColor', '#88ff88')),
            dimColor: getFlowPresetColor('MATRIX', 'dimColor', getFlowPresetValue('matrix', 'dimColor', '#001100')),
            edgeColor: getFlowPresetColor('MATRIX', 'edgeColor', getFlowPresetValue('matrix', 'edgeColor', '#00cc00')),
            particleCount: getFlowPresetValue('matrix', 'particleCount', 6),
            particleWidth: getFlowPresetValue('matrix', 'particleWidth', 1.5),
            particleSpeed: getFlowPresetValue('matrix', 'particleSpeed', 0.015),
            edgeWidthScale: getFlowPresetValue('matrix', 'edgeWidthScale', 2.0),
            sizeMultiplier: getFlowPresetValue('matrix', 'sizeMultiplier', 1.4),
            edgeOpacityMin: getFlowPresetValue('matrix', 'edgeOpacityMin', 0.2),
            dimOpacity: getFlowPresetValue('matrix', 'dimOpacity', 0.02)
        },
        {
            name: 'PULSE',
            highlightColor: getFlowPresetColor('PULSE', 'highlightColor', getFlowPresetValue('pulse', 'highlightColor', '#ff4444')),
            particleColor: getFlowPresetColor('PULSE', 'particleColor', getFlowPresetValue('pulse', 'particleColor', '#ff8888')),
            dimColor: getFlowPresetColor('PULSE', 'dimColor', getFlowPresetValue('pulse', 'dimColor', '#110000')),
            edgeColor: getFlowPresetColor('PULSE', 'edgeColor', getFlowPresetValue('pulse', 'edgeColor', '#cc2222')),
            particleCount: getFlowPresetValue('pulse', 'particleCount', 2),
            particleWidth: getFlowPresetValue('pulse', 'particleWidth', 4.0),
            particleSpeed: getFlowPresetValue('pulse', 'particleSpeed', 0.004),
            edgeWidthScale: getFlowPresetValue('pulse', 'edgeWidthScale', 5.0),
            sizeMultiplier: getFlowPresetValue('pulse', 'sizeMultiplier', 2.2),
            edgeOpacityMin: getFlowPresetValue('pulse', 'edgeOpacityMin', 0.4),
            dimOpacity: getFlowPresetValue('pulse', 'dimOpacity', 0.06)
        },
        {
            name: 'AURORA',
            highlightColor: getFlowPresetColor('AURORA', 'highlightColor', getFlowPresetValue('aurora', 'highlightColor', '#33ccbb')),
            particleColor: getFlowPresetColor('AURORA', 'particleColor', getFlowPresetValue('aurora', 'particleColor', '#66ffee')),
            dimColor: getFlowPresetColor('AURORA', 'dimColor', getFlowPresetValue('aurora', 'dimColor', '#002222')),
            edgeColor: getFlowPresetColor('AURORA', 'edgeColor', getFlowPresetValue('aurora', 'edgeColor', '#22aa99')),
            particleCount: getFlowPresetValue('aurora', 'particleCount', 4),
            particleWidth: getFlowPresetValue('aurora', 'particleWidth', 2.2),
            particleSpeed: getFlowPresetValue('aurora', 'particleSpeed', 0.007),
            edgeWidthScale: getFlowPresetValue('aurora', 'edgeWidthScale', 3.5),
            sizeMultiplier: getFlowPresetValue('aurora', 'sizeMultiplier', 1.7),
            edgeOpacityMin: getFlowPresetValue('aurora', 'edgeOpacityMin', 0.28),
            dimOpacity: getFlowPresetValue('aurora', 'dimOpacity', 0.04)
        }
    ];

    let currentPresetIndex = 0;

    // ═══════════════════════════════════════════════════════════════════════
    // TOGGLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function toggle() {
        const flowMode = window.flowMode;

        // If already in flow mode, cycle to next preset
        if (flowMode) {
            currentPresetIndex = (currentPresetIndex + 1) % PRESETS.length;
            const preset = PRESETS[currentPresetIndex];
            console.log(`[Flow] Cycling to preset: ${preset.name}`);
            applyVisualization();
            window.showModeToast(`FLOW: ${preset.name}`);
            return;
        }

        window.flowMode = true;
        currentPresetIndex = 0;
        console.log('[Flow] Toggled to:', window.flowMode);

        // Sync BOTH potential buttons (Dock vs CommandBar)
        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.toggle('active', window.flowMode);

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.toggle('active', window.flowMode);

        // Show/hide flow legend
        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.toggle('visible', window.flowMode);

        // EXCLUSIVE MODE: Clear other visual noise
        if (typeof window.clearAllFileModes === 'function') {
            window.clearAllFileModes();
        }
        // Ensure standard file/hull buttons are off
        document.querySelectorAll('.file-mode-btn').forEach(b => b.classList.remove('active'));

        applyVisualization();
        const preset = PRESETS[currentPresetIndex];
        window.showModeToast(`FLOW: ${preset.name}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DISABLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function disable() {
        if (!window.flowMode) return;
        window.flowMode = false;
        currentPresetIndex = 0;

        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.remove('active');

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.remove('active');

        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.remove('visible');

        clearVisualization();
        window.showModeToast('Flow mode off');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyVisualization() {
        const Graph = window.Graph;
        const DM = window.DM;

        // Guard: Ensure Graph is ready
        if (!Graph || !DM) {
            console.warn('[Flow] Graph or DM not ready');
            return;
        }

        // Get current preset settings
        const preset = PRESETS[currentPresetIndex];
        const markov = DM.getMarkov ? DM.getMarkov() : {};
        const highEntropy = markov.high_entropy_nodes || [];

        // Use preset values (fallback to FLOW_CONFIG for topK/minWeight if not in preset)
        const flowCfg = window.FLOW_CONFIG || {};
        const highlightColor = preset.highlightColor;
        const particleColor = preset.particleColor;
        const sizeMult = preset.sizeMultiplier;
        const edgeScale = preset.edgeWidthScale;
        const particleCount = preset.particleCount;
        const particleWidth = preset.particleWidth;
        const particleSpeed = preset.particleSpeed;
        const edgeOpacityMin = preset.edgeOpacityMin;
        const dimOpacity = preset.dimOpacity;
        const topK = flowCfg.topKEdges || 3;
        const minWeight = flowCfg.minWeight || 0.01;

        // Build set of high entropy node names
        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();
        highEntropy.forEach(n => highEntropyNodes.add(n.node));
        window.highEntropyNodes = highEntropyNodes;

        const graphNodes = Graph.graphData().nodes;
        const graphLinks = Graph.graphData().links;

        // THRESHOLDING: Build a map of top-K outgoing edges per source node
        const edgesBySource = new Map();
        graphLinks.forEach(link => {
            const srcId = typeof link.source === 'object' ? link.source.id : link.source;
            if (!edgesBySource.has(srcId)) {
                edgesBySource.set(srcId, []);
            }
            edgesBySource.get(srcId).push(link);
        });

        // For each source, keep only top-K by markov_weight (transition probability)
        const visibleEdges = new Set();
        edgesBySource.forEach((edges, srcId) => {
            const sorted = edges
                .filter(e => (e.markov_weight || 0) >= minWeight)
                .sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0))
                .slice(0, topK);
            sorted.forEach(e => visibleEdges.add(e));
        });

        // Store original colors and sizes, then apply flow coloring
        const originalNodeColors = window.originalNodeColors || new Map();
        window.originalNodeColors = originalNodeColors;

        graphNodes.forEach(node => {
            if (!originalNodeColors.has(node.id)) {
                originalNodeColors.set(node.id, node.color);
            }
            // Restore original size first (in case switching presets)
            if (node._originalVal) {
                node.val = node._originalVal;
            } else {
                node._originalVal = node.val || 1;
            }
            // High entropy nodes highlighted (decision points)
            if (highEntropyNodes.has(node.name)) {
                node.color = highlightColor;
                node.val = node._originalVal * sizeMult;
            }
        });

        // Update link widths based on markov_weight (with amplification)
        const maxMarkov = Math.max(0.001, ...graphLinks.map(l => l.markov_weight || 0));
        const amplify = window.amplify || (x => x);

        Graph.linkWidth(link => {
            if (!visibleEdges.has(link)) return 0.1;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return 0.5 + amplified * edgeScale * 2;
        });

        // Update link opacity to emphasize important edges
        Graph.linkOpacity(link => {
            if (!visibleEdges.has(link)) return dimOpacity;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return edgeOpacityMin + amplified * (1.0 - edgeOpacityMin);
        });

        // Add directional particles only on visible edges
        Graph.linkDirectionalParticles(link => {
            if (!visibleEdges.has(link)) return 0;
            return particleCount;
        });
        Graph.linkDirectionalParticleWidth(particleWidth);
        Graph.linkDirectionalParticleSpeed(particleSpeed);
        Graph.linkDirectionalParticleColor(() => particleColor);

        // Update node coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }

        // Debug: count edges with markov weights
        const edgesWithMarkov = graphLinks.filter(l => l.markov_weight > 0).length;
        console.log(`[Flow] Preset: ${preset.name} | ${highEntropyNodes.size} high entropy nodes, ${visibleEdges.size} visible edges (top-${topK}), ${edgesWithMarkov}/${graphLinks.length} edges with markov`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CLEAR FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function clearVisualization() {
        const Graph = window.Graph;

        // Guard: Ensure Graph is ready
        if (!Graph) return;

        const graphNodes = Graph.graphData().nodes;
        const originalNodeColors = window.originalNodeColors || new Map();

        // Restore original node colors and sizes
        graphNodes.forEach(node => {
            if (originalNodeColors.has(node.id)) {
                node.color = originalNodeColors.get(node.id);
            }
            // Restore original size from saved value
            if (node._originalVal) {
                node.val = node._originalVal;
                delete node._originalVal;
            }
        });

        // Reset link widths
        Graph.linkWidth(1);

        // Reset link opacity
        Graph.linkOpacity(0.6);

        // Remove directional particles
        Graph.linkDirectionalParticles(0);

        // Update coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getPresetColor: getFlowPresetColor,
        getPresetValue: getFlowPresetValue,
        toggle: toggle,
        disable: disable,
        apply: applyVisualization,
        clear: clearVisualization,
        PRESETS: PRESETS,
        getCurrentPreset: () => PRESETS[currentPresetIndex],
        getCurrentPresetIndex: () => currentPresetIndex
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getFlowPresetColor = FLOW.getPresetColor;
window.getFlowPresetValue = FLOW.getPresetValue;
window.toggleFlowMode = FLOW.toggle;
window.disableFlowMode = FLOW.disable;
window.applyFlowVisualization = FLOW.apply;
window.clearFlowVisualization = FLOW.clear;
window.FLOW_PRESETS = FLOW.PRESETS;

console.log('[Module] FLOW loaded - 6 functions');


// ═══ MODULE: modules/ui-builders.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UI-BUILDERS MODULE - DOM element construction utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Factory functions for building common UI elements: checkboxes, toggles,
 * filter groups, and option selectors.
 *
 * @module UI_BUILDERS
 * @version 1.0.0
 */

window.UI_BUILDERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // COUNT COLLECTION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Collect counts by key from items
     * @param {Array} items - Items to count
     * @param {Function} keyFn - Function to extract key from item
     * @returns {Array} Array of [key, count] pairs sorted by count desc
     */
    function collectCounts(items, keyFn) {
        const counts = new Map();
        items.forEach(item => {
            const key = keyFn(item);
            if (!key) return;
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHECKBOX ROW
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a checkbox row element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Element ID
     * @param {string} label - Display label
     * @param {number|null} count - Optional count to display
     * @param {boolean} checked - Initial checked state
     * @param {Function} onChange - Callback when checkbox changes
     * @returns {HTMLInputElement} The checkbox input element
     */
    function buildCheckboxRow(container, id, label, count, checked, onChange) {
        const row = document.createElement('div');
        row.className = 'filter-item';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = id;
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('label');
        text.setAttribute('for', id);
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'filter-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        row.appendChild(input);
        row.appendChild(text);
        if (countEl.textContent) {
            row.appendChild(countEl);
        }
        container.appendChild(row);

        return input;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER GROUP
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a filter group with ALL checkbox and individual items
     * @param {string} containerId - Container element ID
     * @param {Array} items - Array of [value, count] pairs
     * @param {Set} stateSet - Set to track selected values
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildFilterGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const allId = `${containerId}-all`;
        let allCheckbox = null;

        allCheckbox = buildCheckboxRow(container, allId, 'ALL', null, true, (checked) => {
            stateSet.clear();
            if (checked) {
                items.forEach(([value]) => stateSet.add(value));
            }
            container.querySelectorAll('input[type="checkbox"]').forEach(box => {
                if (box.id !== allId) box.checked = checked;
            });
            onUpdate();
        });

        items.forEach(([value, count], index) => {
            const id = `${containerId}-${index}`;
            const checked = stateSet.has(value);
            buildCheckboxRow(container, id, value, count, checked, (isChecked) => {
                if (isChecked) {
                    stateSet.add(value);
                } else {
                    stateSet.delete(value);
                }
                const allChecked = items.every(([v]) => stateSet.has(v));
                allCheckbox.checked = allChecked;
                onUpdate();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a datamap toggle element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Toggle ID
     * @param {string} label - Display label
     * @param {boolean} checked - Initial checked state
     * @param {number|null} count - Optional count to display
     * @param {Function} onChange - Callback when toggle changes
     * @returns {Object} Object with wrapper, input, and count elements
     */
    function buildDatamapToggle(container, id, label, checked, count, onChange) {
        const wrapper = document.createElement('label');
        wrapper.className = 'datamap-toggle';
        wrapper.setAttribute('data-id', id);

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('span');
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'datamap-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        wrapper.appendChild(input);
        wrapper.appendChild(text);
        wrapper.appendChild(countEl);
        container.appendChild(wrapper);

        return { wrapper, input, count: countEl };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // EXCLUSIVE OPTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build exclusive (radio-like) options using checkboxes
     * @param {string} containerId - Container element ID
     * @param {Array} options - Array of {label, value} objects
     * @param {*} activeValue - Currently active value
     * @param {Function} onSelect - Callback when option is selected
     */
    function buildExclusiveOptions(containerId, options, activeValue, onSelect) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const inputs = [];
        options.forEach((option, index) => {
            const id = `${containerId}-${index}`;
            const input = buildCheckboxRow(
                container,
                id,
                option.label,
                null,
                option.value === activeValue,
                (checked) => {
                    if (!checked) {
                        input.checked = true;
                        return;
                    }
                    inputs.forEach(other => {
                        if (other !== input) other.checked = false;
                    });
                    onSelect(option.value);
                }
            );
            inputs.push(input);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHIP GROUP BUILDER - Filter chips with ALL toggle
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build chip buttons for filter groups
     * @param {string} containerId - Container element ID
     * @param {Map} items - Map of key -> count
     * @param {Set} stateSet - Set tracking selected items
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildChipGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        // "ALL" chip
        const allChip = document.createElement('button');
        allChip.className = 'chip active';
        allChip.textContent = 'ALL';
        allChip.addEventListener('click', () => {
            // Toggle all on/off
            const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
            if (allActive) {
                stateSet.clear();
                container.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
            } else {
                items.forEach((count, key) => stateSet.add(key));
                container.querySelectorAll('.chip').forEach(c => c.classList.add('active'));
            }
            if (onUpdate) onUpdate();
        });
        container.appendChild(allChip);

        // Individual chips
        items.forEach((count, key) => {
            const chip = document.createElement('button');
            chip.className = 'chip' + (stateSet.has(key) ? ' active' : '');
            chip.innerHTML = `${key}<span class="chip-count">${count}</span>`;
            chip.addEventListener('click', () => {
                if (stateSet.has(key)) {
                    stateSet.delete(key);
                    chip.classList.remove('active');
                } else {
                    stateSet.add(key);
                    chip.classList.add('active');
                }
                // Update "ALL" chip state
                const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
                allChip.classList.toggle('active', allActive);
                if (onUpdate) onUpdate();
            });
            container.appendChild(chip);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA CONTROLS - Visibility toggles
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build metadata visibility controls
     * @param {string} containerId - Container element ID
     * @param {Object} metadata - Metadata state object with boolean flags
     */
    function buildMetadataControls(containerId, metadata) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const toggles = [
            { id: 'meta-labels', label: 'LABELS', key: 'showLabels' },
            { id: 'meta-file-panel', label: 'FILE PANEL', key: 'showFilePanel' },
            { id: 'meta-report', label: 'REPORT', key: 'showReportPanel' },
            { id: 'meta-edges', label: 'EDGES', key: 'showEdges' }
        ];

        toggles.forEach((toggle) => {
            buildCheckboxRow(container, toggle.id, toggle.label, null, metadata[toggle.key], (checked) => {
                metadata[toggle.key] = checked;
                if (typeof applyMetadataVisibility === 'function') applyMetadataVisibility();
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPEARANCE SLIDERS - Pure UI builder (decoupled from global state)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build appearance sliders - PURE UI, no global dependencies
     *
     * @param {string} containerId - Container element ID
     * @param {Array} sliderDefs - Array of slider definitions:
     *   { id, label, min, max, step, value, onChange?, description?, className? }
     * @param {Function} globalOnChange - Optional global callback: (sliderId, newValue) => void
     *
     * Supports two patterns:
     * 1. Individual: Each sliderDef has its own onChange(value) handler
     * 2. Global: A single globalOnChange(sliderId, value) handles all
     */
    function buildAppearanceSliders(containerId, sliderDefs, globalOnChange) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row' + (def.className ? ' ' + def.className : '');

            // Header row with label and value
            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            const safeValue = def.value ?? def.min ?? 0;
            valueDisplay.textContent = safeValue.toFixed(def.step < 1 ? 2 : 0);
            header.appendChild(label);
            header.appendChild(valueDisplay);

            // The slider input
            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = safeValue;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = val.toFixed(def.step < 1 ? 2 : 0);
                // Support both patterns: individual onChange or global
                if (def.onChange) def.onChange(val);
                if (globalOnChange) globalOnChange(def.id, val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);

            // Optional description for meta-sliders
            if (def.description) {
                const desc = document.createElement('div');
                desc.className = 'slider-desc';
                desc.textContent = def.description;
                wrapper.appendChild(desc);
            }

            container.appendChild(wrapper);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        collectCounts: collectCounts,
        buildCheckboxRow: buildCheckboxRow,
        buildFilterGroup: buildFilterGroup,
        buildDatamapToggle: buildDatamapToggle,
        buildExclusiveOptions: buildExclusiveOptions,
        buildChipGroup: buildChipGroup,
        buildMetadataControls: buildMetadataControls,
        buildAppearanceSliders: buildAppearanceSliders
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.collectCounts = UI_BUILDERS.collectCounts;
window.buildCheckboxRow = UI_BUILDERS.buildCheckboxRow;
window.buildFilterGroup = UI_BUILDERS.buildFilterGroup;
window.buildDatamapToggle = UI_BUILDERS.buildDatamapToggle;
window.buildExclusiveOptions = UI_BUILDERS.buildExclusiveOptions;
window.buildChipGroup = UI_BUILDERS.buildChipGroup;
window.buildMetadataControls = UI_BUILDERS.buildMetadataControls;
// Note: buildAppearanceSliders shim is in app.js (orchestration layer)

console.log('[Module] UI_BUILDERS loaded - 8 functions (appearance sliders decoupled)');


// ═══ MODULE: modules/layout-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT-HELPERS MODULE - Layout stability and position utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Functions for saving/restoring node positions, freezing/unfreezing layout,
 * and calculating file positions.
 * Depends on: Graph, NODE_POSITION_CACHE, LAYOUT_FROZEN, IS_3D
 *
 * @module LAYOUT_HELPERS
 * @version 1.0.0
 */

window.LAYOUT_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // POSITION PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Save current node positions to cache
     */
    function saveNodePositions() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;
        if (!Graph || !cache) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined && node.y !== undefined) {
                cache.set(node.id, {
                    x: node.x, y: node.y, z: node.z || 0,
                    vx: node.vx || 0, vy: node.vy || 0, vz: node.vz || 0,
                    fx: node.fx, fy: node.fy, fz: node.fz
                });
            }
        });
    }

    /**
     * Restore node positions from cache
     * @param {Array} nodes - Nodes to restore positions for
     */
    function restoreNodePositions(nodes) {
        const cache = window.NODE_POSITION_CACHE;
        const frozen = window.LAYOUT_FROZEN;
        if (!cache) return;

        nodes.forEach(node => {
            const cached = cache.get(node.id);
            if (cached) {
                node.x = cached.x;
                node.y = cached.y;
                node.z = cached.z;
                node.vx = cached.vx;
                node.vy = cached.vy;
                node.vz = cached.vz;
                // Pin nodes in place when layout is frozen
                if (frozen) {
                    node.fx = cached.x;
                    node.fy = cached.y;
                    node.fz = cached.z;
                }
            }
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LAYOUT FREEZE/UNFREEZE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Freeze layout by pinning all nodes in place
     */
    function freezeLayout() {
        window.LAYOUT_FROZEN = true;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined) {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            }
        });
        Graph.cooldownTicks(0);  // Stop simulation immediately
    }

    /**
     * Unfreeze layout by unpinning all nodes
     */
    function unfreezeLayout() {
        window.LAYOUT_FROZEN = false;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            node.fx = undefined;
            node.fy = undefined;
            node.fz = undefined;
        });
    }

    /**
     * Reset layout - clear cache and reheat simulation
     */
    function resetLayout() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;

        // Clear position cache
        if (cache) cache.clear();

        // Unfreeze and restart simulation
        unfreezeLayout();

        if (Graph) {
            Graph.cooldownTicks(200);  // Allow simulation to run
            Graph.d3ReheatSimulation();
        }

        if (typeof window.showModeToast === 'function') {
            window.showModeToast('Layout reset - physics running');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LINK/FILE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get the ID of a link endpoint (source or target)
     * @param {Object} link - The link object
     * @param {string} side - 'source' or 'target'
     * @returns {string|undefined} The endpoint ID
     */
    function getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.id || endpoint;
        }
        return endpoint;
    }

    /**
     * Calculate target position for a file node in radial layout
     * @param {number} fileIdx - Index of the file
     * @param {number} totalFiles - Total number of files
     * @param {number} radius - Radius of the circle
     * @param {number} zSpacing - Z-axis spacing between files
     * @returns {Object} Position {x, y, z}
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpacing) {
        if (totalFiles <= 0) {
            return { x: 0, y: 0, z: 0 };
        }
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        const is3D = window.IS_3D;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: is3D ? (fileIdx - totalFiles / 2) * zSpacing : 0
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        savePositions: saveNodePositions,
        restorePositions: restoreNodePositions,
        freeze: freezeLayout,
        unfreeze: unfreezeLayout,
        reset: resetLayout,
        getLinkEndpointId: getLinkEndpointId,
        getFileTarget: getFileTarget
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.saveNodePositions = LAYOUT_HELPERS.savePositions;
window.restoreNodePositions = LAYOUT_HELPERS.restorePositions;
window.freezeLayout = LAYOUT_HELPERS.freeze;
window.unfreezeLayout = LAYOUT_HELPERS.unfreeze;
window.resetLayout = LAYOUT_HELPERS.reset;
window.getLinkEndpointId = LAYOUT_HELPERS.getLinkEndpointId;
window.getFileTarget = LAYOUT_HELPERS.getFileTarget;

console.log('[Module] LAYOUT_HELPERS loaded - 7 functions');


// ═══ MODULE: modules/spatial.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SPATIAL MODULE - Spatial algorithms and collision detection
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Spatial hashing for O(n) collision detection, convex hull calculation,
 * and node sampling utilities.
 * Depends on: IS_3D, FILE_CONTAINMENT, THREE
 *
 * @module SPATIAL
 * @version 1.0.0
 */

window.SPATIAL = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SAMPLING
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Sample nodes evenly if there are too many
     * @param {Array} nodes - Array of nodes
     * @param {number} maxPoints - Maximum number of points to return
     * @returns {Array} Sampled nodes
     */
    function sampleFileNodes(nodes, maxPoints) {
        if (nodes.length <= maxPoints) return nodes;
        const step = Math.ceil(nodes.length / maxPoints);
        return nodes.filter((_, idx) => idx % step === 0);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVEX HULL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build 2D convex hull using Andrew's monotone chain algorithm
     * @param {Array} points - Array of {x, y} points
     * @returns {Array|null} Hull points or null if insufficient points
     */
    function buildHull2D(points) {
        if (points.length < 3) return null;

        // Remove duplicates
        const unique = new Map();
        points.forEach(p => {
            const key = `${p.x.toFixed(4)},${p.y.toFixed(4)}`;
            if (!unique.has(key)) unique.set(key, p);
        });

        // Sort by x, then y
        const pts = Array.from(unique.values()).sort((a, b) => {
            if (a.x === b.x) return a.y - b.y;
            return a.x - b.x;
        });

        if (pts.length < 3) return null;

        // Cross product of vectors OA and OB
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

        // Build lower hull
        const lower = [];
        for (const p of pts) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                lower.pop();
            }
            lower.push(p);
        }

        // Build upper hull
        const upper = [];
        for (let i = pts.length - 1; i >= 0; i--) {
            const p = pts[i];
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                upper.pop();
            }
            upper.push(p);
        }

        // Remove last point of each half (it's the starting point of the other)
        upper.pop();
        lower.pop();

        return lower.concat(upper);
    }

    /**
     * Compute centroid of points
     * @param {Array} points - Array of THREE.Vector3-like objects
     * @returns {THREE.Vector3} Centroid
     */
    function computeCentroid(points) {
        const THREE = window.THREE;
        const centroid = new THREE.Vector3();
        points.forEach(p => centroid.add(p));
        return centroid.divideScalar(Math.max(1, points.length));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SPATIAL HASHING - O(n) collision detection
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build spatial hash grid for efficient neighbor queries
     * @param {Array} nodes - Array of nodes with x, y, z coordinates
     * @param {number} cellSize - Size of each grid cell
     * @returns {Map} Grid map with cell keys to node arrays
     */
    function buildSpatialGrid(nodes, cellSize) {
        const is3D = window.IS_3D;
        const grid = new Map();

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) grid.set(key, []);
            grid.get(key).push(node);
        });

        // Store for file containment
        if (window.FILE_CONTAINMENT) {
            window.FILE_CONTAINMENT.spatialGrid = grid;
        }

        return grid;
    }

    /**
     * Get keys for neighboring cells (3x3x3 in 3D, 3x3 in 2D)
     * @param {number} cellX - Cell X coordinate
     * @param {number} cellY - Cell Y coordinate
     * @param {number} cellZ - Cell Z coordinate
     * @returns {Array} Array of neighbor cell keys
     */
    function getNeighborCells(cellX, cellY, cellZ) {
        const is3D = window.IS_3D;
        const neighbors = [];

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = is3D ? -1 : 0; dz <= (is3D ? 1 : 0); dz++) {
                    neighbors.push(`${cellX + dx},${cellY + dy},${cellZ + dz}`);
                }
            }
        }

        return neighbors;
    }

    /**
     * Apply soft collision forces to push overlapping nodes apart
     * @param {Array} nodes - Array of nodes
     * @param {number} cellSize - Spatial grid cell size
     * @param {number} repulsionStrength - Strength of repulsion (0-1)
     */
    function applySoftCollisions(nodes, cellSize, repulsionStrength = 0.5) {
        const containment = window.FILE_CONTAINMENT;
        const is3D = window.IS_3D;

        if (!containment || !containment.collisionEnabled) return;

        const grid = buildSpatialGrid(nodes, cellSize);
        const minDist = 8;  // Minimum distance between particles
        const minDistSq = minDist * minDist;

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            if (!node.__physics) {
                node.__physics = { vx: 0, vy: 0, vz: 0 };
            }

            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const neighborKeys = getNeighborCells(cellX, cellY, cellZ);

            neighborKeys.forEach(key => {
                const cellNodes = grid.get(key);
                if (!cellNodes) return;

                cellNodes.forEach(other => {
                    if (other === node) return;

                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dz = is3D ? ((node.z || 0) - (other.z || 0)) : 0;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < minDistSq && distSq > 0.001) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        const force = (overlap / minDist) * repulsionStrength;

                        // Push apart along normal
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = is3D ? dz / dist : 0;

                        node.__physics.vx += nx * force;
                        node.__physics.vy += ny * force;
                        if (is3D) node.__physics.vz += nz * force;
                    }
                });
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        sampleFileNodes: sampleFileNodes,
        buildHull2D: buildHull2D,
        computeCentroid: computeCentroid,
        buildSpatialGrid: buildSpatialGrid,
        getNeighborCells: getNeighborCells,
        applySoftCollisions: applySoftCollisions
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.sampleFileNodes = SPATIAL.sampleFileNodes;
window.buildHull2D = SPATIAL.buildHull2D;
window.computeCentroid = SPATIAL.computeCentroid;
window.buildSpatialGrid = SPATIAL.buildSpatialGrid;
window.getNeighborCells = SPATIAL.getNeighborCells;
window.applySoftCollisions = SPATIAL.applySoftCollisions;

console.log('[Module] SPATIAL loaded - 6 functions');


// ═══ MODULE: modules/layout.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT MODULE - Unified UI Layout Engine
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * MIGRATED FROM: app.js HudLayoutManager (390 lines)
 * This is the SINGLE SOURCE OF TRUTH for UI layout intelligence.
 *
 * Features:
 *   - Panel placement with collision avoidance (from HudLayoutManager)
 *   - Component registration system (NEW)
 *   - Toast/control-bar collision detection (NEW)
 *   - Min-width graph validation (NEW)
 *   - Debug overlay with Ctrl+Shift+L (NEW)
 *
 * @module LAYOUT
 * @version 2.0.0
 * @confidence 94%
 */

window.LAYOUT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CONFIGURATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    const CONFIG = {
        MARGIN: 16,
        MIN_GRAPH_WIDTH: 320,
        REFLOW_THROTTLE_MS: 50,
        DEBUG_COLORS: {
            dock: 'rgba(100, 150, 255, 0.3)',
            overlay: 'rgba(255, 150, 100, 0.3)',
            floating: 'rgba(100, 255, 150, 0.3)',
            fixed: 'rgba(150, 150, 150, 0.3)'
        }
    };

    // Panels by priority (higher = more important, won't be moved)
    // MIGRATED from HudLayoutManager
    const FIXED_PANELS = ['top-left-header', 'stats-panel', 'metrics-panel', 'bottom-dock', 'report-panel', 'side-dock'];
    const DYNAMIC_PANELS = ['hover-panel', 'file-panel', 'selection-panel'];

    // ═══════════════════════════════════════════════════════════════════════
    // STATE
    // ═══════════════════════════════════════════════════════════════════════

    // Throttle state (from HudLayoutManager)
    let _rafPending = false;
    let _lastReflow = 0;

    // Mouse position for hover-panel placement (from HudLayoutManager)
    let _mouseX = 0;
    let _mouseY = 0;

    // Component registry (NEW)
    const _registry = new Map();

    // Debug overlay state (NEW)
    let _debugEnabled = false;
    let _debugOverlay = null;

    // ═══════════════════════════════════════════════════════════════════════
    // VIEWPORT & RECT UTILITIES (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get viewport rectangle with margins
     */
    function getViewport() {
        return {
            left: CONFIG.MARGIN,
            top: CONFIG.MARGIN,
            right: window.innerWidth - CONFIG.MARGIN,
            bottom: window.innerHeight - CONFIG.MARGIN,
            width: window.innerWidth - 2 * CONFIG.MARGIN,
            height: window.innerHeight - 2 * CONFIG.MARGIN
        };
    }

    /**
     * Check if sidebar is effectively "open" (occupying space)
     */
    function isSidebarOpen() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock) return false;
        const state = window.SIDEBAR_STATE;
        return (state && (state.locked || state.open)) ||
            sideDock.classList.contains('locked') ||
            sideDock.classList.contains('expanded') ||
            sideDock.matches(':hover');
    }

    /**
     * Get rectangle for an element (returns null if hidden/missing)
     */
    function getRect(el) {
        if (!el) return null;
        if (typeof el === 'string') {
            el = document.getElementById(el) || document.querySelector(el);
        }
        if (!el) return null;
        const style = window.getComputedStyle(el);
        if (style.display === 'none' || style.visibility === 'hidden') return null;
        const r = el.getBoundingClientRect();
        if (r.width === 0 && r.height === 0) return null;
        return { left: r.left, top: r.top, right: r.right, bottom: r.bottom, width: r.width, height: r.height };
    }

    /**
     * Get sidebar occupied region (full expanded width when open)
     */
    function getSidebarRect() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock || !isSidebarOpen()) return null;
        const sideWidth = parseInt(getComputedStyle(sideDock).getPropertyValue('--side-width')) || 260;
        return {
            left: 0,
            top: 0,
            right: 16 + sideWidth + 20,
            bottom: window.innerHeight,
            width: 16 + sideWidth + 20,
            height: window.innerHeight
        };
    }

    /**
     * Get all occupied rectangles (fixed panels + sidebar when open)
     */
    function getOccupiedRects() {
        const rects = [];

        // Sidebar takes priority when open
        const sidebarRect = getSidebarRect();
        if (sidebarRect) rects.push(sidebarRect);

        // Fixed panels
        FIXED_PANELS.forEach(id => {
            if (id === 'side-dock') return;
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (rect) rects.push(rect);
        });

        // Top-left header (special case - class-based)
        const topLeft = document.querySelector('.top-left');
        const topLeftRect = getRect(topLeft);
        if (topLeftRect) rects.push(topLeftRect);

        return rects;
    }

    /**
     * Calculate overlap area between two rectangles
     */
    function overlapArea(r1, r2) {
        if (!r1 || !r2) return 0;
        const xOverlap = Math.max(0, Math.min(r1.right, r2.right) - Math.max(r1.left, r2.left));
        const yOverlap = Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
        return xOverlap * yOverlap;
    }

    /**
     * Check if rect is fully inside viewport
     */
    function isInsideViewport(rect, viewport) {
        return rect.left >= viewport.left &&
            rect.top >= viewport.top &&
            rect.right <= viewport.right &&
            rect.bottom <= viewport.bottom;
    }

    /**
     * Clamp position to keep panel inside viewport
     */
    function clampToViewport(pos, panelWidth, panelHeight, viewport) {
        return {
            left: Math.max(viewport.left, Math.min(pos.left, viewport.right - panelWidth)),
            top: Math.max(viewport.top, Math.min(pos.top, viewport.bottom - panelHeight))
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CANDIDATE GENERATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Generate candidate positions for file panel
     */
    function getFilePanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Generate candidate positions for selection panel
     */
    function getSelectionPanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Get screen centroid of selected nodes
     */
    function getSelectionCentroid() {
        const Graph = window.Graph;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (!Graph || !Graph.graphData || !selectedIds || selectedIds.size === 0) return null;

        const nodes = Graph.graphData().nodes || [];
        const selectedNodes = nodes.filter(n => selectedIds.has(n.id));
        if (selectedNodes.length === 0) return null;

        let sumX = 0, sumY = 0, sumZ = 0;
        selectedNodes.forEach(n => {
            sumX += n.x || 0;
            sumY += n.y || 0;
            sumZ += n.z || 0;
        });
        const centroid3D = {
            x: sumX / selectedNodes.length,
            y: sumY / selectedNodes.length,
            z: sumZ / selectedNodes.length
        };

        const camera = Graph.camera();
        if (!camera || !window.THREE) return null;
        const vector = new window.THREE.Vector3(centroid3D.x, centroid3D.y, centroid3D.z);
        vector.project(camera);
        return {
            x: (vector.x * 0.5 + 0.5) * window.innerWidth,
            y: (-vector.y * 0.5 + 0.5) * window.innerHeight
        };
    }

    /**
     * Generate candidate positions for hover panel
     */
    function getHoverPanelCandidates(mouseX, mouseY, panelWidth, panelHeight) {
        const vp = getViewport();
        const offset = 16;

        let anchorX = mouseX;
        let anchorY = mouseY;

        const hoveredNode = window.HOVERED_NODE;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (hoveredNode && selectedIds && selectedIds.has(hoveredNode.id)) {
            const centroid = getSelectionCentroid();
            if (centroid) {
                anchorX = mouseX * 0.3 + centroid.x * 0.7;
                anchorY = mouseY * 0.3 + centroid.y * 0.7;
            }
        }

        const sidebarOpen = isSidebarOpen();
        const sidebarRect = sidebarOpen ? getSidebarRect() : null;
        const minLeft = sidebarRect ? sidebarRect.right + offset : vp.left;

        let candidates = [
            { left: anchorX + offset, top: anchorY - panelHeight - offset },
            { left: anchorX + offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY - panelHeight - offset }
        ];

        if (sidebarRect) {
            candidates = candidates.map(c => ({
                left: Math.max(c.left, minLeft),
                top: c.top
            }));
        }

        return candidates;
    }

    /**
     * Update mouse position
     */
    function updateMousePosition(x, y) {
        _mouseX = x;
        _mouseY = y;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PANEL PLACEMENT (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Place a panel at the best position (least overlap)
     */
    function placePanel(panelEl, candidates, occupiedRects) {
        if (!panelEl) return null;

        const rect = panelEl.getBoundingClientRect();
        const panelWidth = rect.width || 400;
        const panelHeight = rect.height || 350;
        const viewport = getViewport();

        let bestPos = candidates[0];
        let bestOverlap = Infinity;

        for (const pos of candidates) {
            const clampedPos = clampToViewport(pos, panelWidth, panelHeight, viewport);
            const panelRect = {
                left: clampedPos.left,
                top: clampedPos.top,
                right: clampedPos.left + panelWidth,
                bottom: clampedPos.top + panelHeight
            };

            let totalOverlap = 0;
            for (const occRect of occupiedRects) {
                totalOverlap += overlapArea(panelRect, occRect);
            }

            if (!isInsideViewport(panelRect, viewport)) {
                totalOverlap += 10000;
            }

            if (totalOverlap < bestOverlap) {
                bestOverlap = totalOverlap;
                bestPos = clampedPos;
                if (totalOverlap === 0) break;
            }
        }

        return bestPos;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST/CONTROL-BAR COLLISION (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Check and resolve toast/control-bar collision
     * Returns offset to apply to toast if collision detected
     */
    function resolveToastCollision() {
        const toast = document.getElementById('toast') ||
                      document.getElementById('hud-toast') ||
                      document.getElementById('mode-toast');
        const controlBar = document.querySelector('.control-bar');

        if (!toast || !controlBar) return 0;

        const toastRect = getRect(toast);
        const barRect = getRect(controlBar);

        if (!toastRect || !barRect) return 0;

        const overlap = overlapArea(toastRect, barRect);
        if (overlap > 0) {
            // Move toast above control bar
            const offset = barRect.height + CONFIG.MARGIN;
            console.log(`[LAYOUT] Toast/control-bar collision: ${overlap}px², offset: -${offset}px`);
            return -offset;
        }
        return 0;
    }

    /**
     * Apply toast offset if needed
     */
    function applyToastOffset() {
        const offset = resolveToastCollision();
        if (offset !== 0) {
            const toast = document.getElementById('toast') ||
                          document.getElementById('hud-toast');
            if (toast) {
                toast.style.transform = `translateX(-50%) translateY(${offset}px)`;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MIN-WIDTH VALIDATOR (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Validate graph has minimum width, adjust sidebars if needed
     */
    function validateGraphWidth() {
        const leftSidebar = document.getElementById('left-sidebar');
        const rightSidebar = document.getElementById('right-sidebar');
        const viewport = getViewport();

        const leftWidth = leftSidebar ? (getRect(leftSidebar)?.width || 0) : 0;
        const rightWidth = rightSidebar ? (getRect(rightSidebar)?.width || 0) : 0;
        const graphWidth = viewport.width - leftWidth - rightWidth;

        if (graphWidth < CONFIG.MIN_GRAPH_WIDTH) {
            const deficit = CONFIG.MIN_GRAPH_WIDTH - graphWidth;
            console.warn(`[LAYOUT] Graph width ${graphWidth}px < ${CONFIG.MIN_GRAPH_WIDTH}px minimum`);

            // Try to reduce right sidebar
            if (rightSidebar && rightWidth > 200) {
                const newWidth = Math.max(200, rightWidth - deficit);
                document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
                return { adjusted: true, component: 'right-sidebar', newWidth };
            }
        }
        return { adjusted: false };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // REFLOW (from HudLayoutManager, enhanced)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Reflow all dynamic panels
     */
    function reflow() {
        const now = Date.now();
        if (now - _lastReflow < CONFIG.REFLOW_THROTTLE_MS) {
            if (!_rafPending) {
                _rafPending = true;
                requestAnimationFrame(() => {
                    _rafPending = false;
                    reflow();
                });
            }
            return;
        }
        _lastReflow = now;

        const occupiedRects = getOccupiedRects();

        // Place hover panel first (higher priority)
        const hoverPanel = document.getElementById('hover-panel');
        let hoverPanelRect = null;
        if (hoverPanel && hoverPanel.classList.contains('visible')) {
            const hoverWidth = hoverPanel.offsetWidth || 280;
            const hoverHeight = hoverPanel.offsetHeight || 200;
            const candidates = getHoverPanelCandidates(_mouseX, _mouseY, hoverWidth, hoverHeight);
            const pos = placePanel(hoverPanel, candidates, occupiedRects);
            if (pos) {
                hoverPanel.style.left = pos.left + 'px';
                hoverPanel.style.top = pos.top + 'px';
                hoverPanel.style.right = 'auto';
                hoverPanelRect = {
                    left: pos.left, top: pos.top,
                    right: pos.left + hoverWidth, bottom: pos.top + hoverHeight
                };
            }
        }

        const filePanelOccupied = [...occupiedRects];
        if (hoverPanelRect) filePanelOccupied.push(hoverPanelRect);

        // Place selection panel
        const selectionPanel = document.getElementById('selection-panel');
        if (selectionPanel && selectionPanel.classList.contains('visible')) {
            const candidates = getSelectionPanelCandidates(
                selectionPanel.offsetWidth || 320,
                selectionPanel.offsetHeight || 280
            );
            const pos = placePanel(selectionPanel, candidates, filePanelOccupied);
            if (pos) {
                selectionPanel.style.left = pos.left + 'px';
                selectionPanel.style.top = pos.top + 'px';
                selectionPanel.style.right = 'auto';
                filePanelOccupied.push({
                    left: pos.left, top: pos.top,
                    right: pos.left + (selectionPanel.offsetWidth || 320),
                    bottom: pos.top + (selectionPanel.offsetHeight || 280)
                });
            }
        }

        // Place file panel
        const filePanel = document.getElementById('file-panel');
        if (filePanel && filePanel.classList.contains('visible')) {
            const candidates = getFilePanelCandidates(
                filePanel.offsetWidth || 400,
                filePanel.offsetHeight || 350
            );
            const pos = placePanel(filePanel, candidates, filePanelOccupied);
            if (pos) {
                filePanel.style.left = pos.left + 'px';
                filePanel.style.top = pos.top + 'px';
                filePanel.style.bottom = 'auto';
            }
        }

        // NEW: Check toast/control-bar collision
        applyToastOffset();

        // NEW: Validate graph width
        validateGraphWidth();

        // NEW: Update debug overlay
        if (_debugEnabled) updateDebugOverlay();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DEBUG OVERLAY (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle debug overlay
     */
    function toggleDebugOverlay() {
        _debugEnabled = !_debugEnabled;

        if (_debugEnabled) {
            if (!_debugOverlay) {
                _debugOverlay = document.createElement('div');
                _debugOverlay.id = 'layout-debug-overlay';
                _debugOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none; z-index: 10001;
                `;
                document.body.appendChild(_debugOverlay);
            }
            updateDebugOverlay();
            console.log('[LAYOUT] Debug overlay ON (Ctrl+Shift+L)');
        } else {
            if (_debugOverlay) {
                _debugOverlay.remove();
                _debugOverlay = null;
            }
            console.log('[LAYOUT] Debug overlay OFF');
        }
    }

    /**
     * Update debug overlay with current component bounds
     */
    function updateDebugOverlay() {
        if (!_debugOverlay) return;

        let html = '';
        const allPanels = [...FIXED_PANELS, ...DYNAMIC_PANELS, 'toast', 'control-bar', 'left-sidebar', 'right-sidebar'];

        allPanels.forEach(id => {
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (!rect) return;

            const kind = FIXED_PANELS.includes(id) ? 'fixed' :
                         DYNAMIC_PANELS.includes(id) ? 'floating' : 'overlay';
            const color = CONFIG.DEBUG_COLORS[kind] || 'rgba(128,128,128,0.3)';

            html += `
                <div style="
                    position: fixed;
                    left: ${rect.left}px; top: ${rect.top}px;
                    width: ${rect.width}px; height: ${rect.height}px;
                    background: ${color};
                    border: 1px solid ${color.replace('0.3', '0.8')};
                    font-size: 10px; color: white; text-shadow: 0 0 2px black;
                    padding: 2px 4px; box-sizing: border-box; overflow: hidden;
                ">${id}</div>
            `;
        });

        _debugOverlay.innerHTML = html;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COMPONENT REGISTRATION (NEW - for future explicit constraints)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Register a component (for explicit constraint tracking)
     */
    function register(descriptor) {
        const { id, selector, kind = 'dock' } = descriptor;
        if (!id) return null;

        let element = typeof selector === 'string' ?
            (document.getElementById(selector.replace('#', '')) || document.querySelector(selector)) :
            selector;

        _registry.set(id, { ...descriptor, element });
        console.log(`[LAYOUT] Registered: ${id} (${kind})`);
        return _registry.get(id);
    }

    /**
     * Get registered component
     */
    function get(id) {
        return _registry.get(id) || null;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize layout system
     */
    function init() {
        // Window resize
        window.addEventListener('resize', () => reflow());

        // Track mouse position
        window.addEventListener('mousemove', (e) => {
            updateMousePosition(e.clientX, e.clientY);
        }, { passive: true });

        // Sidebar state changes
        const sideDock = document.getElementById('side-dock');
        if (sideDock) {
            sideDock.addEventListener('mouseenter', () => reflow());
            sideDock.addEventListener('mouseleave', () => {
                setTimeout(() => reflow(), 200);
            });
        }

        // Debug overlay shortcut (Ctrl+Shift+L)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                e.preventDefault();
                toggleDebugOverlay();
            }
        });

        console.log('[LAYOUT] Initialized (replaces HudLayoutManager)');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Core utilities
        getViewport,
        getRect,
        overlapArea,
        isInsideViewport,
        clampToViewport,

        // Panel placement (backward compatible with HudLayoutManager)
        getOccupiedRects,
        placePanel,
        getFilePanelCandidates,
        getSelectionPanelCandidates,
        getHoverPanelCandidates,
        getSelectionCentroid,
        updateMousePosition,

        // Main entry points
        reflow,
        init,

        // NEW: Validation
        validateGraphWidth,
        resolveToastCollision,

        // NEW: Debug
        toggleDebugOverlay,

        // NEW: Registration
        register,
        get,

        // Config (read-only)
        CONFIG: Object.freeze({ ...CONFIG })
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY: HudLayoutManager alias
// ═══════════════════════════════════════════════════════════════════════════

window.HudLayoutManager = LAYOUT;
window.Layout = LAYOUT;

console.log('[Module] LAYOUT loaded - Unified Layout Engine v2.0.0');


// ═══ MODULE: modules/hud.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HUD MODULE - Heads-up display management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles HUD fade behavior and stats panel updates.
 * Depends on: DOM elements (stat-nodes, stat-edges, stat-entropy, etc.)
 *
 * @module HUD
 * @version 1.0.0
 */

window.HUD = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // HUD FADE BEHAVIOR
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup HUD auto-fade on idle
     * Fades HUD elements after period of inactivity
     */
    function setupFade() {
        const idleDelay = 2200;
        let timer = null;

        const activate = () => {
            document.body.classList.remove('hud-quiet');
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                document.body.classList.add('hud-quiet');
            }, idleDelay);
        };

        ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach((evt) => {
            window.addEventListener(evt, activate, { passive: true });
        });

        activate();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATS UPDATES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all HUD stats elements
     * @param {Object} data - Graph data with nodes, links, meta
     */
    function updateStats(data) {
        if (!data) return;

        // Stats panel: NODES, EDGES, ENTROPY
        const nodeCount = (data.nodes || []).length;
        const edgeCount = (data.links || []).length;

        const statNodes = document.getElementById('stat-nodes');
        const statEdges = document.getElementById('stat-edges');
        const statEntropy = document.getElementById('stat-entropy');

        if (statNodes) statNodes.textContent = nodeCount.toLocaleString();
        if (statEdges) statEdges.textContent = edgeCount.toLocaleString();
        if (statEntropy) {
            const entropy = data.meta?.entropy ?? data.entropy ?? '--';
            statEntropy.textContent = typeof entropy === 'number' ? entropy.toFixed(2) : entropy;
        }

        // Header panel: target name and timestamp
        const targetName = document.getElementById('target-name');
        const timestamp = document.getElementById('timestamp');

        if (targetName) {
            const target = data.meta?.target || data.target || 'Unknown';
            // Show just the last part of the path
            const shortTarget = target.split('/').pop() || target;
            targetName.textContent = shortTarget;
        }

        if (timestamp) {
            const ts = data.meta?.timestamp || data.timestamp || '';
            // Format: 2024-01-15T10:30:00 -> 2024-01-15 10:30
            const formatted = ts.replace('T', ' ').substring(0, 16);
            timestamp.textContent = formatted || 'Live';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupFade: setupFade,
        updateStats: updateStats
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupHudFade = HUD.setupFade;
window.updateHudStats = HUD.updateStats;

console.log('[Module] HUD loaded - 2 functions');


// ═══ MODULE: modules/dimension.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DIMENSION MODULE - 2D/3D dimension switching with animation
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles smooth animated transitions between 2D and 3D graph views.
 * Depends on: Graph, IS_3D, DIMENSION_TRANSITION, stableSeed, stableZ,
 *             fileMode, GRAPH_MODE, applyFileVizMode
 *
 * @module DIMENSION
 * @version 1.1.0
 */

window.DIMENSION = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // DIMENSION TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle between 2D and 3D dimensions
     */
    function toggle() {
        if (window.DIMENSION_TRANSITION) return;
        window.DIMENSION_TRANSITION = true;

        const target3d = !window.IS_3D;
        const button = document.getElementById('btn-2d');

        animateChange(target3d, () => {
            window.IS_3D = target3d;
            window.DIMENSION_TRANSITION = false;
            if (button) button.textContent = window.IS_3D ? '2D' : '3D';

            // Re-apply file viz mode if active
            if (window.fileMode && window.GRAPH_MODE === 'atoms') {
                if (typeof window.applyFileVizMode === 'function') {
                    window.applyFileVizMode();
                }
            }
        });
    }

    /**
     * Setup the dimension toggle button
     */
    function setup() {
        const button = document.getElementById('btn-2d');
        if (!button) return;

        const updateLabel = () => {
            button.textContent = window.IS_3D ? '2D' : '3D';
        };
        updateLabel();
        button.onclick = toggle;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ANIMATED TRANSITION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Animate transition between 2D and 3D
     * @param {boolean} target3d - Whether transitioning to 3D
     * @param {Function} done - Callback when animation completes
     */
    function animateChange(target3d, done) {
        const Graph = window.Graph;
        // STARFIELD & BLOOM removed - nodes ARE the stars, post-processing not in r149+ UMD builds
        const stableSeed = window.stableSeed;
        const stableZ = window.stableZ;

        const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
        const startTime = performance.now();
        const duration = 3000;
        const delayMin = 0;
        const delayMax = 2000;
        const lockPositionsAfterTransition = true;

        const easeInOutSine = (t) => 0.5 - 0.5 * Math.cos(Math.PI * t);

        // Store previous simulation settings
        const previousVelocityDecay = (Graph && Graph.d3VelocityDecay) ? Graph.d3VelocityDecay() : null;
        const previousAlphaTarget = (Graph && Graph.d3AlphaTarget) ? Graph.d3AlphaTarget() : null;
        const previousCooldownTicks = (Graph && Graph.cooldownTicks) ? Graph.cooldownTicks() : null;
        const previousCooldownTime = (Graph && Graph.cooldownTime) ? Graph.cooldownTime() : null;

        // Freeze simulation during transition
        if (Graph && Graph.cooldownTicks) Graph.cooldownTicks(Infinity);
        if (Graph && Graph.cooldownTime) Graph.cooldownTime(Infinity);
        if (Graph && Graph.d3VelocityDecay) Graph.d3VelocityDecay(1);
        if (Graph && Graph.d3AlphaTarget) Graph.d3AlphaTarget(0);
        if (Graph && Graph.d3ReheatSimulation) Graph.d3ReheatSimulation();

        // Initialize node animation state
        nodes.forEach((node) => {
            node.__xStart = node.x || 0;
            node.__yStart = node.y || 0;
            node.__zStart = node.z || 0;
            node.__delay = delayMin + (stableSeed(node, 'delay') * (delayMax - delayMin));
            node.fx = node.__xStart;
            node.fy = node.__yStart;
            node.vx = 0;
            node.vy = 0;
            node.vz = 0;

            if (target3d) {
                if (node.__z3d === undefined || node.__z3d === null) {
                    node.__z3d = node.__zStart || stableZ(node);
                }
            } else {
                node.__z3d = node.__zStart;
            }
        });

        const maxDistance = nodes.reduce((acc, node) => Math.max(acc, Math.abs(node.__zStart || 0)), 1);

        Graph.numDimensions(3);

        const animate = (now) => {
            const elapsed = now - startTime;
            const t = Math.min(1, elapsed / duration);

            // Animate each node's Z position
            nodes.forEach((node) => {
                const startZ = node.__zStart || 0;
                const targetZ = target3d ? (node.__z3d || 0) : 0;
                const delay = node.__delay || 0;
                const localDuration = Math.max(600, duration - delay);
                const localElapsed = Math.max(0, elapsed - delay);
                const localT = Math.min(1, localElapsed / localDuration);
                const localEase = easeInOutSine(localT);
                const distanceRatio = maxDistance > 0 ? Math.abs(startZ) / maxDistance : 0;
                const distanceCurve = 0.6 + (1 - distanceRatio) * 0.6;
                const progress = Math.pow(localEase, distanceCurve);
                const nextZ = startZ + (targetZ - startZ) * progress;
                node.z = nextZ;
                node.fz = nextZ;
                node.vz = 0;
            });

            if (t < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - clean up
                nodes.forEach((node) => {
                    delete node.fz;
                    delete node.__zStart;
                    delete node.__xStart;
                    delete node.__yStart;
                    delete node.__delay;

                    if (!target3d) {
                        node.z = 0;
                        node.fz = 0;
                    } else if (lockPositionsAfterTransition) {
                        node.z = node.__z3d || node.z || 0;
                        node.fz = node.z;
                    } else {
                        delete node.fx;
                        delete node.fy;
                    }
                });

                Graph.numDimensions(target3d ? 3 : 2);

                // Restore simulation settings
                if (Graph && Graph.d3VelocityDecay && previousVelocityDecay !== null) {
                    Graph.d3VelocityDecay(previousVelocityDecay);
                }
                if (Graph && Graph.d3AlphaTarget && previousAlphaTarget !== null) {
                    Graph.d3AlphaTarget(previousAlphaTarget);
                }
                if (Graph && Graph.cooldownTicks && previousCooldownTicks !== null) {
                    Graph.cooldownTicks(previousCooldownTicks);
                }
                if (Graph && Graph.cooldownTime && previousCooldownTime !== null) {
                    Graph.cooldownTime(previousCooldownTime);
                }

                if (done) done();
            }
        };

        requestAnimationFrame(animate);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        toggle: toggle,
        setup: setup,
        animateChange: animateChange
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.toggleDimensions = DIMENSION.toggle;
window.setupDimensionToggle = DIMENSION.setup;
window.animateDimensionChange = DIMENSION.animateChange;

console.log('[Module] DIMENSION loaded - 3 functions');


// ═══ MODULE: modules/report.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * REPORT MODULE - Report panel, AI insights, and metrics display
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles the brain download report, AI insights panel, and metrics/KPI display.
 * Depends on: escapeHtml (from utils.js), DOM elements
 *
 * @module REPORT
 * @version 1.0.0
 */

window.REPORT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BRAIN DOWNLOAD REPORT
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the brain download report panel
     * @param {Object} data - Data object with brain_download field
     */
    function setupReport(data) {
        const panel = document.getElementById('report-panel');
        const content = document.getElementById('report-content');
        // Guard: elements may not exist in minimal template
        if (!content) return;
        const report = (data && data.brain_download) ? data.brain_download : '';
        content.textContent = report || 'No report available.';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // AI INSIGHTS PANEL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the AI insights panel
     * @param {Object} data - Data object with ai_insights field
     */
    function setupAIInsights(data) {
        const escapeHtml = window.escapeHtml || ((s) => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])));

        const panel = document.getElementById('insights-panel');
        const content = document.getElementById('insights-content');
        const btn = document.getElementById('btn-insights');

        const insights = (data && data.ai_insights) ? data.ai_insights : null;

        if (!insights) {
            // Hide the button if no insights available
            if (btn) btn.style.display = 'none';
            return;
        }

        // Show the button
        if (btn) btn.style.display = 'inline-flex';

        // Render insights
        let html = '';

        // Executive Summary
        if (insights.executive_summary) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Executive Summary</div>
                <div class="insights-summary">${escapeHtml(insights.executive_summary)}</div>
            </div>`;
        }

        // Patterns Detected
        if (insights.patterns_detected && insights.patterns_detected.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Patterns Detected</div>`;
            for (const pattern of insights.patterns_detected) {
                const confidencePercent = Math.round((pattern.confidence || 0) * 100);
                html += `<div class="insights-pattern">
                    <div class="insights-pattern-header">
                        <span class="insights-pattern-name">${escapeHtml(pattern.pattern_name || 'Unknown')}</span>
                        <span class="insights-pattern-type ${pattern.pattern_type || ''}">${escapeHtml(pattern.pattern_type || '')}</span>
                    </div>
                    <div class="insights-confidence">
                        <div class="insights-confidence-bar">
                            <div class="insights-confidence-fill" style="width: ${confidencePercent}%"></div>
                        </div>
                        <span>${confidencePercent}%</span>
                    </div>
                    ${pattern.evidence ? `<div class="insights-pattern-evidence">${escapeHtml(pattern.evidence)}</div>` : ''}
                    ${pattern.recommendation ? `<div class="insights-pattern-evidence" style="color: var(--color-accent-secondary);">Tip: ${escapeHtml(pattern.recommendation)}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Refactoring Opportunities
        if (insights.refactoring_opportunities && insights.refactoring_opportunities.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Refactoring Opportunities</div>`;
            for (const refactor of insights.refactoring_opportunities) {
                html += `<div class="insights-refactor">
                    <div class="insights-refactor-title">
                        ${escapeHtml(refactor.title || 'Untitled')}
                        <span class="insights-refactor-priority ${refactor.priority || 'LOW'}">${refactor.priority || 'LOW'}</span>
                    </div>
                    ${refactor.description ? `<div class="insights-refactor-desc">${escapeHtml(refactor.description)}</div>` : ''}
                    ${refactor.affected_files && refactor.affected_files.length > 0 ?
                        `<div class="insights-refactor-desc" style="margin-top: 4px; color: var(--color-text-muted);">Files: ${refactor.affected_files.slice(0, 3).map(f => escapeHtml(f)).join(', ')}${refactor.affected_files.length > 3 ? '...' : ''}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Topology Analysis
        if (insights.topology_analysis) {
            const topo = insights.topology_analysis;
            html += `<div class="insights-section">
                <div class="insights-section-title">Topology Analysis</div>
                ${topo.shape_interpretation ? `<div class="insights-summary">${escapeHtml(topo.shape_interpretation)}</div>` : ''}
                ${topo.health_assessment ? `<div class="insights-pattern-evidence">Health: ${escapeHtml(topo.health_assessment)}</div>` : ''}
                ${topo.coupling_analysis ? `<div class="insights-pattern-evidence">Coupling: ${escapeHtml(topo.coupling_analysis)}</div>` : ''}
            </div>`;
        }

        // Risk Areas
        if (insights.risk_areas && insights.risk_areas.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Risk Areas</div>`;
            for (const risk of insights.risk_areas) {
                html += `<div class="insights-risk">
                    <span class="insights-risk-level ${risk.risk_level || 'LOW'}">${risk.risk_level || 'LOW'}</span>
                    <div class="insights-risk-content">
                        <div class="insights-risk-area">${escapeHtml(risk.area || 'Unknown')}</div>
                        ${risk.description ? `<div class="insights-risk-desc">${escapeHtml(risk.description)}</div>` : ''}
                        ${risk.mitigation ? `<div class="insights-risk-desc" style="color: var(--color-accent-secondary); margin-top: 4px;">Tip: ${escapeHtml(risk.mitigation)}</div>` : ''}
                    </div>
                </div>`;
            }
            html += '</div>';
        }

        // Meta information
        if (insights.meta) {
            const meta = insights.meta;
            html += `<div class="insights-meta">
                Generated: ${meta.generated_at ? new Date(meta.generated_at).toLocaleString() : 'Unknown'}
                | Model: ${escapeHtml(meta.model || 'Unknown')}
                ${meta.confidence ? ` | Confidence: ${Math.round(meta.confidence * 100)}%` : ''}
            </div>`;
        }

        content.innerHTML = html || '<div class="insights-placeholder">No insights data available.</div>';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METRICS / KPI DISPLAY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup metrics and health indicators
     * @param {Object} data - Data object with kpis field
     */
    function setupMetrics(data) {
        const kpis = (data && data.kpis) ? data.kpis : {};

        const setText = (id, value) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = value;
        };

        const asNumber = (val) => {
            const num = Number(val);
            return Number.isFinite(num) ? num : null;
        };

        const formatPercent = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}%`;
        };

        const formatCount = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${Math.round(num)}`;
        };

        const formatScore = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}/10`;
        };

        // Set metric values
        setText('metric-edge-resolution', formatPercent(kpis.edge_resolution_percent));
        setText('metric-call-ratio', formatPercent(kpis.call_ratio_percent));
        setText('metric-reachability', formatPercent(kpis.reachability_percent));
        setText('metric-dead-code', formatPercent(kpis.dead_code_percent));
        setText('metric-knot-score', formatScore(kpis.knot_score));
        setText('metric-topology', kpis.topology_shape || 'UNKNOWN');
        setText('metric-orphans', formatCount(kpis.orphan_count));
        setText('metric-top-hubs', formatCount(kpis.top_hub_count));

        // Set health indicators (traffic light bars)
        const setHealth = (id, level) => {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('good', 'medium', 'bad', 'neutral');
                el.classList.add(level);
            }
        };

        // Edge Resolution: >90% good, 70-90% medium, <70% bad
        const edgeRes = asNumber(kpis.edge_resolution_percent);
        setHealth('health-edge-resolution', edgeRes === null ? 'neutral' : edgeRes >= 90 ? 'good' : edgeRes >= 70 ? 'medium' : 'bad');

        // Call Ratio: >60% good, 40-60% medium, <40% bad
        const callRatio = asNumber(kpis.call_ratio_percent);
        setHealth('health-call-ratio', callRatio === null ? 'neutral' : callRatio >= 60 ? 'good' : callRatio >= 40 ? 'medium' : 'bad');

        // Reachability: >90% good, 70-90% medium, <70% bad
        const reach = asNumber(kpis.reachability_percent);
        setHealth('health-reachability', reach === null ? 'neutral' : reach >= 90 ? 'good' : reach >= 70 ? 'medium' : 'bad');

        // Dead Code: <5% good, 5-15% medium, >15% bad (INVERTED - lower is better)
        const dead = asNumber(kpis.dead_code_percent);
        setHealth('health-dead-code', dead === null ? 'neutral' : dead <= 5 ? 'good' : dead <= 15 ? 'medium' : 'bad');

        // Knot Score: <3 good, 3-6 medium, >6 bad (INVERTED - lower is better)
        const knot = asNumber(kpis.knot_score);
        setHealth('health-knot-score', knot === null ? 'neutral' : knot <= 3 ? 'good' : knot <= 6 ? 'medium' : 'bad');

        // Topology: neutral (informational only)
        setHealth('health-topology', 'neutral');

        // Orphans: <10 good, 10-50 medium, >50 bad (INVERTED - lower is better)
        const orphans = asNumber(kpis.orphan_count);
        setHealth('health-orphans', orphans === null ? 'neutral' : orphans <= 10 ? 'good' : orphans <= 50 ? 'medium' : 'bad');

        // Top Hubs: neutral (informational only)
        setHealth('health-top-hubs', 'neutral');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupReport: setupReport,
        setupAIInsights: setupAIInsights,
        setupMetrics: setupMetrics
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupReport = REPORT.setupReport;
window.setupAIInsights = REPORT.setupAIInsights;
window.setupMetrics = REPORT.setupMetrics;

console.log('[Module] REPORT loaded - 3 functions');


// ═══ MODULE: modules/visibility.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VISIBILITY MODULE - UI visibility controls and filter utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles background brightness, metadata visibility, filter clearing,
 * and collapsible section management.
 * Depends on: Graph, APPEARANCE_STATE, VIS_FILTERS, THREE
 *
 * @module VISIBILITY
 * @version 1.0.0
 */

window.VISIBILITY = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BACKGROUND CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update background brightness based on APPEARANCE_STATE
     */
    function updateBackgroundBrightness() {
        const Graph = window.Graph;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const THREE = window.THREE;

        if (!Graph || !APPEARANCE_STATE.backgroundBase) return;
        const baseColor = new THREE.Color(APPEARANCE_STATE.backgroundBase);
        const brightness = APPEARANCE_STATE.backgroundBrightness ?? 1;
        const adjusted = baseColor.clone().multiplyScalar(brightness);
        Graph.backgroundColor(`#${adjusted.getHexString()}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA VISIBILITY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply metadata visibility settings (report panel, file panel, etc.)
     */
    function applyMetadataVisibility() {
        const VIS_FILTERS = window.VIS_FILTERS;

        const reportPanel = document.getElementById('report-panel');
        const reportButton = document.getElementById('btn-report');
        const filePanel = document.getElementById('file-panel');

        // Guard: elements may not exist in minimal template
        if (!reportPanel && !reportButton) return;

        if (!VIS_FILTERS.metadata.showReportPanel) {
            if (reportPanel) reportPanel.style.display = 'none';
            if (reportButton) {
                reportButton.classList.remove('active');
                reportButton.style.display = 'none';
            }
        } else {
            if (reportButton) reportButton.style.display = 'inline-flex';
        }
        if (!VIS_FILTERS.metadata.showFilePanel && filePanel) {
            filePanel.classList.remove('visible');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clear all dimension filters (tier, ring, family, role, file, edge)
     * Used for zero-node recovery and manual reset
     */
    function clearAllFilters() {
        const VIS_FILTERS = window.VIS_FILTERS;

        VIS_FILTERS.tiers.clear();
        VIS_FILTERS.rings.clear();
        VIS_FILTERS.families.clear();
        VIS_FILTERS.roles.clear();
        VIS_FILTERS.files.clear();
        VIS_FILTERS.edges.clear();
        VIS_FILTERS.layers.clear();
        VIS_FILTERS.effects.clear();
        VIS_FILTERS.edgeFamilies.clear();

        // Update legend UI
        document.querySelectorAll('.topo-legend-item.filtered').forEach(el => el.classList.remove('filtered'));

        // Update chip UI
        document.querySelectorAll('.filter-chip.active').forEach(el => el.classList.remove('active'));

        console.log('[Filters] All filters cleared');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLLAPSIBLE SECTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup collapsible sections in sidebar and panels
     */
    function setupCollapsibleSections() {
        // Standard sidebar sections
        const titles = document.querySelectorAll('.side-title.collapsible');
        titles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('collapsed', isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });

        // Topology section collapsibles (GEOMETRY panel)
        const topoTitles = document.querySelectorAll('.topo-section-title.collapsible');
        topoTitles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('expanded', !isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updateBackgroundBrightness: updateBackgroundBrightness,
        applyMetadataVisibility: applyMetadataVisibility,
        clearAllFilters: clearAllFilters,
        setupCollapsibleSections: setupCollapsibleSections
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateBackgroundBrightness = VISIBILITY.updateBackgroundBrightness;
window.applyMetadataVisibility = VISIBILITY.applyMetadataVisibility;
window.clearAllFilters = VISIBILITY.clearAllFilters;
window.setupCollapsibleSections = VISIBILITY.setupCollapsibleSections;

console.log('[Module] VISIBILITY loaded - 4 functions');


// ═══ MODULE: modules/animation.js ═══
/**
 * ANIMATION MODULE
 *
 * Unified animation controller for all layout transitions and continuous motions.
 * Addresses ARCH-002 (O(n^2) flock), ARCH-003 (unthrottled refresh), ARCH-004 (conflicts).
 *
 * Key improvements:
 * - Single animation ownership prevents conflicts
 * - Spatial hashing reduces flock from O(n^2) to O(n)
 * - Integration with REFRESH module for throttled updates
 *
 * Usage:
 *   ANIM.applyLayout('orbital')           // Apply a layout preset
 *   ANIM.stop()                           // Stop all animations
 *   ANIM.setStaggerPattern('radial')      // Change wave pattern
 */

const ANIM = (function () {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        baseDuration: 1200,      // Base animation duration (ms)
        staggerSpread: 800,      // Stagger spread (ms)
        flockMaxNodes: 500,      // Max nodes for flock simulation
        spatialGridSize: 50,     // Grid cell size for spatial hashing
        motionFrameSkip: 0       // Skip frames for motion (0 = no skip)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _currentLayout = 'force';
    let _animationId = null;
    let _layoutTime = 0;
    let _currentStaggerPattern = 'tier';
    let _owner = 'none';  // Current animation owner

    // =========================================================================
    // STAGGER PATTERNS - Wave-based node transitions
    // =========================================================================

    const STAGGER_PATTERNS = {
        // Radial ripple: center nodes move first, ripples outward
        radial: (node, startPos, targetPos) => {
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2 + startPos.z ** 2);
            return Math.min(1, dist / 500);
        },
        // Tier cascade: T0 first, then T1, then T2
        tier: (node) => {
            const tier = NODE.getTier(node);
            const tierNum = tier === 'T0' ? 0 : tier === 'T1' ? 1 : 2;
            return tierNum / 2;
        },
        // Distance-based: shortest travel first
        distance: (node, startPos, targetPos) => {
            const dx = targetPos.x - startPos.x;
            const dy = targetPos.y - startPos.y;
            const dz = targetPos.z - startPos.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            return Math.min(1, dist / 400);
        },
        // File grouping: nodes in same file move together
        file: (node) => {
            const fileIdx = node.fileIdx ?? 0;
            return (fileIdx % 8) / 8;
        },
        // Spiral pattern
        spiral: (node, startPos) => {
            const angle = Math.atan2(startPos.y, startPos.x);
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2);
            return ((angle + Math.PI) / (2 * Math.PI) + dist / 1000) % 1;
        },
        // Random stagger
        random: () => Math.random() * 0.6
    };

    // =========================================================================
    // LAYOUT PRESETS
    // =========================================================================

    const LAYOUT_PRESETS = {
        'force': {
            name: 'FORCE', icon: '?', description: 'Physics-based clustering',
            motion: 'settle', cooldown: 300, warmupTicks: 40, getPosition: null
        },
        'orbital': {
            name: 'ORBITAL', icon: '?', description: 'Planetary orbit bands',
            motion: 'orbit', cooldown: Infinity, orbitSpeed: 0.002,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const r = { T0: 80, T1: 160, T2: 280, UNKNOWN: 200 }[tier] || 200;
                const fOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const angle = (fOff / 5) * Math.PI * 2 + (idx / Math.max(1, total)) * Math.PI * 0.3 + (time || 0) * (0.5 + r * 0.001);
                const wobble = Math.sin(idx * 0.7 + (time || 0) * 2) * 15;
                return {
                    x: Math.cos(angle) * (r + wobble),
                    y: Math.sin(idx * 0.3) * 40 + (tier === 'T0' ? -50 : tier === 'T2' ? 50 : 0),
                    z: Math.sin(angle) * (r + wobble)
                };
            }
        },
        'radial': {
            name: 'RADIAL', icon: '?', description: 'Concentric tier rings',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total, time, tierGroups) => {
                const tier = NODE.getTier(node);
                const r = { T0: 60, T1: 150, T2: 280, UNKNOWN: 220 }[tier] || 180;
                const tierNodes = tierGroups?.[tier] || [];
                const tierIdx = tierNodes.indexOf(node);
                const tierTotal = tierNodes.length || 1;
                const angle = (tierIdx / tierTotal) * Math.PI * 2;
                return { x: Math.cos(angle) * r, y: 0, z: Math.sin(angle) * r };
            }
        },
        'spiral': {
            name: 'SPIRAL', icon: '?', description: 'DNA-like helix',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.003,
            getPosition: (node, idx, total, time) => {
                const t = idx / Math.max(1, total);
                const angle = t * Math.PI * 2 * 4 + (time || 0);
                const r = 100 + t * 150;
                return { x: Math.cos(angle) * r, y: (t - 0.5) * 400, z: Math.sin(angle) * r };
            }
        },
        'sphere': {
            name: 'SPHERE', icon: '?', description: 'Globe surface',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const latBase = { T0: 0.8, T1: 0.5, T2: 0.2, UNKNOWN: 0.5 }[tier] || 0.5;
                const lat = (latBase + (idx % 10) * 0.02) * Math.PI;
                const lonBase = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 180 }[family] || 0;
                const lon = ((lonBase + idx * 3) % 360) * Math.PI / 180 + (time || 0);
                const r = 200;
                return {
                    x: Math.sin(lat) * Math.cos(lon) * r,
                    y: Math.cos(lat) * r,
                    z: Math.sin(lat) * Math.sin(lon) * r
                };
            }
        },
        'grid': {
            name: 'GRID', icon: '?', description: '3D lattice',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const tierX = { T0: -150, T1: 0, T2: 150, UNKNOWN: 0 }[tier] || 0;
                const famZ = { LOG: -120, DAT: -60, ORG: 0, EXE: 60, EXT: 120, UNKNOWN: 0 }[family] || 0;
                const row = Math.floor(idx / 15);
                const col = idx % 15;
                return { x: tierX + (col - 7) * 20, y: row * 25 - 100, z: famZ + Math.sin(idx * 0.5) * 20 };
            }
        },
        'flock': {
            name: 'FLOCK', icon: '?', description: 'Swarming birds',
            motion: 'flock', cooldown: Infinity,
            flockParams: { separation: 25, alignment: 0.05, cohesion: 0.01, maxSpeed: 2 },
            getPosition: null
        },
        'galaxy': {
            name: 'GALAXY', icon: '?', description: 'Spiral arms',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const family = NODE.getFamily(node);
                const tier = NODE.getTier(node);
                const armOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const baseAngle = (armOff / 5) * Math.PI * 2;
                const dist = 50 + (idx / total) * 250;
                const spiralAngle = baseAngle + dist * 0.015 + (time || 0);
                const tierY = { T0: -30, T1: 0, T2: 30, UNKNOWN: 0 }[tier] || 0;
                return {
                    x: Math.cos(spiralAngle) * dist,
                    y: tierY + Math.sin(idx * 0.5) * 20,
                    z: Math.sin(spiralAngle) * dist
                };
            }
        }
    };

    // =========================================================================
    // SPATIAL HASHING - O(n) neighbor lookup for flock simulation
    // =========================================================================

    function _buildSpatialGrid(nodes, cellSize) {
        const grid = new Map();

        nodes.forEach((node, idx) => {
            const x = node.x || 0;
            const y = node.y || 0;
            const z = node.z || 0;

            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) {
                grid.set(key, []);
            }
            grid.get(key).push({ node, idx });
        });

        return grid;
    }

    function _getNeighborsFromGrid(grid, node, cellSize, radius) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);

        const neighbors = [];
        const cellRadius = Math.ceil(radius / cellSize);

        // Check neighboring cells
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                    const key = `${cellX + dx},${cellY + dy},${cellZ + dz}`;
                    const cell = grid.get(key);
                    if (cell) {
                        cell.forEach(entry => {
                            if (entry.node !== node) {
                                neighbors.push(entry.node);
                            }
                        });
                    }
                }
            }
        }

        return neighbors;
    }

    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================

    function _groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = NODE.getTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    function _acquireOwnership(owner) {
        // Cancel any existing animation
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = owner;
        return true;
    }

    function _releaseOwnership(owner) {
        if (_owner === owner) {
            if (_animationId) {
                cancelAnimationFrame(_animationId);
                _animationId = null;
            }
            _owner = 'none';
        }
    }

    // =========================================================================
    // LAYOUT APPLICATION
    // =========================================================================

    function applyLayout(presetKey, animate = true) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset) return;

        _currentLayout = presetKey;
        _acquireOwnership('layout');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);

        // Handle force layout specially
        if (presetKey === 'force') {
            nodes.forEach(n => {
                n.fx = undefined;
                n.fy = undefined;
                n.fz = undefined;
            });
            Graph.cooldownTicks(preset.cooldown);
            Graph.d3ReheatSimulation();
            _releaseOwnership('layout');
            if (typeof showModeToast === 'function') {
                showModeToast('? FORCE layout');
            }
            return;
        }

        // Handle flock specially
        if (preset.motion === 'flock') {
            _startFlockSimulation(preset.flockParams);
            Graph.cooldownTicks(preset.cooldown);
            if (typeof showModeToast === 'function') {
                showModeToast(`${preset.icon} ${preset.name} layout`);
            }
            return;
        }

        // Position-based layouts
        if (preset.getPosition) {
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => preset.getPosition(n, i, total, 0, tierGroups));

            if (animate && total > 100) {
                // STAGGERED ANIMATION for large graphs
                _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey);
            } else if (animate) {
                // SIMPLE ANIMATION for small graphs
                _animateSimple(nodes, startPos, targetPos, preset, presetKey);
            } else {
                // INSTANT
                nodes.forEach((n, i) => {
                    const p = targetPos[i];
                    n.fx = p.x;
                    n.fy = p.y;
                    n.fz = p.z;
                });
                if (typeof REFRESH !== 'undefined') {
                    REFRESH.force();
                } else if (Graph) {
                    REFRESH.throttled();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                }
            }
        }

        Graph.cooldownTicks(preset.cooldown);
        if (typeof showModeToast === 'function') {
            showModeToast(`${preset.icon} ${preset.name} layout`);
        }
    }

    function _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey) {
        const baseDuration = CONFIG.baseDuration;
        const staggerSpread = CONFIG.staggerSpread;
        const startTime = Date.now();

        // Hide edges during animation for performance
        Graph.linkOpacity(0);

        // Calculate delay for each node
        const pattern = STAGGER_PATTERNS[_currentStaggerPattern] || STAGGER_PATTERNS.tier;
        const delays = nodes.map((n, i) => pattern(n, startPos[i], targetPos[i]) * staggerSpread);

        function animateFrame() {
            if (_owner !== 'layout') return;

            const elapsed = Date.now() - startTime;

            nodes.forEach((n, i) => {
                const nodeStart = delays[i];
                const nodeElapsed = elapsed - nodeStart;

                if (nodeElapsed <= 0) {
                    n.fx = startPos[i].x;
                    n.fy = startPos[i].y;
                    n.fz = startPos[i].z;
                } else if (nodeElapsed >= baseDuration) {
                    n.fx = targetPos[i].x;
                    n.fy = targetPos[i].y;
                    n.fz = targetPos[i].z;
                } else {
                    const progress = nodeElapsed / baseDuration;
                    const eased = progress * progress * (3 - 2 * progress);
                    n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                    n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                    n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
                }
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            const totalDuration = baseDuration + staggerSpread;
            if (elapsed < totalDuration) {
                _animationId = requestAnimationFrame(animateFrame);
            } else {
                // Restore edges
                if (typeof applyEdgeMode === 'function') {
                    applyEdgeMode();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                } else {
                    _releaseOwnership('layout');
                }
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _animateSimple(nodes, startPos, targetPos, preset, presetKey) {
        const duration = 1500;
        const startTime = Date.now();

        function animateFrame() {
            if (_owner !== 'layout') return;

            const progress = Math.min(1, (Date.now() - startTime) / duration);
            const eased = progress * progress * (3 - 2 * progress);

            nodes.forEach((n, i) => {
                n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            if (progress < 1) {
                _animationId = requestAnimationFrame(animateFrame);
            } else if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                _startLayoutMotion(presetKey);
            } else {
                _releaseOwnership('layout');
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _startLayoutMotion(presetKey) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset || !preset.getPosition) return;

        _acquireOwnership('motion');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);
        const speed = preset.rotateSpeed || preset.orbitSpeed || 0.002;

        function animate() {
            if (_owner !== 'motion') return;

            _layoutTime += speed;

            nodes.forEach((n, i) => {
                const pos = preset.getPosition(n, i, total, _layoutTime, tierGroups);
                n.fx = pos.x;
                n.fy = pos.y;
                n.fz = pos.z;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(animate);
        }

        _animationId = requestAnimationFrame(animate);
    }

    // =========================================================================
    // FLOCK SIMULATION - O(n) with spatial hashing
    // =========================================================================

    function _startFlockSimulation(params) {
        const nodes = Graph?.graphData()?.nodes || [];

        // Performance guard
        if (nodes.length > CONFIG.flockMaxNodes) {
            console.warn(`[ANIM] Flock disabled: ${nodes.length} nodes exceeds ${CONFIG.flockMaxNodes} limit`);
            if (typeof showModeToast === 'function') {
                showModeToast('Warning: Flock disabled (too many nodes)');
            }
            return;
        }

        _acquireOwnership('flock');

        const { separation, alignment, cohesion, maxSpeed } = params;

        // Initialize velocities
        nodes.forEach(n => {
            n._vx = (Math.random() - 0.5) * 2;
            n._vy = (Math.random() - 0.5) * 2;
            n._vz = (Math.random() - 0.5) * 2;
        });

        function flockStep() {
            if (_owner !== 'flock') return;

            // Build spatial grid for O(n) neighbor lookup
            const grid = _buildSpatialGrid(nodes, CONFIG.spatialGridSize);
            const neighborRadius = separation * 3;

            nodes.forEach(n => {
                // Get nearby neighbors from spatial grid (O(1) per node)
                const neighbors = _getNeighborsFromGrid(grid, n, CONFIG.spatialGridSize, neighborRadius);

                let sepX = 0, sepY = 0, sepZ = 0, sepCount = 0;
                let alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;

                const myFamily = NODE.getFamily(n);

                neighbors.forEach(other => {
                    const dx = (other.x || 0) - (n.x || 0);
                    const dy = (other.y || 0) - (n.y || 0);
                    const dz = (other.z || 0) - (n.z || 0);
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 0.001;

                    // Separation
                    if (dist < separation * 2) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                        sepZ -= dz / dist;
                        sepCount++;
                    }

                    // Alignment and cohesion (same family only)
                    if (NODE.getFamily(other) === myFamily && dist < 150) {
                        alignX += other._vx || 0;
                        alignY += other._vy || 0;
                        alignZ += other._vz || 0;
                        alignCount++;

                        cohX += other.x || 0;
                        cohY += other.y || 0;
                        cohZ += other.z || 0;
                        cohCount++;
                    }
                });

                // Apply forces
                if (sepCount > 0) {
                    n._vx += (sepX / sepCount) * separation * 0.05;
                    n._vy += (sepY / sepCount) * separation * 0.05;
                    n._vz += (sepZ / sepCount) * separation * 0.05;
                }
                if (alignCount > 0) {
                    n._vx += ((alignX / alignCount) - n._vx) * alignment;
                    n._vy += ((alignY / alignCount) - n._vy) * alignment;
                    n._vz += ((alignZ / alignCount) - n._vz) * alignment;
                }
                if (cohCount > 0) {
                    n._vx += (cohX / cohCount - (n.x || 0)) * cohesion;
                    n._vy += (cohY / cohCount - (n.y || 0)) * cohesion;
                    n._vz += (cohZ / cohCount - (n.z || 0)) * cohesion;
                }

                // Center attraction
                n._vx -= (n.x || 0) * 0.0005;
                n._vy -= (n.y || 0) * 0.0005;
                n._vz -= (n.z || 0) * 0.0005;

                // Speed limit
                const speed = Math.sqrt(n._vx * n._vx + n._vy * n._vy + n._vz * n._vz);
                if (speed > maxSpeed) {
                    n._vx = (n._vx / speed) * maxSpeed;
                    n._vy = (n._vy / speed) * maxSpeed;
                    n._vz = (n._vz / speed) * maxSpeed;
                }

                // Update position
                n.fx = (n.x || 0) + n._vx;
                n.fy = (n.y || 0) + n._vy;
                n.fz = (n.z || 0) + n._vz;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(flockStep);
        }

        _animationId = requestAnimationFrame(flockStep);
    }

    // =========================================================================
    // PULSE ANIMATION
    // =========================================================================

    let _pulseId = null;

    function togglePulse(active) {
        if (active) {
            _startPulse();
        } else {
            _stopPulse();
        }
    }

    function _startPulse() {
        if (_pulseId) return;
        const startTime = Date.now();

        function loop() {
            const elapsed = Date.now() - startTime;
            // Oscillate lightness +/- 10%
            const val = Math.sin(elapsed * 0.003) * 10;

            if (typeof COLOR !== 'undefined') {
                COLOR.setTransform('lightnessShift', val);
                // Also breathe chroma a bit
                COLOR.setTransform('chromaScale', 1.0 + Math.sin(elapsed * 0.003) * 0.2);
            }

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof Graph !== 'undefined' && Graph) {
                // Determine if we need to force re-coloring or if just re-rendering canvas is enough.
                // Since transforms affect color calculation, we likely need to re-apply colors.
                if (typeof window.applyNodeColors === 'function') {
                    const nodes = Graph.graphData().nodes;
                    window.applyNodeColors(nodes);
                    Graph.nodeColor(Graph.nodeColor()); // Trigger internal update
                }
            }

            _pulseId = requestAnimationFrame(loop);
        }
        _pulseId = requestAnimationFrame(loop);
        if (typeof showModeToast === 'function') showModeToast('Pulse Animation ON');
    }

    function _stopPulse() {
        if (_pulseId) {
            cancelAnimationFrame(_pulseId);
            _pulseId = null;
        }
        // Reset
        if (typeof COLOR !== 'undefined') {
            COLOR.setTransform('lightnessShift', 0);
            COLOR.setTransform('chromaScale', 1.0);
        }

        // Final refresh to clear artifacts
        if (typeof window.applyNodeColors === 'function' && typeof Graph !== 'undefined') {
            const nodes = Graph.graphData().nodes;
            window.applyNodeColors(nodes);
            Graph.nodeColor(Graph.nodeColor());
        }

        if (typeof showModeToast === 'function') showModeToast('Pulse Animation OFF');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function stop() {
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = 'none';
    }

    function setStaggerPattern(pattern) {
        if (STAGGER_PATTERNS[pattern]) {
            _currentStaggerPattern = pattern;
            if (typeof showModeToast === 'function') {
                showModeToast(`Wave pattern: ${pattern.toUpperCase()}`);
            }
        }
    }

    function cycleStaggerPattern() {
        const patterns = Object.keys(STAGGER_PATTERNS);
        const currentIdx = patterns.indexOf(_currentStaggerPattern);
        _currentStaggerPattern = patterns[(currentIdx + 1) % patterns.length];
        if (typeof showModeToast === 'function') {
            showModeToast(`Wave pattern: ${_currentStaggerPattern.toUpperCase()}`);
        }
        return _currentStaggerPattern;
    }

    return {
        // Layout control
        applyLayout,
        stop,

        // Stagger patterns
        setStaggerPattern,
        cycleStaggerPattern,
        togglePulse, // Added to public API
        get staggerPattern() { return _currentStaggerPattern; },
        get staggerPatterns() { return Object.keys(STAGGER_PATTERNS); },

        // State
        get currentLayout() { return _currentLayout; },
        get isAnimating() { return _animationId !== null; },
        get owner() { return _owner; },

        // Layout presets
        presets: LAYOUT_PRESETS,

        // Config
        config: CONFIG
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// Note: CURRENT_LAYOUT, LAYOUT_ANIMATION_ID, LAYOUT_TIME, CURRENT_STAGGER_PATTERN
// are managed by app.js (separate animation system) - not duplicated here
Object.defineProperty(window, 'LAYOUT_PRESETS', { get: () => ANIM.presets, configurable: true });
Object.defineProperty(window, 'STAGGER_PATTERNS', { get: () => ANIM.staggerPatterns, configurable: true });

function applyLayoutPreset(presetKey, animate) {
    ANIM.applyLayout(presetKey, animate);
}

function cycleStaggerPattern() {
    ANIM.cycleStaggerPattern();
}

function startFlockSimulation(params) {
    // Handled internally by ANIM
    ANIM.applyLayout('flock');
}

function groupNodesByTier(nodes) {
    const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
    nodes.forEach(n => {
        const tier = NODE.getTier(n);
        (groups[tier] || groups.UNKNOWN).push(n);
    });
    return groups;
}


// ═══ MODULE: modules/selection.js ═══
/**
 * SELECTION MODULE
 *
 * Manages node selection, multi-select, marquee selection, and selection visuals.
 * Includes animated selection colors using OKLCH pendulum system.
 *
 * Depends on: CORE (PENDULUM, SELECTION_SIZE_MULT), NODE, COLOR
 *
 * Usage:
 *   SELECT.set([id1, id2])              // Set selection
 *   SELECT.toggle(node)                 // Toggle node selection
 *   SELECT.clear()                      // Clear selection
 *   SELECT.getSelectedNodes()           // Get selected node objects
 *   SELECT.ids                          // Get Set of selected IDs
 */

const SELECT = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    const _ids = new Set();
    let _marqueeActive = false;
    let _marqueeStart = null;
    let _marqueeAdditive = false;
    let _lastMarqueeEndTs = 0;

    // Selection visuals state
    const _selectionOriginals = new Map();
    const _originalColorsForDim = new Map();

    // THREE.js geometries (created lazily)
    let _selectionHaloGeometry = null;
    let _groupHaloGeometry = null;

    // =========================================================================
    // CORE SELECTION FUNCTIONS
    // =========================================================================

    /**
     * Get currently selected nodes
     */
    function getSelectedNodes() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return [];
        const nodes = Graph.graphData().nodes || [];
        return nodes.filter(node => node && node.id && _ids.has(node.id));
    }

    /**
     * Set selection (optionally additive)
     */
    function set(ids, additive = false) {
        if (!additive) {
            _ids.clear();
        }
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        // Use app.js's updateSelectionVisuals if available (has group halo logic)
        // Otherwise fall back to internal _updateVisuals
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Toggle a node's selection state
     */
    function toggle(node) {
        if (!node || !node.id) return;
        if (_ids.has(node.id)) {
            _ids.delete(node.id);
        } else {
            _ids.add(node.id);
        }
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Clear all selection
     */
    function clear() {
        _ids.clear();
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Maybe clear selection (with marquee debounce)
     */
    function maybeClear() {
        const now = Date.now();
        if (_marqueeActive) return;
        if (now - _lastMarqueeEndTs < 250) return;
        clear();
    }

    /**
     * Add nodes to selection
     */
    function add(ids) {
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Remove nodes from selection
     */
    function remove(ids) {
        (ids || []).forEach(id => {
            _ids.delete(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    // =========================================================================
    // OKLCH COLOR UTILITIES
    // =========================================================================

    function _oklchToHex(L, C, H) {
        const hRad = H * Math.PI / 180;
        const a = C * Math.cos(hRad);
        const b = C * Math.sin(hRad);

        const l_ = L / 100 + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L / 100 - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L / 100 - 0.0894841775 * a - 1.2914855480 * b;

        const l = l_ * l_ * l_;
        const m = m_ * m_ * m_;
        const s = s_ * s_ * s_;

        let rLin = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
        let gLin = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
        let bLin = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

        const gamma = x => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;

        let rOut = Math.round(gamma(rLin) * 255);
        let gOut = Math.round(gamma(gLin) * 255);
        let bOut = Math.round(gamma(bLin) * 255);

        rOut = Math.max(0, Math.min(255, rOut));
        gOut = Math.max(0, Math.min(255, gOut));
        bOut = Math.max(0, Math.min(255, bOut));

        return '#' + [rOut, gOut, bOut].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function _dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // =========================================================================
    // PENDULUM ANIMATION
    // =========================================================================

    function _updatePendulums(dt) {
        const PENDULUM = CORE.PENDULUM;
        const p1 = PENDULUM.hue;
        const p2 = PENDULUM.chroma;

        // Pendulum 1: Modulates hue rotation speed
        const accel1 = -(p1.gravity / p1.length) * Math.sin(p1.angle);
        p1.velocity += accel1 * dt;
        p1.velocity *= p1.damping;
        p1.angle += p1.velocity * dt;

        // Continuous hue rotation
        const speedMod = 1 + Math.sin(p1.angle) * 0.5;
        PENDULUM.currentHue = (PENDULUM.currentHue + p1.rotationSpeed * speedMod * (dt / 16)) % 360;

        // Pendulum 2: Chroma with coupling
        const coupling = 0.00015 * Math.sin(p1.angle);
        const accel2 = -(p2.gravity / p2.length) * Math.sin(p2.angle) + coupling;
        p2.velocity += accel2 * dt;
        p2.velocity *= p2.damping;
        p2.angle += p2.velocity * dt;

        // Lightness phase
        PENDULUM.lightness.phase += PENDULUM.lightness.speed * dt;
    }

    function _getSelectionColor(phaseOffset = 0) {
        const PENDULUM = CORE.PENDULUM;
        const p2 = PENDULUM.chroma;
        const p3 = PENDULUM.lightness;

        const H = (PENDULUM.currentHue + phaseOffset * 45) % 360;
        const C = Math.max(0.18, p2.center + Math.sin(p2.angle + phaseOffset * Math.PI * 2) * p2.amplitude);
        const L = p3.center + Math.sin(p3.phase + phaseOffset * Math.PI * 4) * p3.amplitude;

        return _oklchToHex(L, C, H);
    }

    function _getNodeSpatialPhase(node) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const distance = Math.sqrt(x * x + y * y + z * z);
        const PENDULUM = CORE.PENDULUM;
        const scale = PENDULUM.ripple ? (PENDULUM.ripple.scale || 200) : 200;
        const ripplePhase = (distance / scale) % 1;

        const angle = Math.atan2(y, x);
        const angularOffset = Math.sin(angle * 3) * 0.1;

        return (ripplePhase + angularOffset + 1) % 1;
    }

    function _animateSelectionColors(timestamp) {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) return;

        const dt = PENDULUM.lastTime ? Math.min(timestamp - PENDULUM.lastTime, 50) : 16;
        PENDULUM.lastTime = timestamp;

        _updatePendulums(dt);

        if (_ids.size > 0 && typeof Graph !== 'undefined' && Graph?.graphData) {
            const nodes = Graph.graphData().nodes || [];

            nodes.forEach(node => {
                if (_ids.has(node.id)) {
                    const spatialPhase = _getNodeSpatialPhase(node);
                    node.color = _getSelectionColor(spatialPhase);
                }
            });

            if (typeof toColorNumber === 'function') {
                Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
            }
        }

        requestAnimationFrame(_animateSelectionColors);
    }

    function startAnimation() {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) {
            PENDULUM.running = true;
            PENDULUM.hue.velocity = 0.02 + Math.random() * 0.01;
            PENDULUM.chroma.velocity = 0.015 + Math.random() * 0.01;
            PENDULUM.lastTime = 0;
            requestAnimationFrame(_animateSelectionColors);
        }
    }

    function stopAnimation() {
        CORE.PENDULUM.running = false;
    }

    // =========================================================================
    // VISUAL UPDATES
    // =========================================================================

    function _updateVisuals() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;

        const nodes = Graph.graphData().nodes || [];
        const hasSelection = _ids.size > 0;
        const SELECTION_SIZE_MULT = CORE.SELECTION_SIZE_MULT;

        nodes.forEach(node => {
            const isSelected = _ids.has(node.id);

            // Save original for restoration
            if (hasSelection && !_originalColorsForDim.has(node.id)) {
                _originalColorsForDim.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            if (isSelected && !_selectionOriginals.has(node.id)) {
                _selectionOriginals.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            // Apply styling
            if (hasSelection) {
                if (isSelected) {
                    const orig = _selectionOriginals.get(node.id);
                    node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
                } else {
                    const orig = _originalColorsForDim.get(node.id);
                    if (orig) {
                        node.color = _dimColor(orig.color, 0.5);
                        node.val = orig.val * 0.7;
                    }
                }
            } else {
                // Restore originals
                const orig = _originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = orig.color;
                    node.val = orig.val;
                }
            }

            // Update halo visibility
            if (node.__selectionHalo) {
                node.__selectionHalo.visible = isSelected;
            }
        });

        // Handle animation state
        if (hasSelection) {
            startAnimation();
        } else {
            stopAnimation();
            _selectionOriginals.clear();
            _originalColorsForDim.clear();
        }

        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (Graph) {
            REFRESH.throttled();
        }
    }

    function _updatePanel() {
        if (typeof updateSelectionPanel === 'function') {
            updateSelectionPanel();
        }
    }

    function _updateGroupButtonState() {
        if (typeof updateGroupButtonState === 'function') {
            updateGroupButtonState();
        }
    }

    // =========================================================================
    // NODE OVERLAYS (3D halos)
    // =========================================================================

    function ensureOverlays(node) {
        if (!node) return null;
        if (node.__overlayGroup) return node.__overlayGroup;

        // Lazy init geometry
        if (!_selectionHaloGeometry) {
            _selectionHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
            _groupHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
        }

        const group = new THREE.Group();

        const selectionMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
        });
        const selectionHalo = new THREE.Mesh(_selectionHaloGeometry, selectionMaterial);
        selectionHalo.visible = false;
        selectionHalo.renderOrder = 3;

        const groupMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.45,
            depthWrite: false
        });
        const groupHalo = new THREE.Mesh(_groupHaloGeometry, groupMaterial);
        groupHalo.visible = false;
        groupHalo.renderOrder = 2;

        group.add(selectionHalo);
        group.add(groupHalo);

        node.__selectionHalo = selectionHalo;
        node.__groupHalo = groupHalo;
        node.__overlayGroup = group;

        return group;
    }

    function updateOverlayScale(node) {
        const APPEARANCE_STATE = typeof window !== 'undefined' ? window.APPEARANCE_STATE : { nodeScale: 1 };
        const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE?.nodeScale || 1));
        const selectionScale = base * 2.5;
        const groupScale = base * 1.8;

        if (node.__selectionHalo) {
            node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
        }
        if (node.__groupHalo) {
            node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
        }
    }

    // =========================================================================
    // MARQUEE STATE
    // =========================================================================

    function setMarqueeActive(active) {
        _marqueeActive = active;
        if (!active) {
            _lastMarqueeEndTs = Date.now();
        }
    }

    function setMarqueeStart(pos) {
        _marqueeStart = pos;
    }

    function setMarqueeAdditive(additive) {
        _marqueeAdditive = additive;
    }

    // =========================================================================
    // UI HELPERS
    // =========================================================================

    function formatCountList(items, limit = 4) {
        return items.slice(0, limit).map(([key, count]) => `${key} ${count}`).join(' · ') || '--';
    }

    function appendSelectionRow(container, label, value) {
        const row = document.createElement('div');
        row.className = 'selection-row';
        const labelEl = document.createElement('span');
        labelEl.className = 'label';
        labelEl.textContent = label;
        const valueEl = document.createElement('span');
        valueEl.textContent = value || '--';
        row.appendChild(labelEl);
        row.appendChild(valueEl);
        container.appendChild(row);
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel() {
        const panel = document.getElementById('selection-panel');
        const body = document.getElementById('selection-body');
        const title = document.getElementById('selection-title');
        if (!panel || !body) return;

        const nodes = getSelectedNodes();
        if (!nodes.length) {
            panel.classList.remove('visible');
            body.innerHTML = '';
            return;
        }

        panel.classList.add('visible');
        if (title) title.textContent = `SELECTION (${nodes.length})`;
        body.innerHTML = '';

        if (nodes.length <= 3) {
            nodes.forEach(node => {
                const item = document.createElement('div');
                item.className = 'selection-item';
                const name = document.createElement('div');
                name.className = 'selection-name';
                name.textContent = node.name || node.id || 'Unknown';
                item.appendChild(name);
                appendSelectionRow(item, 'Family', typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--');
                appendSelectionRow(item, 'Ring', typeof getNodeRing === 'function' ? getNodeRing(node) : '--');
                appendSelectionRow(item, 'Tier', typeof getNodeTier === 'function' ? getNodeTier(node) : '--');
                appendSelectionRow(item, 'Role', node.role || '--');
                const filePath = node.file_path || node.file || '';
                if (filePath) {
                    const shortPath = filePath.length > 48 ? '...' + filePath.slice(-45) : filePath;
                    appendSelectionRow(item, 'File', shortPath);
                }
                body.appendChild(item);
            });
        } else {
            const summary = document.createElement('div');
            summary.className = 'selection-summary';

            const families = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(n) : '--') : [];
            const rings = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeRing === 'function' ? getNodeRing(n) : '--') : [];
            const tiers = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeTier === 'function' ? getNodeTier(n) : '--') : [];

            const total = document.createElement('div');
            total.textContent = `Total: ${nodes.length} nodes`;
            summary.appendChild(total);

            const familyRow = document.createElement('div');
            familyRow.textContent = `Family: ${formatCountList(families)}`;
            summary.appendChild(familyRow);

            const ringRow = document.createElement('div');
            ringRow.textContent = `Ring: ${formatCountList(rings)}`;
            summary.appendChild(ringRow);

            const tierRow = document.createElement('div');
            tierRow.textContent = `Tier: ${formatCountList(tiers)}`;
            summary.appendChild(tierRow);

            const numericKeys = [
                ['tokens', 'TOKENS'],
                ['bytes', 'BYTES'],
                ['loc', 'LOC'],
                ['lines', 'LINES'],
                ['lines_of_code', 'LOC'],
                ['size', 'SIZE']
            ];
            const totals = {};
            nodes.forEach(node => {
                numericKeys.forEach(([key]) => {
                    const value = Number(node[key]);
                    if (Number.isFinite(value)) {
                        totals[key] = (totals[key] || 0) + value;
                    }
                });
            });
            numericKeys.forEach(([key, label]) => {
                if (totals[key]) {
                    const row = document.createElement('div');
                    row.textContent = `${label}: ${Math.round(totals[key])}`;
                    summary.appendChild(row);
                }
            });

            body.appendChild(summary);
        }

        if (typeof HudLayoutManager !== 'undefined' && HudLayoutManager.reflow) {
            HudLayoutManager.reflow();
        }
    }

    // =========================================================================
    // SELECTION MODAL
    // =========================================================================

    function showSelectionModal() {
        const nodes = getSelectedNodes();
        if (!nodes.length) {
            if (typeof showToast === 'function') showToast('No nodes selected');
            return;
        }

        const overlay = document.getElementById('selection-modal-overlay');
        const title = document.getElementById('selection-modal-title');
        const statsContainer = document.getElementById('selection-modal-stats');
        const body = document.getElementById('selection-modal-body');

        if (!overlay || !body) return;

        // Calculate aggregates
        let totalTokens = 0, totalBytes = 0, totalLoc = 0;
        const tierCounts = {};
        const ringCounts = {};
        const familyCounts = {};

        nodes.forEach(node => {
            totalTokens += Number(node.tokens) || 0;
            totalBytes += Number(node.bytes) || 0;
            totalLoc += Number(node.loc || node.lines || node.lines_of_code) || 0;

            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';

            tierCounts[tier] = (tierCounts[tier] || 0) + 1;
            ringCounts[ring] = (ringCounts[ring] || 0) + 1;
            familyCounts[family] = (familyCounts[family] || 0) + 1;
        });

        const maxVal = Math.max(...nodes.map(n => n.val || n.size || 1));

        title.textContent = `SELECTED NODES (${nodes.length})`;

        // Build stats bar
        statsContainer.innerHTML = '';
        const stats = [
            ['NODES', nodes.length.toLocaleString()],
            ['TOKENS', totalTokens.toLocaleString()],
            ['BYTES', totalBytes.toLocaleString()],
            ['LOC', totalLoc.toLocaleString()],
            ['TIERS', Object.keys(tierCounts).join(', ')],
            ['FAMILIES', Object.keys(familyCounts).length]
        ];
        stats.forEach(([label, value]) => {
            if (value && value !== '0') {
                const stat = document.createElement('div');
                stat.className = 'selection-modal-stat';
                stat.innerHTML = `
                    <span class="selection-modal-stat-label">${label}</span>
                    <span class="selection-modal-stat-value">${value}</span>
                `;
                statsContainer.appendChild(stat);
            }
        });

        // Build table
        const sortedNodes = [...nodes].sort((a, b) => (b.val || b.size || 1) - (a.val || a.size || 1));

        body.innerHTML = `
            <table class="selection-modal-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Tier</th>
                        <th>Ring</th>
                        <th>Family</th>
                        <th>Level</th>
                        <th>Tokens</th>
                        <th>LOC</th>
                        <th>Relevance</th>
                    </tr>
                </thead>
                <tbody id="selection-modal-tbody"></tbody>
            </table>
        `;

        const tbody = document.getElementById('selection-modal-tbody');
        sortedNodes.forEach(node => {
            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';
            const level = node.level || node.scale_level || 'L3';
            const tokens = Number(node.tokens) || '--';
            const loc = Number(node.loc || node.lines || node.lines_of_code) || '--';
            const relevance = ((node.val || node.size || 1) / maxVal * 100).toFixed(0);

            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="node-name" title="${node.name || node.id}">${node.name || node.id}</td>
                <td><span class="level-badge tier-badge">${tier}</span></td>
                <td><span class="level-badge ring-badge">${ring}</span></td>
                <td><span class="level-badge family-badge">${family}</span></td>
                <td>${level}</td>
                <td class="numeric">${typeof tokens === 'number' ? tokens.toLocaleString() : tokens}</td>
                <td class="numeric">${typeof loc === 'number' ? loc.toLocaleString() : loc}</td>
                <td>
                    <div class="relevance-bar">
                        <div class="relevance-fill" style="width: ${relevance}%"></div>
                    </div>
                </td>
            `;
            tbody.appendChild(row);
        });

        overlay.classList.add('visible');
    }

    function hideSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        if (overlay) overlay.classList.remove('visible');
    }

    function initSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        const closeBtn = document.getElementById('selection-modal-close');
        const selectionTitle = document.getElementById('selection-title');

        if (closeBtn) {
            closeBtn.addEventListener('click', hideSelectionModal);
        }

        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) hideSelectionModal();
            });
        }

        if (selectionTitle) {
            selectionTitle.style.cursor = 'pointer';
            selectionTitle.addEventListener('click', showSelectionModal);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey) {
                const activeEl = document.activeElement;
                if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
                if (getSelectedNodes().length > 0) {
                    e.preventDefault();
                    showSelectionModal();
                }
            }
            if (e.key === 'Escape') {
                hideSelectionModal();
            }
        });
    }

    // =========================================================================
    // SELECTION BOX / MARQUEE
    // =========================================================================

    let _selectionBox = null;

    function updateSelectionBox(rect) {
        if (!_selectionBox) _selectionBox = document.getElementById('selection-box');
        if (!_selectionBox) return;
        _selectionBox.style.display = 'block';
        _selectionBox.style.left = `${rect.left}px`;
        _selectionBox.style.top = `${rect.top}px`;
        _selectionBox.style.width = `${rect.width}px`;
        _selectionBox.style.height = `${rect.height}px`;
    }

    function getNodeScreenPosition(node) {
        if (typeof Graph === 'undefined' || !Graph?.camera || !node) return null;
        if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return null;
        const camera = Graph.camera();
        const vector = new THREE.Vector3(node.x, node.y, node.z || 0);
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        return { x, y };
    }

    function selectNodesInBox(rect, additive = true) {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const nodes = Graph.graphData().nodes || [];
        const selected = [];
        nodes.forEach(node => {
            const pos = getNodeScreenPosition(node);
            if (!pos) return;
            if (pos.x >= rect.left && pos.x <= rect.right &&
                pos.y >= rect.top && pos.y <= rect.bottom) {
                if (node.id) selected.push(node.id);
            }
        });
        if (selected.length) {
            set(selected, additive);
        }
    }

    function setupSelectionInteractions() {
        const clearBtn = document.getElementById('selection-clear');
        if (clearBtn) {
            clearBtn.onclick = () => clear();
        }

        const groupBtn = document.getElementById('btn-create-group');
        if (groupBtn && typeof createGroupFromSelection === 'function') {
            groupBtn.onclick = () => createGroupFromSelection();
        }

        _selectionBox = document.getElementById('selection-box');
        if (typeof Graph === 'undefined' || !Graph?.renderer || !_selectionBox) return;

        const canvas = Graph.renderer().domElement;
        if (!canvas) return;

        const onPointerDown = (e) => {
            if (e.button !== 0) return;
            if (typeof SPACE_PRESSED !== 'undefined' && SPACE_PRESSED) return;
            if (e.target !== canvas) return;
            if (typeof HOVERED_NODE !== 'undefined' && HOVERED_NODE) return;
            _marqueeActive = true;
            _marqueeAdditive = !!e.shiftKey;
            _marqueeStart = { x: e.clientX, y: e.clientY };
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, _marqueeStart) : { left: e.clientX, top: e.clientY, width: 0, height: 0 });
            if (Graph.controls()) {
                Graph.controls().enabled = false;
            }
            e.preventDefault();
        };

        const onPointerMove = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) });
        };

        const finishSelection = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            const rect = typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) };
            _selectionBox.style.display = 'none';
            const additive = _marqueeAdditive;
            _marqueeActive = false;
            _marqueeStart = null;
            _marqueeAdditive = false;
            _lastMarqueeEndTs = Date.now();
            if (Graph.controls()) {
                Graph.controls().enabled = true;
            }
            const didDrag = rect.width > 4 && rect.height > 4;
            if (didDrag) {
                selectNodesInBox(rect, additive);
            }
        };

        canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
        canvas.addEventListener('pointermove', onPointerMove, { passive: true });
        canvas.addEventListener('pointerup', finishSelection, { passive: true });
        canvas.addEventListener('pointerleave', finishSelection, { passive: true });
    }

    // =========================================================================
    // SYNC AND INIT
    // =========================================================================

    function syncSelectionAfterGraphUpdate() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const visibleIds = new Set((Graph.graphData().nodes || []).map(n => n.id));
        const idsToRemove = [];
        Array.from(_ids).forEach(id => {
            if (!visibleIds.has(id)) {
                idsToRemove.push(id);
            }
        });
        if (idsToRemove.length > 0) {
            remove(idsToRemove);
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    function initSelectionState(data) {
        if (typeof buildDatasetKey === 'function') {
            window.DATASET_KEY = buildDatasetKey(data);
            window.GROUPS_STORAGE_KEY = `collider_groups_${window.DATASET_KEY}`;
        }
        if (typeof loadGroups === 'function') loadGroups();
        if (typeof renderGroupList === 'function') renderGroupList();
        updateSelectionPanel();
        _updateGroupButtonState();
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core selection
        set,
        toggle,
        clear,
        maybeClear,
        add,
        remove,
        getSelectedNodes,

        // State access
        get ids() { return _ids; },
        get size() { return _ids.size; },
        has(id) { return _ids.has(id); },

        // Animation
        startAnimation,
        stopAnimation,

        // Overlays
        ensureOverlays,
        updateOverlayScale,

        // Marquee
        setMarqueeActive,
        setMarqueeStart,
        setMarqueeAdditive,
        get marqueeActive() { return _marqueeActive; },
        get marqueeStart() { return _marqueeStart; },
        get marqueeAdditive() { return _marqueeAdditive; },
        get lastMarqueeEndTs() { return _lastMarqueeEndTs; },

        // Internal access (for migration)
        _selectionOriginals,
        _originalColorsForDim,

        // UI (moved from app.js)
        updateSelectionPanel,
        showSelectionModal,
        hideSelectionModal,
        initSelectionModal,
        updateSelectionBox,
        getNodeScreenPosition,
        selectNodesInBox,
        setupSelectionInteractions,
        syncSelectionAfterGraphUpdate,
        initSelectionState
    };
})();

// Backward compatibility aliases - Using getters to ensure live updates
// Note: All variables use Object.defineProperty to avoid duplicate declarations with app.js
// SELECTED_NODE_IDS - selection.js is now the SINGLE SOURCE OF TRUTH (unified in modularization)
Object.defineProperty(window, 'SELECTED_NODE_IDS', { get: () => SELECT.ids, configurable: true });
Object.defineProperty(window, 'MARQUEE_ACTIVE', { get: () => SELECT.marqueeActive, configurable: true });
Object.defineProperty(window, 'MARQUEE_START', { get: () => SELECT.marqueeStart, configurable: true });
Object.defineProperty(window, 'MARQUEE_ADDITIVE', { get: () => SELECT.marqueeAdditive, configurable: true });
Object.defineProperty(window, 'LAST_MARQUEE_END_TS', { get: () => SELECT.lastMarqueeEndTs, configurable: true });
// selectionOriginals, originalColorsForDim - app.js owns these, not duplicated here

function getSelectedNodes() { return SELECT.getSelectedNodes(); }
function setSelection(ids, additive) { SELECT.set(ids, additive); }
function toggleSelection(node) { SELECT.toggle(node); }
function clearSelection() { SELECT.clear(); }
function maybeClearSelection() { SELECT.maybeClear(); }
function startSelectionAnimation() { SELECT.startAnimation(); }
function stopSelectionAnimation() { SELECT.stopAnimation(); }
function ensureNodeOverlays(node) { return SELECT.ensureOverlays(node); }
function updateOverlayScale(node) { SELECT.updateOverlayScale(node); }

// UI functions (moved from app.js)
function updateSelectionPanel() { SELECT.updateSelectionPanel(); }
function showSelectionModal() { SELECT.showSelectionModal(); }
function hideSelectionModal() { SELECT.hideSelectionModal(); }
function initSelectionModal() { SELECT.initSelectionModal(); }
function updateSelectionBox(rect) { SELECT.updateSelectionBox(rect); }
function getNodeScreenPosition(node) { return SELECT.getNodeScreenPosition(node); }
function selectNodesInBox(rect, additive) { SELECT.selectNodesInBox(rect, additive); }
function setupSelectionInteractions() { SELECT.setupSelectionInteractions(); }
function syncSelectionAfterGraphUpdate() { SELECT.syncSelectionAfterGraphUpdate(); }
function initSelectionState(data) { SELECT.initSelectionState(data); }

console.log('[Module] SELECT loaded - selection UI, modal, marquee, animation');


// ═══ MODULE: modules/panels.js ═══
/**
 * PANELS MODULE
 *
 * Manages floating panels and HUD layout for the visualization.
 * Handles panel open/close, command bar, and UI dimming.
 *
 * Usage:
 *   PANELS.open('view')       // Open a panel
 *   PANELS.close('view')      // Close a panel
 *   PANELS.toggle('view')     // Toggle panel visibility
 *   PANELS.initCommandBar()   // Wire up command bar buttons
 */

const PANELS = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _activePanelId = null;

    // =========================================================================
    // PANEL FUNCTIONS
    // =========================================================================

    /**
     * Open a panel by ID
     */
    function open(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        // Close any already-open panel
        if (_activePanelId && _activePanelId !== panelId) {
            close(_activePanelId);
        }

        if (panel) {
            panel.classList.add('visible');
            setTimeout(() => { panel.style.opacity = '1'; }, 10);
        }
        if (btn) btn.classList.add('active');
        _activePanelId = panelId;

        // Dim the universe when panel opens
        document.body.classList.add('ui-active');

        // Dim starfield via JS
        if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
            const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
            STARFIELD.material.opacity = baseOpacity * 0.3;
        }
    }

    /**
     * Close a panel by ID
     */
    function close(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        if (panel) {
            panel.classList.remove('visible');
        }
        if (btn) btn.classList.remove('active');
        if (_activePanelId === panelId) _activePanelId = null;

        // Restore universe when all panels closed
        if (!_activePanelId) {
            document.body.classList.remove('ui-active');

            // Restore starfield
            if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
                const starsBtn = document.getElementById('btn-stars');
                const starsVisible = starsBtn && starsBtn.classList.contains('active');
                const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
                STARFIELD.material.opacity = starsVisible ? baseOpacity : 0;
            }
        }
    }

    /**
     * Toggle a panel
     */
    function toggle(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        if (panel && panel.classList.contains('visible')) {
            close(panelId);
        } else {
            open(panelId);
        }
    }

    /**
     * Get active panel ID
     */
    function getActive() {
        return _activePanelId;
    }

    // =========================================================================
    // COMMAND BAR INITIALIZATION
    // =========================================================================

    function initCommandBar() {
        const cmdBtns = {
            'cmd-view': 'view',
            'cmd-filter': 'filter',
            'cmd-style': 'style',
            'cmd-settings': 'settings'
        };

        Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', () => toggle(panelId));
            }
        });

        // Settings panel: Oval margin slider
        _initOvalMarginSlider();
        _initOvalDebugToggle();

        // Style panel sliders (consolidated from app.js)
        _initStylePanelSliders();
        _initToggleSwitches();
        _initSegmentedControls();
        _initCommandBarActions();
    }

    // ═══════════════════════════════════════════════════════════════════
    // STYLE PANEL SLIDERS - Connected to appearance system
    // ═══════════════════════════════════════════════════════════════════

    function _initStylePanelSliders() {
        // Node Size Slider
        const nodeSizeSlider = document.getElementById('node-size-slider');
        const nodeSizeValue = document.getElementById('node-size-value');
        if (nodeSizeSlider) {
            nodeSizeSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (nodeSizeValue) nodeSizeValue.textContent = val.toFixed(1) + 'x';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.nodeVal(node => (node.val || node.size || 1) * val);
                }
            });
        }

        // Edge Opacity Slider
        const edgeOpacitySlider = document.getElementById('edge-opacity-slider');
        const edgeOpacityValue = document.getElementById('edge-opacity-value');
        if (edgeOpacitySlider) {
            edgeOpacitySlider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (edgeOpacityValue) edgeOpacityValue.textContent = val + '%';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val / 100;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
            });
        }

        // Density Slider (filter panel) - NOTE: #density-slider2 not in current HTML template
        // Code retained for future filter panel implementation
        const densitySlider2 = document.getElementById('density-slider2');
        const densityValue2 = document.getElementById('density-value2');
        if (densitySlider2) {
            densitySlider2.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (densityValue2) densityValue2.textContent = val + '%';
                if (typeof CURRENT_DENSITY !== 'undefined') window.CURRENT_DENSITY = val;
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        }
    }

    function _initToggleSwitches() {
        document.querySelectorAll('.toggle-switch').forEach(toggle => {
            toggle.addEventListener('click', () => {
                toggle.classList.toggle('active');
            });
        });
    }

    function _initSegmentedControls() {
        document.querySelectorAll('.segmented-control').forEach(control => {
            control.querySelectorAll('.segment').forEach(segment => {
                segment.addEventListener('click', () => {
                    control.querySelectorAll('.segment').forEach(s => s.classList.remove('active'));
                    segment.classList.add('active');

                    // Handle dimension change
                    if (control.id === 'dim-control') {
                        const dim = segment.dataset.dim;
                        if (typeof IS_3D !== 'undefined') {
                            window.IS_3D = (dim !== '2');
                            if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                        }
                    }

                    // Handle node color mode
                    if (control.id === 'node-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode && typeof setNodeColorMode === 'function') {
                            setNodeColorMode(mode);
                        }
                    }

                    // Handle edge color mode
                    if (control.id === 'edge-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode) {
                            if (typeof EDGE_MODE !== 'undefined') window.EDGE_MODE = mode;
                            if (typeof applyEdgeMode === 'function') applyEdgeMode();
                        }
                    }

                    // Handle panel layout
                    if (control.id === 'layout-control') {
                        const layout = segment.dataset.layout;
                        if (layout) {
                            document.body.setAttribute('data-layout', layout);
                        }
                    }
                });
            });
        });
    }

    function _initCommandBarActions() {
        // Skip if REGISTRY not available (defensive)
        if (typeof REGISTRY === 'undefined' || !REGISTRY.register) return;

        // File mode toggle
        REGISTRY.register('cmd-files2', () => {
            if (typeof setFileModeState === 'function') {
                const newState = typeof fileMode !== 'undefined' ? !fileMode : true;
                setFileModeState(newState);
                const btn = document.getElementById('cmd-files2');
                if (btn) btn.classList.toggle('active', newState);
            }
        }, { desc: 'Toggle File Boundaries Mode' });

        // Flow mode toggle
        REGISTRY.register('cmd-flow2', () => {
            if (typeof toggleFlowMode === 'function') {
                toggleFlowMode();
                const btn = document.getElementById('cmd-flow2');
                if (btn && typeof flowMode !== 'undefined') btn.classList.toggle('active', flowMode);
            }
        }, { desc: 'Toggle Flow Mode' });

        // 3D toggle
        REGISTRY.register('cmd-3d', () => {
            if (typeof toggleDimensions === 'function') {
                toggleDimensions();
            } else if (typeof IS_3D !== 'undefined') {
                window.IS_3D = !window.IS_3D;
                if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                const btnDim = document.getElementById('btn-dimensions');
                if (btnDim) btnDim.textContent = window.IS_3D ? '2D' : '3D';
            }
            const btn = document.getElementById('cmd-3d');
            if (btn && typeof IS_3D !== 'undefined') btn.classList.toggle('active', window.IS_3D);

            // Update dim-control if exists
            const dimControl = document.getElementById('dim-control');
            if (dimControl && typeof IS_3D !== 'undefined') {
                dimControl.querySelectorAll('.segment').forEach(s => {
                    s.classList.toggle('active', s.dataset.dim === (window.IS_3D ? '3' : '2'));
                });
            }
        }, { desc: 'Toggle 2D/3D View' });

        console.log('[PANELS] Command bar actions registered');
    }

    function _initOvalMarginSlider() {
        const ovalSlider = document.getElementById('oval-margin-slider');
        const ovalValue = document.getElementById('oval-margin-value');
        let ovalDebounceTimer = null;

        if (ovalSlider) {
            ovalSlider.addEventListener('input', (e) => {
                if (ovalValue) ovalValue.textContent = e.target.value + '%';
            });

            const applyOvalMargin = () => {
                clearTimeout(ovalDebounceTimer);
                ovalDebounceTimer = setTimeout(() => {
                    const val = ovalSlider.value;
                    document.documentElement.style.setProperty('--oval-margin', val + '%');
                }, 300);
            };

            ovalSlider.addEventListener('mouseup', applyOvalMargin);
            ovalSlider.addEventListener('touchend', applyOvalMargin);
            ovalSlider.addEventListener('change', applyOvalMargin);
        }
    }

    function _initOvalDebugToggle() {
        const toggleOvalDebug = document.getElementById('toggle-oval-debug');
        if (toggleOvalDebug) {
            toggleOvalDebug.addEventListener('click', () => {
                toggleOvalDebug.classList.toggle('active');
                const ovalDebug = document.querySelector('.oval-debug');
                if (ovalDebug) {
                    ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
                }
            });
        }
    }

    // =========================================================================
    // HUD LAYOUT MANAGER - REMOVED, USE LAYOUT MODULE
    // =========================================================================
    // The HudLayoutManager has been unified into modules/layout.js
    // Use LAYOUT.reflow() instead of PANELS.HudLayoutManager.reflow()

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        open,
        close,
        toggle,
        getActive,
        initCommandBar,

        // State access
        get activePanelId() { return _activePanelId; }
    };
})();

// Backward compatibility - _activePanelId is managed by app.js
function openPanel(panelId) { PANELS.open(panelId); }
function closePanel(panelId) { PANELS.close(panelId); }
function togglePanel(panelId) { PANELS.toggle(panelId); }
function initCommandBar() { PANELS.initCommandBar(); }
// HudLayoutManager - app.js owns this, not duplicated here

// ════════════════════════════════════════════════════════════════════════
// PANEL DRAG & RESIZE - Make panels movable and resizable
// ════════════════════════════════════════════════════════════════════════

const PANEL_DRAG = (function() {
    'use strict';

    const _panels = new Map();
    let _dragState = null;
    let _resizeState = null;
    const STORAGE_KEY = 'collider-panel-positions';

    function init() {
        // Initialize draggable/resizable panels (use actual element IDs)
        initPanel('side-dock', { draggable: true, resizable: true, minWidth: 150, maxWidth: 400 });
        initPanel('header-panel', { draggable: true, resizable: false });
        initPanel('stats-panel', { draggable: true, resizable: false });
        initPanel('metrics-panel', { draggable: true, resizable: true, minWidth: 180, maxWidth: 350 });

        // Restore saved positions
        restorePositions();

        // Global mouse handlers
        document.addEventListener('mousemove', (e) => _onMouseMove(e));
        document.addEventListener('mouseup', (e) => _onMouseUp(e));
    }

    function initPanel(id, options = {}) {
        const panel = document.getElementById(id) || document.querySelector('.' + id);
        if (!panel) return;

        const config = {
            el: panel,
            id: id,
            draggable: options.draggable !== false,
            resizable: options.resizable === true,
            minWidth: options.minWidth || 100,
            maxWidth: options.maxWidth || 600,
            minHeight: options.minHeight || 50,
            maxHeight: options.maxHeight || window.innerHeight - 100
        };

        _panels.set(id, config);

        // Make panel positioned if not already
        const style = window.getComputedStyle(panel);
        if (style.position === 'static') {
            panel.style.position = 'absolute';
        }

        // Add drag handle (the panel header or title)
        if (config.draggable) {
            const header = panel.querySelector('.side-title, .hud-title, .panel-header') || panel;
            header.style.cursor = 'move';
            header.addEventListener('mousedown', (e) => _startDrag(e, id));
        }

        // Add resize handle
        if (config.resizable) {
            const handle = document.createElement('div');
            handle.className = 'panel-resize-handle';
            handle.addEventListener('mousedown', (e) => _startResize(e, id));
            panel.appendChild(handle);
            panel.style.position = 'absolute';
        }
    }

    function _startDrag(e, panelId) {
        // Don't drag if clicking on interactive elements
        if (e.target.closest('input, button, select, .collapsible-content, .preset-btn, .layout-btn, .scheme-btn')) {
            return;
        }

        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        const rect = config.el.getBoundingClientRect();

        _dragState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startLeft: rect.left,
            startTop: rect.top
        };

        config.el.classList.add('panel-dragging');
    }

    function _startResize(e, panelId) {
        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        e.stopPropagation();

        const rect = config.el.getBoundingClientRect();

        _resizeState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startWidth: rect.width,
            startHeight: rect.height
        };

        config.el.classList.add('panel-resizing');
    }

    function _onMouseMove(e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (!config) return;

            const dx = e.clientX - _dragState.startX;
            const dy = e.clientY - _dragState.startY;

            let newLeft = _dragState.startLeft + dx;
            let newTop = _dragState.startTop + dy;

            // Keep within viewport
            newLeft = Math.max(0, Math.min(window.innerWidth - 50, newLeft));
            newTop = Math.max(0, Math.min(window.innerHeight - 50, newTop));

            config.el.style.left = newLeft + 'px';
            config.el.style.top = newTop + 'px';
            config.el.style.right = 'auto';
            config.el.style.bottom = 'auto';
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (!config) return;

            const dx = e.clientX - _resizeState.startX;
            const dy = e.clientY - _resizeState.startY;

            let newWidth = _resizeState.startWidth + dx;
            let newHeight = _resizeState.startHeight + dy;

            // Apply constraints
            newWidth = Math.max(config.minWidth, Math.min(config.maxWidth, newWidth));
            newHeight = Math.max(config.minHeight, Math.min(config.maxHeight, newHeight));

            config.el.style.width = newWidth + 'px';
            // Only resize height for certain panels
            if (config.el.classList.contains('side-dock') || config.el.classList.contains('side-content')) {
                // Don't change height for sidebar - it's auto
            } else {
                config.el.style.height = newHeight + 'px';
            }
        }
    }

    function _onMouseUp(_e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (config) {
                config.el.classList.remove('panel-dragging');
                savePositions();
            }
            _dragState = null;
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (config) {
                config.el.classList.remove('panel-resizing');
                savePositions();
            }
            _resizeState = null;
        }
    }

    function savePositions() {
        const positions = {};
        _panels.forEach((config, id) => {
            const rect = config.el.getBoundingClientRect();
            const style = config.el.style;
            positions[id] = {
                left: style.left || rect.left + 'px',
                top: style.top || rect.top + 'px',
                width: style.width || null,
                height: style.height || null
            };
        });
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not save positions:', e);
        }
    }

    function restorePositions() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;

            const positions = JSON.parse(saved);
            Object.entries(positions).forEach(([id, pos]) => {
                const config = _panels.get(id);
                if (!config) return;

                if (pos.left) config.el.style.left = pos.left;
                if (pos.top) config.el.style.top = pos.top;
                if (pos.width) config.el.style.width = pos.width;
                if (pos.height) config.el.style.height = pos.height;

                // Clear right/bottom if we're setting left/top
                if (pos.left) config.el.style.right = 'auto';
                if (pos.top) config.el.style.bottom = 'auto';
            });
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not restore positions:', e);
        }
    }

    function resetPositions() {
        try {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not reset positions:', e);
        }
    }

    return {
        init,
        initPanel,
        savePositions,
        restorePositions,
        resetPositions,
        get panels() { return _panels; }
    };
})();

// Backward compatibility wrapper
const PanelManager = {
    panels: PANEL_DRAG.panels,
    init() { PANEL_DRAG.init(); },
    initPanel(id, opts) { PANEL_DRAG.initPanel(id, opts); },
    savePositions() { PANEL_DRAG.savePositions(); },
    restorePositions() { PANEL_DRAG.restorePositions(); },
    resetPositions() { PANEL_DRAG.resetPositions(); }
};

// Initialize after DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => PANEL_DRAG.init());
} else {
    setTimeout(() => PANEL_DRAG.init(), 100);
}

// Expose globally
window.PANEL_DRAG = PANEL_DRAG;
window.PanelManager = PanelManager;


// ═══ MODULE: modules/sidebar.js ═══
/**
 * SIDEBAR MODULE
 *
 * Manages sidebar controls including color presets, layout presets,
 * physics controls, appearance controls, filters, and panel updates.
 *
 * Depends on: ANIM (for layouts), REFRESH (for throttled updates)
 *
 * Usage:
 *   SIDEBAR.init()                         // Initialize after DOM ready
 *   SIDEBAR.setColorMode('tier')           // Change color mode
 *   SIDEBAR.setLayout('force')             // Change layout
 *   SIDEBAR.setPhysicsPreset('tight')      // Apply physics preset
 *   SIDEBAR.updateStats(nodes, edges)      // Update stat displays
 */

// Note: Using window assignment instead of const to avoid duplicate declaration with app.js
window.SIDEBAR = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _refreshTimer = null;
    let _bound = false;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    /**
     * Initialize sidebar - call after DOM is ready
     */
    function init() {
        if (_bound) return;
        _bound = true;

        // Initialize unified state manager first
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.init();
        }

        _bindSectionHeaders();
        _bindColorPresets();
        _bindLayoutPresets();
        _bindPhysicsControls();
        _bindAppearanceControls();
        _bindActionButtons();
        initSchemeNavigator();
        initViewModeToggle();
        initSectionResize();   // Enable vertical section resizing
        initSidebarResize();   // Enable horizontal sidebar resizing

        // Sync UI to initial state
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.syncUIFromState();
        }

        console.log('[SIDEBAR] Initialized');
    }

    // =========================================================================
    // SECTION COLLAPSE/EXPAND
    // =========================================================================

    function _bindSectionHeaders() {
        document.querySelectorAll('.section-header[data-section]').forEach(header => {
            header.addEventListener('click', () => {
                const sectionId = header.dataset.section;
                const content = document.getElementById(`section-${sectionId}`);
                if (!content) return;

                const isCollapsed = header.classList.toggle('collapsed');
                content.classList.toggle('collapsed', isCollapsed);
            });
        });
    }

    // =========================================================================
    // COLOR PRESETS (TIER, FAMILY, LAYER, RING, FILE, FLOW)
    // =========================================================================

    // =========================================================================
    // COLOR PRESETS: SMART SIDEBAR CONFIGURATION
    // =========================================================================

    const PRESET_CONFIG = [
        {
            category: 'Architecture',
            presets: [
                { id: 'tier', label: 'Tier', desc: 'Auto-detected architectural height' },
                { id: 'layer', label: 'Layer', desc: 'Business logic strata' },
                { id: 'subsystem', label: 'Subsystem', desc: 'Functional domain grouping' },
                { id: 'boundary_score', label: 'Boundary', desc: 'Internal vs External (1-9)' },
                { id: 'phase', label: 'Phase', desc: 'Data-Logic-Org-Exec (MIPO)' }
            ]
        },
        {
            category: 'Taxonomy',
            presets: [
                { id: 'atom', label: 'Atom', desc: 'Function, Class, Module types' },
                { id: 'family', label: 'Family', desc: 'Logic, Data, Execution' },
                { id: 'role', label: 'Role', desc: 'Service, Repo, Controller' },
                { id: 'roleCategory', label: 'Role Cat', desc: 'Query, Command, Event' },
                { id: 'fileType', label: 'File Type', desc: 'Extension-based coloring' }
            ]
        },
        {
            category: 'Metrics',
            presets: [
                { id: 'complexity', label: 'Complexity', desc: 'Cyclomatic complexity' },
                { id: 'loc', label: 'LOC', desc: 'Lines of Code' },
                { id: 'fan_in', label: 'Fan-In', desc: 'Incoming dependencies' },
                { id: 'fan_out', label: 'Fan-Out', desc: 'Outgoing dependencies' },
                { id: 'trust', label: 'Trust', desc: 'Detection confidence' }
            ]
        },
        {
            category: 'RPBL DNA',
            presets: [
                { id: 'responsibility', label: 'Responsibility', desc: 'SRP alignment (1-9)' },
                { id: 'purity', label: 'Purity', desc: 'Side-effect profile (1-9)' },
                { id: 'lifecycle_score', label: 'Lifecycle', desc: 'Static vs Dynamic (1-9)' },
                { id: 'state', label: 'State', desc: 'Stateful vs Stateless' },
                { id: 'visibility', label: 'Visibility', desc: 'Public vs Private' }
            ]
        },
        {
            category: 'Topology',
            presets: [
                { id: 'centrality', label: 'Centrality', desc: 'Graph importance' },
                { id: 'rank', label: 'PageRank', desc: 'Algorithmic influence' }, // mapped to centrality logic or similar
                { id: 'ring', label: 'Ring', desc: 'Concentric architecture rings' },
                { id: 'flow', label: 'Flow', desc: 'Dependency direction' }
            ]
        },
        {
            category: 'Evolution',
            presets: [
                { id: 'churn', label: 'Churn', desc: 'Change frequency (Simulated)' },
                { id: 'age', label: 'Age', desc: 'Time since creation (Simulated)' }
            ]
        }
    ];

    // =========================================================================
    // SCHEME NAVIGATOR: 33 Named Color Schemes
    // =========================================================================

    const SCHEME_CONFIG = [
        // PART A: Famous Scientific (15)
        { category: 'Sequential', schemes: ['viridis', 'plasma', 'magma', 'inferno', 'cividis', 'turbo', 'mako', 'rocket'] },
        { category: 'Diverging', schemes: ['coolwarm', 'spectral'] },
        { category: 'Thematic', schemes: ['thermal', 'nightvision', 'ocean', 'terrain', 'electric'] },

        // PART B: Role-Semantic (18 key roles)
        { category: 'Access', schemes: ['query', 'finder'] },
        { category: 'Mutation', schemes: ['command', 'creator', 'destroyer'] },
        { category: 'Construction', schemes: ['factory'] },
        { category: 'Storage', schemes: ['repository', 'cache'] },
        { category: 'Control', schemes: ['service', 'orchestrator'] },
        { category: 'Validation', schemes: ['validator', 'guard'] },
        { category: 'Transform', schemes: ['transformer', 'parser'] },
        { category: 'Events', schemes: ['handler', 'emitter'] },
        { category: 'Support', schemes: ['utility', 'lifecycle'] },

        // PART C: OKLCH Geometry (Mathematical paths through color space)
        { category: 'Loops', schemes: ['rainbow-loop', 'rainbow-bright', 'rainbow-dark'] },
        { category: 'Arcs', schemes: ['arc-warm', 'arc-cool', 'arc-nature'] },
        { category: 'Spirals', schemes: ['spiral-up', 'spiral-down', 'spiral-chroma'] },
        { category: 'Waves', schemes: ['wave-lightness', 'wave-chroma', 'pulse'] },
        { category: 'Ramps', schemes: ['ramp-hue', 'ramp-lightness', 'ramp-chroma'] },
        { category: 'Paths', schemes: ['helix', 'convergent', 'divergent', 'bicone'] }
    ];

    function _bindColorPresets() {
        // Init Smart Sidebar
        const container = document.getElementById('section-color');
        if (!container) return;

        // Clear existing static buttons if any (except header)
        const contentDiv = container.querySelector('.section-content');
        if (contentDiv) {
            contentDiv.innerHTML = ''; // Rebuild from scratch
            renderSmartSidebar(contentDiv);
        }
    }

    function renderSmartSidebar(container) {
        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Presets...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.preset-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.btn').forEach(btn => {
                    const match = btn.textContent.toLowerCase().includes(term) || btn.title.toLowerCase().includes(term);
                    btn.style.display = match ? 'block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        searchContainer.appendChild(searchInput);
        container.appendChild(searchContainer);

        // Render Categories
        PRESET_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'preset-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'btn-grid btn-grid-3'; // Default to 3-col

            section.presets.forEach(p => {
                const btn = document.createElement('button');
                btn.className = 'btn color-btn';
                btn.textContent = p.label;
                btn.title = p.desc;
                btn.dataset.preset = p.id;

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    setColorMode(p.id);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    // =========================================================================
    // SCHEME NAVIGATOR RENDERER
    // =========================================================================

    function renderSchemeNavigator(container) {
        if (!container) return;
        container.innerHTML = '';

        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Schemes...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.scheme-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.scheme-btn').forEach(btn => {
                    const match = btn.dataset.scheme.toLowerCase().includes(term) ||
                        (btn.title && btn.title.toLowerCase().includes(term));
                    btn.style.display = match ? 'inline-block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear';
        clearBtn.title = 'Remove scheme, use default colors';
        clearBtn.style.cssText = 'margin-left: 8px; padding: 4px 8px; font-size: 9px; background: rgba(255,100,100,0.2); border: 1px solid rgba(255,100,100,0.3); color: var(--text); border-radius: 4px; cursor: pointer;';
        clearBtn.addEventListener('click', clearColorScheme);

        searchContainer.appendChild(searchInput);
        searchContainer.appendChild(clearBtn);
        container.appendChild(searchContainer);

        // Render Categories
        SCHEME_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'scheme-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'scheme-grid';
            grid.style.cssText = 'display: flex; flex-wrap: wrap; gap: 4px;';

            section.schemes.forEach(schemeName => {
                const btn = document.createElement('button');
                btn.className = 'scheme-btn';
                btn.dataset.scheme = schemeName;

                // Get scheme info from COLOR engine
                let info = { name: schemeName, semantic: '' };
                if (typeof COLOR !== 'undefined' && COLOR.getSchemeInfo) {
                    info = COLOR.getSchemeInfo(schemeName);
                }

                btn.title = info.semantic || schemeName;

                // Create clean color swatches (5 stops) instead of ugly gradient
                const swatchContainer = document.createElement('div');
                swatchContainer.className = 'scheme-swatches';

                if (typeof COLOR !== 'undefined' && COLOR.getSchemeColor) {
                    // Sample 5 colors from the scheme path
                    [0, 0.25, 0.5, 0.75, 1].forEach(t => {
                        const swatch = document.createElement('span');
                        swatch.className = 'scheme-swatch';
                        swatch.style.backgroundColor = COLOR.getSchemeColor(schemeName, t);
                        swatchContainer.appendChild(swatch);
                    });
                }

                btn.appendChild(swatchContainer);

                // Label below swatches
                const label = document.createElement('span');
                label.className = 'scheme-label';
                label.textContent = info.name;
                btn.appendChild(label);

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    applyColorScheme(schemeName);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    /**
     * Apply a named color scheme (palette)
     *
     * NEW BEHAVIOR (via VIS_STATE):
     * - Palette is "armed" but does NOT auto-switch colorBy mode
     * - Palette only visually applies when colorBy is an interval mode
     * - When user switches to interval mode, the armed palette becomes active
     */
    function applyColorScheme(schemeName) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(schemeName);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(schemeName);
        }

        try {
            localStorage.setItem('collider_scheme', schemeName);
        } catch (e) { /* ignore */ }

        _refreshGraphColors();
        console.log('[SIDEBAR] Applied scheme:', schemeName);
    }

    /**
     * Clear active scheme, return to default interval colors
     */
    function clearColorScheme() {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(null);
            return;
        }

        // Fallback
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(null);
        }

        try {
            localStorage.removeItem('collider_scheme');
        } catch (e) { /* ignore */ }

        document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));

        _refreshGraphColors();

        console.log('[SIDEBAR] Cleared color scheme');
    }

    /**
     * Internal: Refresh all node colors and re-render the graph
     */
    function _refreshGraphColors() {
        if (typeof Graph === 'undefined' || !Graph) return;

        // Get current nodes from DataManager or Graph
        const DM = window.DM;
        const nodes = DM ? DM.getNodes() : (Graph.graphData ? Graph.graphData().nodes : []);

        // Recompute colors using current mode
        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render
        Graph.nodeColor(Graph.nodeColor());

        // Also refresh edges if in gradient mode
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    /**
     * Initialize scheme navigator in sidebar
     */
    function initSchemeNavigator() {
        const container = document.getElementById('section-schemes');
        if (container) {
            renderSchemeNavigator(container);
        }

        // Setup collapsible header for schemes panel
        const collapsibleHeaders = document.querySelectorAll('.info-panel-header.collapsible');
        collapsibleHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    header.classList.toggle('collapsed', isCollapsed);
                }
            });
        });

        // Setup color mode buttons (for right sidebar)
        const colorBtns = document.querySelectorAll('.color-panel .color-btn');
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                if (!preset) return;

                // Apply color mode via VIS_STATE (handles UI sync)
                setColorMode(preset);
            });
        });

        // NOTE: Saved preferences are now loaded by VIS_STATE.init()
        // UI sync is handled by VIS_STATE.syncUIFromState()
    }

    // =========================================================================
    // VIEW MODE TOGGLE (ATOMS vs FILES)
    // =========================================================================

    let _currentViewMode = 'atoms';
    let _deferredViewMode = null;  // Stores mode to apply after data loads

    /**
     * Initialize the view mode toggle (Atoms vs Files)
     * Note: Only sets up event handlers and button visual state.
     * Actual mode application for 'files' is deferred until data is loaded.
     */
    function initViewModeToggle() {
        const toggle = document.getElementById('view-mode-toggle');
        if (!toggle) return;

        const buttons = toggle.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                if (!mode || mode === _currentViewMode) return;

                setViewMode(mode);
            });
        });

        // Load saved preference - but only update button state, defer actual mode switch
        try {
            const saved = localStorage.getItem('collider_view_mode');
            if (saved && (saved === 'atoms' || saved === 'files')) {
                // Update button visual state immediately
                buttons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === saved);
                });
                _currentViewMode = saved;

                // If files mode, defer application until data is loaded
                if (saved === 'files') {
                    _deferredViewMode = 'files';
                    console.log('[SIDEBAR] Files mode saved - deferring until data loads');
                }
            }
        } catch (e) { /* ignore */ }
    }

    /**
     * Apply deferred view mode after data is loaded
     * Call this from initGraph() after DM.init() completes
     */
    function applyDeferredViewMode() {
        if (_deferredViewMode === 'files') {
            console.log('[SIDEBAR] Applying deferred files mode now that data is loaded');
            _deferredViewMode = null;  // Clear to prevent re-application

            // Apply files mode (data is now available)
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
                console.log('[SIDEBAR] View mode: FILES - showing file nodes');

                if (typeof showToast === 'function') {
                    showToast('FILE VIEW: Each node is a file. Click to expand.');
                }
            }
        }
    }

    /**
     * Set the view mode (atoms or files)
     */
    function setViewMode(mode) {
        if (mode !== 'atoms' && mode !== 'files') return;
        _currentViewMode = mode;

        // Update button states
        const buttons = document.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });

        // Save preference
        try {
            localStorage.setItem('collider_view_mode', mode);
        } catch (e) { /* ignore */ }

        // Apply view mode via FILE_VIZ module
        if (mode === 'files') {
            // Switch to file-nodes view
            if (typeof FILE_VIZ !== 'undefined') {
                // Build the file graph first (required before switching mode)
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'files';
                if (typeof buildFileGraph === 'function') buildFileGraph(null);
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: FILES - showing file nodes');
        } else {
            // Switch to atoms view
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.graphMode = 'atoms';
                FILE_VIZ.setEnabled(false);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'atoms';
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: ATOMS - showing individual atoms');
        }

        // Show toast notification
        if (typeof showToast === 'function') {
            const msg = mode === 'files'
                ? 'FILE VIEW: Each node is a file. Click to expand.'
                : 'ATOM VIEW: Each node is a code element.';
            showToast(msg);
        }
    }

    /**
     * Get current view mode
     */
    function getViewMode() {
        return _currentViewMode;
    }

    function setColorMode(mode) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setColorBy(mode);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof APPEARANCE_STATE !== 'undefined') {
            APPEARANCE_STATE.colorMode = mode;
            APPEARANCE_STATE.currentPreset = mode;
        }

        if (typeof setNodeColorMode === 'function') {
            setNodeColorMode(mode);
        }

        // Handle flow mode specially
        if (mode === 'flow') {
            if (typeof flowMode !== 'undefined' && !flowMode && typeof toggleFlowMode === 'function') {
                toggleFlowMode();
            }
        } else if (typeof flowMode !== 'undefined' && flowMode && typeof disableFlowMode === 'function') {
            disableFlowMode();
        }

        if (typeof window !== 'undefined' && typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        console.log('[SIDEBAR] Color mode:', mode);
    }

    // =========================================================================
    // LAYOUT PRESETS (FORCE, RADIAL, ORBITAL, SPHERE, GRID, SPIRAL)
    // =========================================================================

    function _bindLayoutPresets() {
        const container = document.getElementById('section-layout');
        if (!container) return;

        container.querySelectorAll('.btn[data-layout]').forEach(btn => {
            btn.addEventListener('click', () => {
                const layout = btn.dataset.layout;
                setLayout(layout);

                // Update active state
                container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });
    }

    function setLayout(layout) {
        // Prefer ANIM module if available
        if (typeof ANIM !== 'undefined' && ANIM.applyLayout) {
            ANIM.applyLayout(layout, true);
        } else if (typeof applyLayoutPreset === 'function') {
            applyLayoutPreset(layout, true);
        }
        console.log('[SIDEBAR] Layout:', layout);
    }

    // =========================================================================
    // PHYSICS CONTROLS
    // =========================================================================

    const PHYSICS_PRESETS = {
        default: { charge: -120, link: 50, center: 0.05, damping: 0.4 },
        tight: { charge: -80, link: 30, center: 0.1, damping: 0.5 },
        loose: { charge: -200, link: 80, center: 0.02, damping: 0.3 },
        explosive: { charge: -400, link: 120, center: 0.01, damping: 0.2 }
    };

    function _bindPhysicsControls() {
        // Charge (repulsion)
        _bindSlider('physics-charge', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('charge').strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Link distance
        _bindSlider('physics-link', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('link').distance(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Center pull
        _bindSlider('physics-center', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                const center = Graph.d3Force('center');
                if (center && center.strength) center.strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Damping (velocity decay)
        _bindSlider('physics-damping', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3VelocityDecay(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Physics presets
        const container = document.getElementById('section-physics');
        if (container) {
            container.querySelectorAll('.btn[data-physics]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.physics;
                    setPhysicsPreset(preset);
                });
            });
        }
    }

    function setPhysicsPreset(preset) {
        const p = PHYSICS_PRESETS[preset];
        if (!p) return;

        // Update sliders
        _setSliderValue('physics-charge', p.charge);
        _setSliderValue('physics-link', p.link);
        _setSliderValue('physics-center', p.center);
        _setSliderValue('physics-damping', p.damping);

        // Apply to graph
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('charge').strength(p.charge);
            Graph.d3Force('link').distance(p.link);
            const center = Graph.d3Force('center');
            if (center && center.strength) center.strength(p.center);
            Graph.d3VelocityDecay(p.damping);
            Graph.d3ReheatSimulation();
        }

        console.log('[SIDEBAR] Physics preset:', preset);
    }

    // =========================================================================
    // APPEARANCE CONTROLS
    // =========================================================================

    function _bindAppearanceControls() {
        // Auto-bind all sliders that have a matching numeric input
        // This covers cfg-node-size, cfg-node-opacity, etc.
        const ranges = document.querySelectorAll('input[type="range"]');
        ranges.forEach(range => {
            if (range.id) {
                _bindSlider(range.id, (val) => {
                    // Dispatch to specific handlers based on ID
                    // This creates a centralized handler dispatch
                    _handleSliderChange(range.id, val);
                });
            }
        });

        // Toggles
        _bindToggle('cfg-toggle-labels', (active) => {
            if (typeof VIS_FILTERS !== 'undefined' && VIS_FILTERS.metadata) {
                VIS_FILTERS.metadata.showLabels = active;
            }
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.nodeLabel(n => active ? n.name : null);
            }
        });

        _bindToggle('cfg-toggle-highlight', (active) => {
            // Handled by VIS_STATE or interactions
        });

        _bindToggle('cfg-toggle-pulse', (active) => {
            if (typeof ANIM !== 'undefined') {
                ANIM.togglePulse(active);
            }
        });

        _bindToggle('cfg-toggle-depth', (active) => {
            // 3D shading toggle
        });

        _bindToggle('cfg-toggle-arrows', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.showArrows = active;
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.linkDirectionalArrowLength(active ? 6 : 0);
                Graph.linkDirectionalArrowRelPos(0.9);
            }
        });

        _bindToggle('cfg-toggle-gradient', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.gradientEdges = active;
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            window.refreshGradientEdgeColors && window.refreshGradientEdgeColors();
        });
    }

    // Centralized handler for all sliders
    function _handleSliderChange(id, val) {
        // Map ID to logic
        switch (id) {
            // Node Config
            case 'cfg-node-size':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeVal(n => (n.val || 1) * val);
                break;
            case 'cfg-node-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode(); // Re-apply colors with new alpha
                break;
            case 'cfg-node-res':
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeResolution(val);
                break;
            case 'cfg-label-size':
                // Note: 3d-force-graph doesn't have a direct dynamic label size multiplier, 
                // but we can trigger a re-render or update state.
                break;

            // Edge Config    
            case 'cfg-edge-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
                break;
            case 'cfg-edge-width':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeWidth = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkWidth(val);
                break;
            case 'cfg-edge-curve':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeCurvature = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkCurvature(val);
                break;
            case 'cfg-particle-speed':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticleSpeed(val);
                break;
            case 'cfg-particle-count':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticles(val);
                break;

            // Physics (Updated IDs)
            case 'physics-charge':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('charge').strength(val);
                    Graph.d3ReheatSimulation();
                }
                break;
            case 'physics-link':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('link').distance(val);
                    Graph.d3ReheatSimulation();
                }
                break;
        }
    }


    // =========================================================================
    // ACTION BUTTONS
    // =========================================================================

    function _bindActionButtons() {
        // Reset view
        const resetBtn = document.getElementById('btn-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
                }
            });
        }

        // Screenshot
        const screenshotBtn = document.getElementById('btn-screenshot');
        if (screenshotBtn) {
            screenshotBtn.addEventListener('click', () => {
                if (typeof takeScreenshot === 'function') {
                    takeScreenshot();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    const link = document.createElement('a');
                    link.download = 'collider-screenshot.png';
                    link.href = Graph.renderer().domElement.toDataURL('image/png');
                    link.click();
                }
            });
        }

        // NOTE: btn-2d binding removed - dimension.js is authoritative for 2D/3D toggle

        // Freeze simulation
        const freezeBtn = document.getElementById('btn-freeze');
        if (freezeBtn) {
            freezeBtn.addEventListener('click', () => {
                if (typeof toggleFreeze === 'function') {
                    toggleFreeze();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    // Simple freeze toggle
                    const alpha = Graph.d3AlphaTarget();
                    Graph.d3AlphaTarget(alpha === 0 ? 0.3 : 0);
                    freezeBtn.classList.toggle('active', alpha !== 0);
                }
            });
        }
    }

    // =========================================================================
    // FILTER CHIPS
    // =========================================================================

    function populateFilterChips(data) {
        if (!data || !data.nodes) return;

        // Tiers
        const tiers = [...new Set(data.nodes.map(n => n.tier).filter(Boolean))].sort();
        _populateChipGroup('filter-tiers', tiers, 'tiers');

        // Rings
        const rings = [...new Set(data.nodes.map(n => n.ring).filter(Boolean))].sort();
        _populateChipGroup('filter-rings', rings, 'rings');

        // Edge types
        const edgeTypes = [...new Set(data.links?.map(e => e.type).filter(Boolean) || [])].sort();
        _populateChipGroup('filter-edges', edgeTypes, 'edges');
    }

    function _populateChipGroup(containerId, items, filterKey) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';
        items.forEach(item => {
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = item;
            chip.addEventListener('click', () => {
                const isActive = chip.classList.toggle('active');
                setFilter(filterKey, item, !isActive); // active = filtered OUT
                _scheduleRefresh();
            });
            container.appendChild(chip);
        });
    }

    function setFilter(dimension, value, visible) {
        if (typeof VIS_FILTERS === 'undefined') return;
        const set = VIS_FILTERS[dimension];
        if (!set) return;

        if (visible) {
            set.delete(value); // Remove from filter = show
        } else {
            set.add(value);    // Add to filter = hide
        }
    }

    // =========================================================================
    // HOVER PANEL
    // =========================================================================

    function showHoverPanel(node) {
        const panel = document.getElementById('hover-panel');
        if (!panel || !node) return;

        const setField = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value || '--';
        };

        setField('hover-name', node.name);
        setField('hover-kind', node.kind || node.type || 'unknown');
        setField('hover-atom', node.atom);
        setField('hover-family', node.family || (node.atom ? node.atom.split('.')[0] : null));
        setField('hover-ring', node.ring);
        setField('hover-tier', node.tier);
        setField('hover-role', node.role);

        const fileEl = document.getElementById('hover-file');
        if (fileEl) fileEl.textContent = node.file_path || node.file || '';

        panel.classList.add('visible');
    }

    function hideHoverPanel() {
        const panel = document.getElementById('hover-panel');
        if (panel) panel.classList.remove('visible');
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel(selectedNodes) {
        const panel = document.getElementById('selection-panel');
        const title = document.getElementById('selection-title');
        const list = document.getElementById('selection-list');
        const clearBtn = document.getElementById('selection-clear');

        if (!panel || !list) return;

        if (!selectedNodes || selectedNodes.length === 0) {
            panel.classList.remove('visible');
            return;
        }

        if (title) title.textContent = `SELECTED (${selectedNodes.length})`;

        list.innerHTML = selectedNodes.slice(0, 20).map(n =>
            `<div class="selection-item">${n.name || n.id}</div>`
        ).join('');

        if (selectedNodes.length > 20) {
            list.innerHTML += `<div class="selection-item" style="opacity:0.5">...and ${selectedNodes.length - 20} more</div>`;
        }

        panel.classList.add('visible');

        // Bind clear button
        if (clearBtn) {
            clearBtn.onclick = () => {
                if (typeof SELECT !== 'undefined') {
                    SELECT.clear();
                } else if (typeof clearSelection === 'function') {
                    clearSelection();
                }
                panel.classList.remove('visible');
            };
        }
    }

    // =========================================================================
    // STATS DISPLAY
    // =========================================================================

    function updateStats(nodes, edges, entropy) {
        const nodeEl = document.getElementById('stat-nodes');
        const edgeEl = document.getElementById('stat-edges');
        const entropyEl = document.getElementById('stat-entropy');

        if (nodeEl) nodeEl.textContent = nodes?.toLocaleString() || '0';
        if (edgeEl) edgeEl.textContent = edges?.toLocaleString() || '0';
        if (entropyEl) entropyEl.textContent = entropy?.toFixed(2) || '--';
    }

    // =========================================================================
    // HELPER: SLIDERS
    // =========================================================================

    function _bindSlider(id, callback) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);

        // Handle deprecated value span if it exists (for backward compat)
        const valSpan = document.getElementById(`${id}-val`);

        if (!slider) return;

        // Slider -> Number
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (numberInput) numberInput.value = val;
            if (valSpan) valSpan.textContent = val;
            callback(val);
        });

        // Number -> Slider
        if (numberInput) {
            numberInput.addEventListener('change', () => { // Change triggers on enter/blur
                let val = parseFloat(numberInput.value);

                // Clamp
                if (slider.min) val = Math.max(parseFloat(slider.min), val);
                if (slider.max) val = Math.min(parseFloat(slider.max), val);

                numberInput.value = val;
                slider.value = val;
                if (valSpan) valSpan.textContent = val;
                callback(val);
            });

            // Optional: Live update while typing? Maybe too heavy. Use change for now.
        }
    }

    function _setSliderValue(id, value) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);
        const valSpan = document.getElementById(`${id}-val`);

        if (slider) slider.value = value;
        if (numberInput) numberInput.value = value;
        if (valSpan) valSpan.textContent = value;
    }

    // =========================================================================
    // HELPER: TOGGLES
    // =========================================================================

    function _bindToggle(id, callback) {
        const toggle = document.getElementById(id);
        if (!toggle) {
            console.warn('[SIDEBAR] _bindToggle: element not found:', id);
            return;
        }

        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            callback(isActive);
        });
    }

    // =========================================================================
    // DEBOUNCED REFRESH
    // =========================================================================

    function _scheduleRefresh() {
        clearTimeout(_refreshTimer);
        _refreshTimer = setTimeout(() => {
            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof refreshGraph === 'function') {
                refreshGraph();
            }
        }, 16); // ~1 frame
    }

    // =========================================================================
    // SECTION RESIZING - Vertical drag handles
    // =========================================================================

    const SECTION_HEIGHT_KEY = 'viz_section_heights';
    let _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };

    function initSectionResize() {
        // Add resize handles to each section
        document.querySelectorAll('.section-content').forEach(content => {
            const sectionId = content.id;
            if (!sectionId) return;

            // Make content resizable
            content.classList.add('resizable');

            // Create resize handle
            const handle = document.createElement('div');
            handle.className = 'section-resize-handle';
            handle.dataset.section = sectionId;

            // Insert after section-content (before next section)
            const section = content.closest('.section');
            if (section && section.nextElementSibling) {
                section.parentNode.insertBefore(handle, section.nextElementSibling);
            }

            // Bind drag events
            handle.addEventListener('mousedown', _startResize);
        });

        // Global mouse events
        document.addEventListener('mousemove', _onResize);
        document.addEventListener('mouseup', _endResize);

        // Restore saved heights
        _restoreSectionHeights();

        console.log('[SIDEBAR] Section resize initialized');
    }

    function _startResize(e) {
        const sectionId = e.target.dataset.section;
        const content = document.getElementById(sectionId);
        if (!content) return;

        _resizeState = {
            active: true,
            section: content,
            startY: e.clientY,
            startHeight: content.offsetHeight
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }

    function _onResize(e) {
        if (!_resizeState.active || !_resizeState.section) return;

        const delta = e.clientY - _resizeState.startY;
        const newHeight = Math.max(60, Math.min(400, _resizeState.startHeight + delta));

        _resizeState.section.style.maxHeight = newHeight + 'px';
    }

    function _endResize() {
        if (!_resizeState.active) return;

        // Save height
        if (_resizeState.section) {
            _saveSectionHeight(_resizeState.section.id, _resizeState.section.style.maxHeight);
        }

        // Cleanup
        document.querySelectorAll('.section-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };
    }

    function _saveSectionHeight(sectionId, height) {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            heights[sectionId] = height;
            localStorage.setItem(SECTION_HEIGHT_KEY, JSON.stringify(heights));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save section height:', e);
        }
    }

    function _restoreSectionHeights() {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            Object.entries(heights).forEach(([sectionId, height]) => {
                const content = document.getElementById(sectionId);
                if (content && height) {
                    content.style.maxHeight = height;
                }
            });
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore section heights:', e);
        }
    }

    // =========================================================================
    // SIDEBAR RESIZING - Horizontal drag handles
    // =========================================================================

    const SIDEBAR_WIDTH_KEY = 'viz_sidebar_widths';
    let _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };

    function initSidebarResize() {
        const leftHandle = document.getElementById('left-resize-handle');
        const rightHandle = document.getElementById('right-resize-handle');

        if (leftHandle) {
            leftHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'left'));
        }
        if (rightHandle) {
            rightHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'right'));
        }

        // Global mouse events
        document.addEventListener('mousemove', _onSidebarResize);
        document.addEventListener('mouseup', _endSidebarResize);

        // Restore saved widths
        _restoreSidebarWidths();

        console.log('[SIDEBAR] Sidebar resize initialized');
    }

    function _startSidebarResize(e, side) {
        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        const currentWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(cssVar)) || 280;

        _sidebarResizeState = {
            active: true,
            side: side,
            startX: e.clientX,
            startWidth: currentWidth
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        e.preventDefault();
    }

    function _onSidebarResize(e) {
        if (!_sidebarResizeState.active) return;

        const { side, startX, startWidth } = _sidebarResizeState;
        const delta = side === 'left' ? (e.clientX - startX) : (startX - e.clientX);
        const minWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-sidebar-width')) || 200;
        const maxWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-sidebar-width')) || 400;
        const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + delta));

        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        document.documentElement.style.setProperty(cssVar, newWidth + 'px');

        // Update handle position
        const handle = document.getElementById(`${side}-resize-handle`);
        if (handle) {
            if (side === 'left') {
                handle.style.left = (newWidth - 3) + 'px';
            } else {
                handle.style.right = (newWidth - 3) + 'px';
            }
        }
    }

    function _endSidebarResize() {
        if (!_sidebarResizeState.active) return;

        // Save widths
        _saveSidebarWidths();

        // Cleanup
        document.querySelectorAll('.sidebar-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };
    }

    function _saveSidebarWidths() {
        try {
            const left = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width');
            const right = getComputedStyle(document.documentElement).getPropertyValue('--right-panel-width');
            localStorage.setItem(SIDEBAR_WIDTH_KEY, JSON.stringify({ left, right }));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save sidebar widths:', e);
        }
    }

    function _restoreSidebarWidths() {
        try {
            const widths = JSON.parse(localStorage.getItem(SIDEBAR_WIDTH_KEY) || '{}');
            if (widths.left) {
                document.documentElement.style.setProperty('--sidebar-width', widths.left);
                const leftHandle = document.getElementById('left-resize-handle');
                if (leftHandle) leftHandle.style.left = `calc(${widths.left} - 3px)`;
            }
            if (widths.right) {
                document.documentElement.style.setProperty('--right-panel-width', widths.right);
                const rightHandle = document.getElementById('right-resize-handle');
                if (rightHandle) rightHandle.style.right = `calc(${widths.right} - 3px)`;
            }
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore sidebar widths:', e);
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Initialization
        init,
        initSectionResize,
        initSidebarResize,

        // Color modes
        setColorMode,

        // Color Schemes (33 named gradients)
        applyColorScheme,
        clearColorScheme,
        renderSchemeNavigator,
        initSchemeNavigator,
        SCHEME_CONFIG,

        // Layouts
        setLayout,

        // Physics
        setPhysicsPreset,
        PHYSICS_PRESETS,

        // Filters
        populateFilterChips,
        setFilter,
        renderSmartSidebar, // Export for debug/manual re-render

        // Panels
        showHoverPanel,
        hideHoverPanel,
        updateSelectionPanel,

        // Stats
        updateStats,

        // View Mode (ATOMS/FILES toggle)
        initViewModeToggle,
        setViewMode,
        getViewMode,
        applyDeferredViewMode
    };
})();

// Backward compatibility - SidebarManager class is defined in app.js, not duplicated here
// The SIDEBAR module provides all functionality via SIDEBAR.* calls


// ═══ MODULE: modules/edge-system.js ═══
/**
 * EDGE SYSTEM MODULE
 *
 * Manages edge coloring, width, modes, and gradient effects.
 * Includes gradient palettes for tier, file, flow, depth, and semantic modes.
 *
 * Depends on: COLOR (for type-based colors), NODE (for tier lookups)
 *
 * Usage:
 *   EDGE.getColor(link)           // Get color for a link
 *   EDGE.getWidth(link)           // Get width for a link
 *   EDGE.setMode('gradient-tier') // Change edge mode
 *   EDGE.apply()                  // Apply current mode to graph
 */

const EDGE = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODE_ORDER = [
        'gradient-tier',      // Source→Target tier flow (architecture layers)
        'gradient-file',      // File boundaries (module regions)
        'gradient-flow',      // Markov probability (hot paths)
        'gradient-depth',     // Call depth progression
        'gradient-semantic',  // Semantic distance (type similarity)
        'type',               // Classic type-based
        'weight',             // Weight intensity
        'mono'                // Minimal monochrome
    ];

    const MODE_LABELS = {
        'gradient-tier': '▼ TIER FLOW',
        'gradient-file': '▼ FILE REGIONS',
        'gradient-flow': '▼ HOT PATHS',
        'gradient-depth': '▼ CALL DEPTH',
        'gradient-semantic': '▼ SEMANTIC',
        type: 'EDGE: TYPE',
        weight: 'EDGE: WEIGHT',
        mono: 'EDGE: MONO'
    };

    const MODE_HINTS = {
        'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
        'gradient-file': 'Color by file region - shows module boundaries',
        'gradient-flow': 'Hot paths - markov probability gradient',
        'gradient-depth': 'Color by call chain depth',
        'gradient-semantic': 'Color by semantic similarity of endpoints',
        type: 'Edge color by type (calls, imports, etc.)',
        weight: 'Edge width & color by weight',
        mono: 'Minimal monochrome'
    };

    // Gradient color palettes for different modes
    const PALETTES = {
        tier: {
            // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
            T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
            T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
            T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
            UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
        },
        file: {
            // Rainbow hues distributed across files
            saturation: 65,
            lightness: 48
        },
        flow: {
            // Cold (low prob) to Hot (high prob)
            cold: { h: 220, s: 60, l: 45 },   // Blue
            warm: { h: 45, s: 85, l: 50 },    // Yellow
            hot: { h: 0, s: 90, l: 55 }       // Red
        },
        depth: {
            // Shallow (bright) to Deep (dark, saturated)
            shallow: { h: 180, s: 50, l: 65 },  // Light cyan
            mid: { h: 260, s: 70, l: 50 },      // Purple
            deep: { h: 320, s: 80, l: 40 }      // Magenta
        },
        semantic: {
            // Similar (harmonious) to Different (contrasting)
            similar: { h: 150, s: 60, l: 50 },    // Green - same type
            related: { h: 200, s: 65, l: 48 },    // Cyan - related
            different: { h: 340, s: 75, l: 50 }   // Pink - different
        }
    };

    const DEFAULT_OPACITY = 0.08;
    const INFERRED_OPACITY = 0.04;  // Lower opacity for inferred edges
    const MIN_WIDTH = 0.6;
    const MAX_WIDTH = 2.2;
    const BASE_WIDTH = 1.0;
    const DASH_PATTERN = [5, 5];   // Dashed line pattern for inferred edges

    // =========================================================================
    // STATE
    // =========================================================================

    let _mode = 'gradient-file';  // Default mode
    let _ranges = { weight: { min: 1, max: 1 }, confidence: { min: 1, max: 1 } };
    let _nodeFileIndex = new Map();
    let _fileHueMap = new Map();
    let _config = {
        opacity: DEFAULT_OPACITY,
        dim: { interfile_factor: 0.25 }
    };

    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Check if an edge is inferred (from CODOME boundaries).
     * Inferred edges are marked with:
     *   - inferred: true
     *   - family: 'Codome'
     *   - _fromCodome: true
     */
    function isInferredEdge(link) {
        return link?.inferred === true ||
            link?.family === 'Codome' ||
            link?._fromCodome === true;
    }

    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function interpolateHSL(hsl1, hsl2, t) {
        t = clamp01(t);
        // Handle hue interpolation (shortest path on color wheel)
        let h1 = hsl1.h, h2 = hsl2.h;
        let dh = h2 - h1;
        if (Math.abs(dh) > 180) {
            if (dh > 0) h1 += 360;
            else h2 += 360;
        }
        const h = (h1 + (h2 - h1) * t) % 360;
        const s = hsl1.s + (hsl2.s - hsl1.s) * t;
        const l = hsl1.l + (hsl2.l - hsl1.l) * t;
        return hslColor(h, s, l);
    }

    /**
     * Normalize a metric value to [0,1] range.
     * NOW DELEGATES TO UPB_SCALES when available.
     */
    function normalizeMetric(value, range, scaleName) {
        // If range is degenerate (all same values), return based on absolute value
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }

        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(
                scaleName || 'linear',
                value,
                range.min,
                range.max
            );
        }

        // Fallback: inline linear normalization
        return clamp01((value - range.min) / (range.max - range.min));
    }

    // =========================================================================
    // NODE HELPERS (use canonical versions from node-helpers.js via window.*)
    // =========================================================================

    function getLinkFileIdx(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.fileIdx ?? -1;
        }
        if (endpoint) {
            return _nodeFileIndex.get(endpoint) ?? -1;
        }
        return -1;
    }

    // =========================================================================
    // FILE HUE MAP
    // =========================================================================

    function buildFileHueMap() {
        _fileHueMap.clear();
        // Try DATA module first, then DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        if (!dm || !dm.getFileBoundaries) return;

        const files = dm.getFileBoundaries();
        const goldenAngle = 137.508;  // Golden angle for good distribution
        files.forEach((file, idx) => {
            const hue = (idx * goldenAngle) % 360;
            _fileHueMap.set(idx, hue);
        });
    }

    // =========================================================================
    // RANGE UPDATES
    // =========================================================================

    function updateRanges() {
        const links = (typeof Graph !== 'undefined' && Graph?.graphData()?.links) || [];
        let minWeight = Infinity, maxWeight = -Infinity;
        let minConf = Infinity, maxConf = -Infinity;

        links.forEach(link => {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            minWeight = Math.min(minWeight, weight);
            maxWeight = Math.max(maxWeight, weight);
            minConf = Math.min(minConf, confidence);
            maxConf = Math.max(maxConf, confidence);
        });

        _ranges = {
            weight: {
                min: isFinite(minWeight) ? minWeight : 1,
                max: isFinite(maxWeight) ? maxWeight : 1
            },
            confidence: {
                min: isFinite(minConf) ? minConf : 1,
                max: isFinite(maxConf) ? maxConf : 1
            }
        };
    }

    function refreshNodeFileIndex() {
        _nodeFileIndex.clear();
        const nodes = (typeof Graph !== 'undefined' && Graph?.graphData()?.nodes) || [];
        nodes.forEach(node => {
            if (node && node.id) {
                _nodeFileIndex.set(node.id, node.fileIdx ?? -1);
            }
        });
    }

    // =========================================================================
    // GRADIENT EDGE COLOR
    // =========================================================================

    function getGradientColor(link, mode) {
        const srcNode = typeof link.source === 'object' ? link.source :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.source) : null);
        const tgtNode = typeof link.target === 'object' ? link.target :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.target) : null);

        if (mode === 'gradient-tier') {
            const srcTier = window.getNodeTierValue(srcNode);
            const tgtTier = window.getNodeTierValue(tgtNode);
            const avgTier = (srcTier + tgtTier) / 2;

            const palette = PALETTES.tier;
            let color;
            if (avgTier < 0.5) {
                color = interpolateHSL(palette.T0, palette.T1, avgTier * 2);
            } else if (avgTier < 1.5) {
                color = interpolateHSL(palette.T0, palette.T1, (avgTier - 0.5));
            } else {
                color = interpolateHSL(palette.T1, palette.T2, (avgTier - 1) / 2);
            }

            // Highlight tier transitions (edges crossing tiers)
            if (srcTier !== tgtTier) {
                return hslColor(
                    parseInt(color.slice(4)),
                    75,  // Higher saturation
                    55   // Brighter
                );
            }
            return color;
        }

        if (mode === 'gradient-file') {
            const srcFile = srcNode?.fileIdx ?? -1;
            const tgtFile = tgtNode?.fileIdx ?? -1;
            const palette = PALETTES.file;

            if (srcFile === tgtFile && srcFile >= 0) {
                const hue = _fileHueMap.get(srcFile) ?? (srcFile * 37 % 360);
                return hslColor(hue, palette.saturation, palette.lightness);
            } else {
                const srcHue = _fileHueMap.get(srcFile) ?? 0;
                const tgtHue = _fileHueMap.get(tgtFile) ?? 180;
                let midHue = (srcHue + tgtHue) / 2;
                if (Math.abs(srcHue - tgtHue) > 180) {
                    midHue = (midHue + 180) % 360;
                }
                return hslColor(midHue, palette.saturation * 0.6, palette.lightness * 1.1);
            }
        }

        if (mode === 'gradient-flow') {
            const mw = link.markov_weight ?? link.weight ?? 0;
            const palette = PALETTES.flow;

            if (mw < 0.3) {
                return interpolateHSL(palette.cold, palette.warm, mw / 0.3);
            } else if (mw < 0.7) {
                return interpolateHSL(palette.warm, palette.hot, (mw - 0.3) / 0.4);
            } else {
                return hslColor(palette.hot.h, palette.hot.s + 10, palette.hot.l + 10);
            }
        }

        if (mode === 'gradient-depth') {
            const srcDepth = window.getNodeDepth(srcNode);
            const tgtDepth = window.getNodeDepth(tgtNode);
            const avgDepth = (srcDepth + tgtDepth) / 2;
            const palette = PALETTES.depth;

            if (avgDepth < 0.33) {
                return interpolateHSL(palette.shallow, palette.mid, avgDepth * 3);
            } else if (avgDepth < 0.66) {
                return interpolateHSL(palette.mid, palette.deep, (avgDepth - 0.33) * 3);
            } else {
                return hslColor(palette.deep.h, palette.deep.s, palette.deep.l - 10);
            }
        }

        if (mode === 'gradient-semantic') {
            const similarity = window.getSemanticSimilarity(srcNode, tgtNode);
            const palette = PALETTES.semantic;

            if (similarity > 0.7) {
                return interpolateHSL(palette.related, palette.similar, (similarity - 0.7) / 0.3);
            } else if (similarity > 0.3) {
                return interpolateHSL(palette.different, palette.related, (similarity - 0.3) / 0.4);
            } else {
                return hslColor(palette.different.h, palette.different.s + 10, palette.different.l);
            }
        }

        return '#444444';
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(link) {
        // Check if UPB has edge color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasEdgeBinding === 'function' && UPB.hasEdgeBinding()) {
            // UPB handles edge colors - return null to signal deference
            return null;
        }

        // Gradient modes
        if (_mode.startsWith('gradient-')) {
            return getGradientColor(link, _mode);
        }

        const edgeKey = String(link.edge_type || link.type || 'unknown').toLowerCase();

        if (_mode === 'type') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', edgeKey) : '#666666';
        }

        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const t = normalizeMetric(weight, _ranges.weight);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('weight', t) : hslColor(30, 70, 50 + t * 30);
        }

        if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            const t = normalizeMetric(confidence, _ranges.confidence);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('confidence', t) : hslColor(200, 70, 50 + t * 30);
        }

        if (_mode === 'mono') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', 'unknown') : '#555555';
        }

        // Default: type-based coloring
        return typeof COLOR !== 'undefined' ?
            COLOR.get('edgeType', edgeKey) : '#666666';
    }

    // =========================================================================
    // EDGE WIDTH
    // =========================================================================

    function getWidth(link) {
        // For most modes, return uniform width for visual consistency
        if (_mode !== 'weight' && _mode !== 'confidence') {
            return BASE_WIDTH;
        }

        // Weight/confidence modes: subtle variation within tight bounds
        let t = 0.5;
        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            t = normalizeMetric(weight, _ranges.weight);
        } else if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            t = normalizeMetric(confidence, _ranges.confidence);
        }

        return MIN_WIDTH + (t * (MAX_WIDTH - MIN_WIDTH));
    }

    // =========================================================================
    // EDGE LINE DASH (for inferred edges)
    // =========================================================================

    function getLineDash(link) {
        // Return dashed pattern for inferred CODOME edges
        if (isInferredEdge(link)) {
            return DASH_PATTERN;  // [5, 5] = 5px dash, 5px gap
        }
        return null;  // Solid line for regular edges
    }

    // =========================================================================
    // APPLY MODE TO GRAPH
    // =========================================================================

    function apply() {
        updateRanges();
        refreshNodeFileIndex();
        buildFileHueMap();

        if (typeof Graph === 'undefined' || !Graph) return;

        Graph.linkColor(link => {
            const color = getColor(link);
            return typeof toColorNumber === 'function' ?
                toColorNumber(color, 0x222222) : color;
        });

        Graph.linkOpacity(link => {
            const overrideOpacity = (typeof APPEARANCE_STATE !== 'undefined' &&
                typeof APPEARANCE_STATE.edgeOpacity === 'number')
                ? APPEARANCE_STATE.edgeOpacity
                : null;
            const baseOpacity = (overrideOpacity !== null)
                ? overrideOpacity
                : (link.opacity ?? DEFAULT_OPACITY);

            // Inferred edges have lower base opacity
            let opacity = isInferredEdge(link) ? INFERRED_OPACITY : baseOpacity;

            // File mode dimming
            const fileMode = typeof window !== 'undefined' && window.fileMode;
            const graphMode = typeof GRAPH_MODE !== 'undefined' ? GRAPH_MODE : 'atoms';
            if (fileMode && graphMode === 'atoms') {
                const srcIdx = getLinkFileIdx(link, 'source');
                const tgtIdx = getLinkFileIdx(link, 'target');
                if (srcIdx >= 0 && tgtIdx >= 0 && srcIdx !== tgtIdx) {
                    const dimFactor = _config.dim?.interfile_factor ?? 0.25;
                    return opacity * dimFactor;
                }
            }
            return opacity;
        });

        // Apply dashed line pattern to inferred CODOME edges
        if (typeof Graph.linkLineDash === 'function') {
            Graph.linkLineDash(link => getLineDash(link));
        }

        // Don't override width in flow mode
        const flowMode = typeof window !== 'undefined' && window.flowMode;
        if (!flowMode) {
            Graph.linkWidth(link => {
                const baseWidth = getWidth(link);
                // Respect APPEARANCE_STATE.edgeWidth multiplier if set
                const widthMultiplier = (typeof APPEARANCE_STATE !== 'undefined' &&
                    typeof APPEARANCE_STATE.edgeWidth === 'number')
                    ? APPEARANCE_STATE.edgeWidth
                    : 1;
                return Math.max(0.5, baseWidth * widthMultiplier);
            });
        }
    }

    // =========================================================================
    // MODE MANAGEMENT
    // =========================================================================

    function setMode(mode) {
        if (!MODE_ORDER.includes(mode)) return;
        _mode = mode;

        const button = document.getElementById('btn-edge-mode');
        if (button) {
            button.textContent = MODE_LABELS[_mode] || 'EDGE';
        }

        apply();

        // Update legend to reflect edge mode colors
        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        // Show mode toast hint
        if (typeof showModeToast === 'function') {
            showModeToast(MODE_HINTS[mode] || `Edge mode: ${mode}`);
        }
    }

    function cycleMode() {
        const currentIndex = MODE_ORDER.indexOf(_mode);
        const nextIndex = (currentIndex + 1) % MODE_ORDER.length;
        setMode(MODE_ORDER[nextIndex]);
    }

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getWidth,
        getLineDash,
        apply,

        // Mode management
        setMode,
        cycleMode,
        get mode() { return _mode; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Constants
        MODE_ORDER,
        MODE_LABELS,
        MODE_HINTS,
        PALETTES,

        // Internal access (for migration)
        get ranges() { return _ranges; },
        get nodeFileIndex() { return _nodeFileIndex; },
        get fileHueMap() { return _fileHueMap; },

        // Utility exports
        buildFileHueMap,
        updateRanges,
        refreshNodeFileIndex,
        isInferredEdge
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// These create getters/setters that sync with EDGE module state
Object.defineProperty(window, 'EDGE_MODE', {
    get: () => EDGE.mode,
    set: (v) => EDGE.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'EDGE_RANGES', {
    get: () => EDGE.ranges,
    configurable: true
});
Object.defineProperty(window, 'NODE_FILE_INDEX', {
    get: () => EDGE.nodeFileIndex,
    configurable: true
});
Object.defineProperty(window, 'FILE_HUE_MAP', {
    get: () => EDGE.fileHueMap,
    configurable: true
});
// Static constants - app.js owns these, not duplicated here
// EDGE_MODE_ORDER, EDGE_MODE_LABELS, EDGE_MODE_HINTS, GRADIENT_PALETTES - defined in app.js

function getEdgeColor(link) { return EDGE.getColor(link); }
function getEdgeWidth(link) { return EDGE.getWidth(link); }
function getEdgeLineDash(link) { return EDGE.getLineDash(link); }
function isInferredEdgeGlobal(link) { return EDGE.isInferredEdge(link); }
function applyEdgeMode() { EDGE.apply(); }
function setEdgeMode(mode) { EDGE.setMode(mode); }
function cycleEdgeMode() { EDGE.cycleMode(); }
function updateEdgeRanges() { EDGE.updateRanges(); }
function refreshNodeFileIndex() { EDGE.refreshNodeFileIndex(); }
function buildFileHueMap() { EDGE.buildFileHueMap(); }
function getGradientEdgeColor(link, mode) { return EDGE.getColor(link); }


// ═══ MODULE: modules/file-color-model.js ═══
/**
 * FILE COLOR MODEL
 * 
 * Pure color generation for file visualization.
 * ZERO external dependencies - fully testable in isolation.
 * 
 * Extracted from file-viz.js God Object decomposition.
 * 
 * @usage
 *   const colors = new FileColorModel({ strategy: 'golden-angle' });
 *   const color = colors.getColor(fileIdx, totalFiles, fileName);
 */

const FileColorModel = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const GOLDEN_RATIO = 1.618033988749895;
    const GOLDEN_ANGLE = 360 / (GOLDEN_RATIO * GOLDEN_RATIO); // ~137.5°

    const STRATEGIES = {
        'golden-angle': 'golden-angle',
        'sequential': 'sequential',
        'hash': 'hash'
    };

    const DEFAULT_CONFIG = {
        strategy: 'golden-angle',
        saturation: 0.7,
        lightness: 0.55,
        lightnessRange: { min: 0.35, max: 0.75 },
        hueOffset: 0
    };

    // =========================================================================
    // PURE UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Clamp value to range
     */
    function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Convert HSL to CSS color string
     */
    function hslToString(h, s, l) {
        return `hsl(${h.toFixed(1)}, ${(s * 100).toFixed(1)}%, ${(l * 100).toFixed(1)}%)`;
    }

    /**
     * Convert HSL to hex color
     */
    function hslToHex(h, s, l) {
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;

        let r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }

        const toHex = (v) => Math.round((v + m) * 255).toString(16).padStart(2, '0');
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    /**
     * Hash string to unit value [0, 1)
     */
    function hashToUnit(str) {
        if (!str) return 0;
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash % 1000) / 1000;
    }

    // =========================================================================
    // HUE CALCULATION STRATEGIES
    // =========================================================================

    /**
     * Golden angle distribution - maximally distinct colors
     */
    function hueGoldenAngle(fileIdx, totalFiles, hueOffset) {
        return (fileIdx * GOLDEN_ANGLE + hueOffset) % 360;
    }

    /**
     * Sequential distribution - linear spread across spectrum
     */
    function hueSequential(fileIdx, totalFiles, hueOffset) {
        if (totalFiles <= 1) return hueOffset;
        return ((fileIdx / totalFiles) * 360 + hueOffset) % 360;
    }

    /**
     * Hash-based distribution - deterministic based on filename
     */
    function hueFromHash(fileName, hueOffset) {
        return (hashToUnit(fileName) * 360 + hueOffset) % 360;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class FileColorModel {
        constructor(config = {}) {
            this.config = { ...DEFAULT_CONFIG, ...config };
            this._validateConfig();
        }

        _validateConfig() {
            if (!STRATEGIES[this.config.strategy]) {
                console.warn(`[FileColorModel] Unknown strategy "${this.config.strategy}", using golden-angle`);
                this.config.strategy = 'golden-angle';
            }
        }

        /**
         * Get hue for a file based on current strategy
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file (used for hash strategy)
         * @returns {number} Hue value 0-360
         */
        getHue(fileIdx, totalFiles, fileName = '') {
            const { strategy, hueOffset } = this.config;

            switch (strategy) {
                case 'hash':
                    return hueFromHash(fileName, hueOffset);
                case 'sequential':
                    return hueSequential(fileIdx, totalFiles, hueOffset);
                case 'golden-angle':
                default:
                    return hueGoldenAngle(fileIdx, totalFiles, hueOffset);
            }
        }

        /**
         * Get color for a file
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file
         * @param {Object} overrides - Optional overrides for saturation/lightness
         * @returns {string} CSS color string
         */
        getColor(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToString(hue, saturation, lightness);
        }

        /**
         * Get color as hex string
         */
        getColorHex(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToHex(hue, saturation, lightness);
        }

        /**
         * Get color as numeric value for Three.js
         */
        getColorNumeric(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hex = this.getColorHex(fileIdx, totalFiles, fileName, overrides);
            return parseInt(hex.slice(1), 16);
        }

        /**
         * Generate a palette of N colors
         * @param {number} count - Number of colors to generate
         * @returns {Array<string>} Array of CSS color strings
         */
        generatePalette(count) {
            return Array.from({ length: count }, (_, i) =>
                this.getColor(i, count, `file_${i}`)
            );
        }

        /**
         * Update configuration
         */
        setConfig(newConfig) {
            this.config = { ...this.config, ...newConfig };
            this._validateConfig();
        }

        /**
         * Get current configuration
         */
        getConfig() {
            return { ...this.config };
        }
    }

    // =========================================================================
    // STATIC UTILITIES (for one-off use without instantiation)
    // =========================================================================

    FileColorModel.hslToHex = hslToHex;
    FileColorModel.hslToString = hslToString;
    FileColorModel.hashToUnit = hashToUnit;
    FileColorModel.GOLDEN_ANGLE = GOLDEN_ANGLE;
    FileColorModel.STRATEGIES = STRATEGIES;

    return FileColorModel;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.FileColorModel = FileColorModel;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = FileColorModel;
}


// ═══ MODULE: modules/layout-forces.js ═══
/**
 * LAYOUT FORCES
 * 
 * D3 force simulation manipulation for file visualization.
 * Extracted from file-viz.js God Object decomposition.
 * 
 * KEY DESIGN: Takes graph instance as argument - NO GLOBALS.
 * 
 * @usage
 *   LayoutForces.applyClusterForce(Graph, nodes, targets);
 *   LayoutForces.applyCohesionForce(Graph, nodes, config);
 *   LayoutForces.clearForces(Graph, ['cluster', 'fileCohesion']);
 */

const LayoutForces = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const FORCE_NAMES = {
        CLUSTER: 'cluster',
        COHESION: 'fileCohesion',
        RADIAL: 'fileRadial'
    };

    const DEFAULT_COHESION_CONFIG = {
        strength: 0.3,
        radiusFactor: 1.2,
        minRadius: 15,
        maxRadius: 100,
        centerPull: 0.5
    };

    const DEFAULT_CLUSTER_CONFIG = {
        strength: 0.15,
        decay: 0.02
    };

    // =========================================================================
    // CORE FORCE FUNCTIONS
    // =========================================================================

    /**
     * Create a clustering force that pulls nodes toward target positions
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to apply force to (must have x, y, z)
     * @param {Map|Object} targets - Map of nodeId -> { x, y, z } target positions
     * @param {Object} config - Force configuration
     */
    function applyClusterForce(graphInstance, nodes, targets, config = {}) {
        const { strength, decay } = { ...DEFAULT_CLUSTER_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Convert targets to Map if needed
        const targetMap = targets instanceof Map ? targets : new Map(Object.entries(targets));

        // Create custom force
        const clusterForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach(node => {
                const target = targetMap.get(node.id);
                if (!target) return;

                // Pull toward target
                const dx = target.x - (node.x || 0);
                const dy = target.y - (node.y || 0);
                const dz = target.z - (node.z || 0);

                node.vx = (node.vx || 0) + dx * effectiveStrength;
                node.vy = (node.vy || 0) + dy * effectiveStrength;
                node.vz = (node.vz || 0) + dz * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.CLUSTER, clusterForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    /**
     * Apply file cohesion force - pulls nodes together within file groups
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - All graph nodes
     * @param {Object} config - Force configuration and physics settings
     */
    function applyCohesionForce(graphInstance, nodes, config = {}) {
        const settings = { ...DEFAULT_COHESION_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Group nodes by file
        const fileGroups = new Map();
        nodes.forEach(node => {
            const fileIdx = node.fileIdx;
            if (fileIdx === undefined || fileIdx < 0) return;

            if (!fileGroups.has(fileIdx)) {
                fileGroups.set(fileIdx, []);
            }
            fileGroups.get(fileIdx).push(node);
        });

        // Precompute centroids
        const centroids = new Map();
        fileGroups.forEach((group, fileIdx) => {
            if (group.length === 0) return;

            const centroid = { x: 0, y: 0, z: 0 };
            group.forEach(n => {
                centroid.x += n.x || 0;
                centroid.y += n.y || 0;
                centroid.z += n.z || 0;
            });
            centroid.x /= group.length;
            centroid.y /= group.length;
            centroid.z /= group.length;

            centroids.set(fileIdx, centroid);
        });

        // Create cohesion force
        const cohesionForce = (alpha) => {
            const effectiveStrength = settings.strength * alpha;

            fileGroups.forEach((group, fileIdx) => {
                if (group.length < 2) return;

                const centroid = centroids.get(fileIdx);
                if (!centroid) return;

                // Compute group radius
                let maxDist = 0;
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const targetRadius = Math.min(
                    settings.maxRadius,
                    Math.max(settings.minRadius, maxDist * settings.radiusFactor)
                );

                // Apply force toward centroid with boundary constraint
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;

                    // Pull toward centroid
                    const pullStrength = effectiveStrength * settings.centerPull;
                    n.vx = (n.vx || 0) - dx * pullStrength / dist;
                    n.vy = (n.vy || 0) - dy * pullStrength / dist;
                    n.vz = (n.vz || 0) - dz * pullStrength / dist;

                    // Boundary constraint if outside target radius
                    if (dist > targetRadius) {
                        const overshoot = (dist - targetRadius) / dist;
                        n.vx = (n.vx || 0) - dx * overshoot * effectiveStrength;
                        n.vy = (n.vy || 0) - dy * overshoot * effectiveStrength;
                        n.vz = (n.vz || 0) - dz * overshoot * effectiveStrength;
                    }
                });

                // Update centroid for next iteration
                let newCentroid = { x: 0, y: 0, z: 0 };
                group.forEach(n => {
                    newCentroid.x += n.x || 0;
                    newCentroid.y += n.y || 0;
                    newCentroid.z += n.z || 0;
                });
                newCentroid.x /= group.length;
                newCentroid.y /= group.length;
                newCentroid.z /= group.length;
                centroids.set(fileIdx, newCentroid);
            });
        };

        graphInstance.d3Force(FORCE_NAMES.COHESION, cohesionForce);
        graphInstance.d3ReheatSimulation();

        console.log(`[LayoutForces] Cohesion force applied to ${fileGroups.size} file groups`);
        return true;
    }

    /**
     * Clear specific forces from the simulation
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array<string>} forceNames - Names of forces to clear
     */
    function clearForces(graphInstance, forceNames = [FORCE_NAMES.CLUSTER, FORCE_NAMES.COHESION]) {
        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        forceNames.forEach(name => {
            graphInstance.d3Force(name, null);
        });

        return true;
    }

    /**
     * Apply radial force - arranges nodes in a ring
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to arrange
     * @param {Object} config - { radius, strength, center: {x, y, z} }
     */
    function applyRadialForce(graphInstance, nodes, config = {}) {
        const { radius = 100, strength = 0.3, center = { x: 0, y: 0, z: 0 } } = config;

        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        const radialForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach((node, i) => {
                const angle = (i / nodes.length) * Math.PI * 2;
                const targetX = center.x + Math.cos(angle) * radius;
                const targetY = center.y + Math.sin(angle) * radius;
                const targetZ = center.z;

                node.vx = (node.vx || 0) + (targetX - (node.x || 0)) * effectiveStrength;
                node.vy = (node.vy || 0) + (targetY - (node.y || 0)) * effectiveStrength;
                node.vz = (node.vz || 0) + (targetZ - (node.z || 0)) * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.RADIAL, radialForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Force application
        applyClusterForce,
        applyCohesionForce,
        applyRadialForce,
        clearForces,

        // Constants
        FORCE_NAMES,
        DEFAULT_COHESION_CONFIG,
        DEFAULT_CLUSTER_CONFIG
    };
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.LayoutForces = LayoutForces;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = LayoutForces;
}


// ═══ MODULE: modules/hull-visualizer.js ═══
/**
 * HULL VISUALIZER - SDF-Based Organic Membranes
 * 
 * Renders file group boundaries using Signed Distance Functions.
 * GPU-accelerated via WebGL shaders for smooth, organic membrane look.
 * 
 * Advantages over Metaballs/Marching Cubes:
 * - Implicit smooth blending between overlapping groups
 * - Real-time performance with 100+ groups
 * - Distance queries for hit testing
 * - Smooth normals for lighting
 * 
 * @usage
 *   const hulls = new HullVisualizer(scene, renderer);
 *   hulls.update(nodesByFile, colorProvider);
 *   hulls.setBlendFactor(0.5); // Membrane smoothness
 *   hulls.dispose();
 */

const HullVisualizer = (function () {
    'use strict';

    // =========================================================================
    // SHADER CODE
    // =========================================================================

    const VERTEX_SHADER = `
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        void main() {
            vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    // Fragment shader with SDF smooth union
    const FRAGMENT_SHADER = `
        precision highp float;
        
        uniform vec3 uCenters[64];      // Up to 64 group centers
        uniform float uRadii[64];       // Corresponding radii
        uniform vec3 uColors[64];       // Group colors
        uniform int uGroupCount;        // Active group count
        uniform float uBlendFactor;     // Smooth union factor (higher = more blending)
        uniform float uOpacity;         // Overall opacity
        uniform vec3 uCameraPos;        // Camera position for fresnel
        
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        // Smooth minimum (for organic blending)
        float smin(float a, float b, float k) {
            float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
            return mix(b, a, h) - k * h * (1.0 - h);
        }
        
        // SDF for a sphere
        float sdSphere(vec3 p, vec3 center, float radius) {
            return length(p - center) - radius;
        }
        
        // Compute combined SDF for all groups
        float sceneSDF(vec3 p) {
            if (uGroupCount == 0) return 1000.0;
            
            float d = sdSphere(p, uCenters[0], uRadii[0]);
            
            for (int i = 1; i < 64; i++) {
                if (i >= uGroupCount) break;
                float di = sdSphere(p, uCenters[i], uRadii[i]);
                d = smin(d, di, uBlendFactor);
            }
            
            return d;
        }
        
        // Get blended color based on distance to each group
        vec3 getBlendedColor(vec3 p) {
            if (uGroupCount == 0) return vec3(0.5);
            
            vec3 colorSum = vec3(0.0);
            float weightSum = 0.0;
            
            for (int i = 0; i < 64; i++) {
                if (i >= uGroupCount) break;
                float d = length(p - uCenters[i]);
                float weight = 1.0 / (d * d + 0.01);
                colorSum += uColors[i] * weight;
                weightSum += weight;
            }
            
            return colorSum / max(weightSum, 0.001);
        }
        
        void main() {
            float sdf = sceneSDF(vWorldPos);
            
            // Only render near the surface (within membrane thickness)
            float thickness = uBlendFactor * 0.5;
            if (abs(sdf) > thickness) discard;
            
            // Compute normal from SDF gradient
            vec3 eps = vec3(0.01, 0.0, 0.0);
            vec3 sdfNormal = normalize(vec3(
                sceneSDF(vWorldPos + eps.xyy) - sceneSDF(vWorldPos - eps.xyy),
                sceneSDF(vWorldPos + eps.yxy) - sceneSDF(vWorldPos - eps.yxy),
                sceneSDF(vWorldPos + eps.yyx) - sceneSDF(vWorldPos - eps.yyx)
            ));
            
            // Fresnel effect for glass-like appearance
            vec3 viewDir = normalize(uCameraPos - vWorldPos);
            float fresnel = pow(1.0 - abs(dot(viewDir, sdfNormal)), 2.0);
            
            // Get blended color
            vec3 color = getBlendedColor(vWorldPos);
            
            // Edge fade based on SDF distance
            float edgeFade = 1.0 - smoothstep(0.0, thickness, abs(sdf));
            
            // Final color with fresnel rim lighting
            vec3 finalColor = color + fresnel * 0.3;
            float finalOpacity = uOpacity * edgeFade * (0.3 + fresnel * 0.5);
            
            gl_FragColor = vec4(finalColor, finalOpacity);
        }
    `;

    // =========================================================================
    // FALLBACK: Simple sphere-based visualization (when shaders unavailable)
    // =========================================================================

    function createFallbackMesh(center, radius, color, THREE) {
        const geometry = new THREE.SphereGeometry(radius, 24, 24);
        const material = new THREE.MeshPhysicalMaterial({
            color: color,
            transparent: true,
            opacity: 0.15,
            roughness: 0.1,
            metalness: 0.0,
            clearcoat: 0.3,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(center);
        mesh.renderOrder = -1; // Render behind nodes

        return mesh;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class HullVisualizer {
        constructor(scene, renderer, options = {}) {
            this.scene = scene;
            this.renderer = renderer;
            this.options = {
                maxGroups: 64,
                blendFactor: 2.0,
                opacity: 0.25,
                paddingFactor: 1.3,
                minRadius: 5,
                useShaders: options.useShaders !== false,
                ...options
            };

            this.meshes = [];
            this.shaderMaterial = null;
            this.uniforms = null;
            this.boundingMesh = null;

            this._initShaderMaterial();
        }

        _initShaderMaterial() {
            if (!this.options.useShaders || typeof THREE === 'undefined') {
                console.log('[HullVisualizer] Using fallback sphere rendering');
                return;
            }

            try {
                this.uniforms = {
                    uCenters: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3()) },
                    uRadii: { value: new Float32Array(this.options.maxGroups) },
                    uColors: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3(0.5, 0.5, 0.5)) },
                    uGroupCount: { value: 0 },
                    uBlendFactor: { value: this.options.blendFactor },
                    uOpacity: { value: this.options.opacity },
                    uCameraPos: { value: new THREE.Vector3() }
                };

                this.shaderMaterial = new THREE.ShaderMaterial({
                    vertexShader: VERTEX_SHADER,
                    fragmentShader: FRAGMENT_SHADER,
                    uniforms: this.uniforms,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                console.log('[HullVisualizer] SDF shader initialized');
            } catch (e) {
                console.warn('[HullVisualizer] Shader init failed, using fallback:', e.message);
                this.shaderMaterial = null;
            }
        }

        /**
         * Update visualization with new node groups
         * @param {Map|Object} nodesByFile - Map of fileIdx -> [nodes]
         * @param {Function} colorProvider - (fileIdx, total) -> color string or number
         */
        update(nodesByFile, colorProvider) {
            this.clear();

            // Convert to Map if needed
            const groups = nodesByFile instanceof Map ?
                nodesByFile :
                new Map(Object.entries(nodesByFile));

            if (groups.size === 0) return;

            const groupData = [];

            // Compute centroids and radii
            groups.forEach((nodes, fileIdx) => {
                if (!nodes || nodes.length === 0) return;

                // Compute centroid
                const centroid = { x: 0, y: 0, z: 0 };
                nodes.forEach(n => {
                    centroid.x += n.x || 0;
                    centroid.y += n.y || 0;
                    centroid.z += n.z || 0;
                });
                centroid.x /= nodes.length;
                centroid.y /= nodes.length;
                centroid.z /= nodes.length;

                // Compute radius (max distance from centroid + padding)
                let maxDist = 0;
                nodes.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const radius = Math.max(
                    this.options.minRadius,
                    maxDist * this.options.paddingFactor
                );

                // Get color
                const color = colorProvider ?
                    colorProvider(parseInt(fileIdx), groups.size) :
                    '#888888';

                groupData.push({
                    fileIdx,
                    center: new THREE.Vector3(centroid.x, centroid.y, centroid.z),
                    radius,
                    color: this._parseColor(color)
                });
            });

            // Limit to max groups
            const activeGroups = groupData.slice(0, this.options.maxGroups);

            if (this.shaderMaterial && this.uniforms) {
                this._updateShaderUniforms(activeGroups);
                this._createBoundingMesh(activeGroups);
            } else {
                this._createFallbackMeshes(activeGroups);
            }

            console.log(`[HullVisualizer] Updated ${activeGroups.length} group boundaries`);
        }

        _parseColor(color) {
            if (typeof color === 'number') {
                return new THREE.Color(color);
            }
            if (typeof color === 'string') {
                return new THREE.Color(color);
            }
            if (color instanceof THREE.Color) {
                return color;
            }
            return new THREE.Color(0x888888);
        }

        _updateShaderUniforms(groups) {
            groups.forEach((g, i) => {
                this.uniforms.uCenters.value[i] = g.center;
                this.uniforms.uRadii.value[i] = g.radius;
                this.uniforms.uColors.value[i] = new THREE.Vector3(g.color.r, g.color.g, g.color.b);
            });
            this.uniforms.uGroupCount.value = groups.length;
        }

        _createBoundingMesh(groups) {
            // Create a large bounding box that contains all groups
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            groups.forEach(g => {
                minX = Math.min(minX, g.center.x - g.radius);
                minY = Math.min(minY, g.center.y - g.radius);
                minZ = Math.min(minZ, g.center.z - g.radius);
                maxX = Math.max(maxX, g.center.x + g.radius);
                maxY = Math.max(maxY, g.center.y + g.radius);
                maxZ = Math.max(maxZ, g.center.z + g.radius);
            });

            const width = maxX - minX + this.options.blendFactor * 2;
            const height = maxY - minY + this.options.blendFactor * 2;
            const depth = maxZ - minZ + this.options.blendFactor * 2;

            const geometry = new THREE.BoxGeometry(width, height, depth, 32, 32, 32);
            this.boundingMesh = new THREE.Mesh(geometry, this.shaderMaterial);
            this.boundingMesh.position.set(
                (minX + maxX) / 2,
                (minY + maxY) / 2,
                (minZ + maxZ) / 2
            );
            this.boundingMesh.renderOrder = -1;

            this.scene.add(this.boundingMesh);
            this.meshes.push(this.boundingMesh);
        }

        _createFallbackMeshes(groups) {
            groups.forEach(g => {
                const mesh = createFallbackMesh(g.center, g.radius, g.color, THREE);
                this.scene.add(mesh);
                this.meshes.push(mesh);
            });
        }

        /**
         * Update camera position for fresnel effect
         */
        updateCamera(cameraPosition) {
            if (this.uniforms && this.uniforms.uCameraPos) {
                this.uniforms.uCameraPos.value.copy(cameraPosition);
            }
        }

        /**
         * Set blend factor (higher = more organic blending)
         */
        setBlendFactor(factor) {
            this.options.blendFactor = factor;
            if (this.uniforms) {
                this.uniforms.uBlendFactor.value = factor;
            }
        }

        /**
         * Set opacity
         */
        setOpacity(opacity) {
            this.options.opacity = opacity;
            if (this.uniforms) {
                this.uniforms.uOpacity.value = opacity;
            }
            // Update fallback meshes
            this.meshes.forEach(m => {
                if (m.material && m.material.opacity !== undefined) {
                    m.material.opacity = opacity;
                }
            });
        }

        /**
         * Clear all rendered hulls
         */
        clear() {
            this.meshes.forEach(mesh => {
                this.scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material && mesh.material !== this.shaderMaterial) {
                    mesh.material.dispose();
                }
            });
            this.meshes = [];
            this.boundingMesh = null;
        }

        /**
         * Dispose of all resources
         */
        dispose() {
            this.clear();
            if (this.shaderMaterial) {
                this.shaderMaterial.dispose();
                this.shaderMaterial = null;
            }
        }

        /**
         * Check if a point is inside any hull
         * @returns {number|null} fileIdx if inside, null otherwise
         */
        hitTest(point) {
            if (!this.uniforms) return null;

            const count = this.uniforms.uGroupCount.value;
            for (let i = 0; i < count; i++) {
                const center = this.uniforms.uCenters.value[i];
                const radius = this.uniforms.uRadii.value[i];
                const dist = point.distanceTo(center);
                if (dist < radius) {
                    return i; // Return group index
                }
            }
            return null;
        }
    }

    // =========================================================================
    // STATIC FACTORY
    // =========================================================================

    HullVisualizer.create = function (scene, renderer, options) {
        return new HullVisualizer(scene, renderer, options);
    };

    return HullVisualizer;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.HullVisualizer = HullVisualizer;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = HullVisualizer;
}


// ═══ MODULE: modules/file-viz.js ═══
/**
 * FILE VIZ CONTROLLER
 * 
 * Thin orchestrator for file visualization modes.
 * Delegates to specialized modules:
 *   - FileColorModel: Color generation
 *   - LayoutForces: D3 physics manipulation
 *   - HullVisualizer: SDF-based boundary rendering
 * 
 * DESIGN PRINCIPLE: This module coordinates, it does NOT implement.
 * All implementation details live in the delegated modules.
 * 
 * @usage
 *   FILE_VIZ.setEnabled(true);
 *   FILE_VIZ.setMode('hulls');
 *   FILE_VIZ.apply();
 */

const FILE_VIZ = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS & MODES
    // =========================================================================

    const MODES = {
        OFF: 'off',
        COLOR: 'color',
        HULLS: 'hulls',
        MAP: 'map'
    };

    // =========================================================================
    // STATE (minimal - delegates to child modules)
    // =========================================================================

    let _enabled = false;
    let _mode = MODES.COLOR;
    let _colorModel = null;
    let _hullVisualizer = null;
    let _fileGraph = null;
    let _expandedFiles = new Set();
    let _graphMode = 'atoms'; // atoms | files

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function _ensureColorModel() {
        if (!_colorModel && typeof FileColorModel !== 'undefined') {
            _colorModel = new FileColorModel({ strategy: 'golden-angle' });
        }
        return _colorModel;
    }

    function _ensureHullVisualizer() {
        if (!_hullVisualizer && typeof HullVisualizer !== 'undefined') {
            const scene = typeof Graph !== 'undefined' ? Graph.scene() : null;
            const renderer = typeof Graph !== 'undefined' ? Graph.renderer() : null;
            if (scene && renderer) {
                _hullVisualizer = new HullVisualizer(scene, renderer, {
                    blendFactor: 2.0,
                    opacity: 0.2
                });
            }
        }
        return _hullVisualizer;
    }

    // =========================================================================
    // COLOR FUNCTIONS (delegated to FileColorModel)
    // =========================================================================

    function getColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const model = _ensureColorModel();
        if (!model) {
            // Fallback if module not loaded
            return `hsl(${(fileIdx * 137.5) % 360}, 70%, 55%)`;
        }

        const overrides = lightnessOverride ? { lightness: lightnessOverride } : {};
        return model.getColor(fileIdx, totalFiles, fileName, overrides);
    }

    function applyColors(graphNodes) {
        if (!_enabled || !graphNodes) return;

        // Check if UPB has active color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasColorBinding === 'function' && UPB.hasColorBinding()) {
            // UPB is handling colors - don't override
            console.log('[FILE_VIZ] Deferring to UPB for node colors');
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        const boundaries = dm ? dm.getFileBoundaries() : [];
        const totalFiles = boundaries.length;

        graphNodes.forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                const fileName = boundaries[node.fileIdx]?.file_name || '';
                node.color = getColor(node.fileIdx, totalFiles, fileName);
            }
        });
    }

    // =========================================================================
    // HULL FUNCTIONS (delegated to HullVisualizer)
    // =========================================================================

    function drawFileBoundaries(data) {
        const viz = _ensureHullVisualizer();
        if (!viz) {
            console.warn('[FILE_VIZ] HullVisualizer not available');
            return 0;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return 0;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Group nodes by file
        const nodesByFile = new Map();
        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!nodesByFile.has(node.fileIdx)) {
                nodesByFile.set(node.fileIdx, []);
            }
            nodesByFile.get(node.fileIdx).push(node);
        });

        // Color provider
        const colorProvider = (fileIdx, total) => {
            const fileName = boundaries[fileIdx]?.file_name || '';
            return getColor(fileIdx, total, fileName);
        };

        viz.update(nodesByFile, colorProvider);
        return nodesByFile.size;
    }

    function clearBoundaries() {
        if (_hullVisualizer) {
            _hullVisualizer.clear();
        }
    }

    // =========================================================================
    // PHYSICS FUNCTIONS (delegated to LayoutForces)
    // =========================================================================

    function applyClusterForce(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Compute file centroid targets
        const targets = new Map();
        const fileNodes = new Map();

        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!fileNodes.has(node.fileIdx)) {
                fileNodes.set(node.fileIdx, []);
            }
            fileNodes.get(node.fileIdx).push(node);
        });

        // Create spiral layout for file groups
        const totalFiles = fileNodes.size;
        let fileIndex = 0;
        fileNodes.forEach((group, fileIdx) => {
            const angle = fileIndex * 2.4; // Golden angle
            const radius = 50 + fileIndex * 10;
            const target = {
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius,
                z: (fileIndex - totalFiles / 2) * 5
            };

            group.forEach(node => {
                targets.set(node.id, target);
            });
            fileIndex++;
        });

        return LayoutForces.applyClusterForce(Graph, nodes, targets);
    }

    function applyCohesion(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const physicsConfig = dm.raw?.physics || {};

        return LayoutForces.applyCohesionForce(Graph, nodes, {
            strength: physicsConfig.fileCohesion || 0.3
        });
    }

    function clearCohesion() {
        if (typeof LayoutForces !== 'undefined' && typeof Graph !== 'undefined') {
            LayoutForces.clearForces(Graph);
        }
    }

    // =========================================================================
    // FILE GRAPH (map mode)
    // =========================================================================

    function buildFileGraph() {
        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return null;

        const boundaries = dm.getFileBoundaries();
        const links = dm.getLinks();

        // Create file nodes
        const fileNodes = boundaries.map((boundary, idx) => ({
            id: `file:${idx}`,
            name: boundary.file_name || `File ${idx}`,
            fileIdx: idx,
            isFileNode: true,
            atomCount: boundary.atom_count || boundary.atom_indices?.length || 0,
            val: Math.max(1, Math.sqrt(boundary.atom_count || 1)),
            color: getColor(idx, boundaries.length, boundary.file_name),
            x: 0, y: 0, z: 0
        }));

        // Build file-to-file links from atom links
        const atomToFile = new Map();
        dm.getNodes().forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                atomToFile.set(node.id, node.fileIdx);
            }
        });

        const fileLinkCounts = new Map();
        links.forEach(link => {
            const srcFile = atomToFile.get(link.source?.id || link.source);
            const tgtFile = atomToFile.get(link.target?.id || link.target);

            if (srcFile !== undefined && tgtFile !== undefined && srcFile !== tgtFile) {
                const key = `${srcFile}-${tgtFile}`;
                fileLinkCounts.set(key, (fileLinkCounts.get(key) || 0) + 1);
            }
        });

        const fileLinks = [];
        fileLinkCounts.forEach((count, key) => {
            const [src, tgt] = key.split('-').map(Number);
            fileLinks.push({
                source: `file:${src}`,
                target: `file:${tgt}`,
                weight: count,
                opacity: Math.min(0.8, 0.1 + count * 0.05)
            });
        });

        _fileGraph = { nodes: fileNodes, links: fileLinks };
        return _fileGraph;
    }

    function applyFileGraphMode() {
        if (!_fileGraph) buildFileGraph();
        if (!_fileGraph || !Graph) return;  // Guard against null AND undefined

        Graph.graphData(_fileGraph);
        _graphMode = 'files';

        if (typeof showToast !== 'undefined') {
            showToast(`File Map: ${_fileGraph.nodes.length} files, ${_fileGraph.links.length} connections`);
        }

        // Enforce strict centering on Origin (0,0,0)
        if (Graph.d3Force) {
            Graph.d3Force('center', d3.forceCenter(0, 0, 0));
        }
    }

    // =========================================================================
    // MODE APPLICATION
    // =========================================================================

    function apply() {
        if (!_enabled) {
            clearBoundaries();
            clearCohesion();
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return;

        switch (_mode) {
            case MODES.COLOR:
                clearBoundaries();
                applyColors(dm.getNodes());
                if (typeof refreshGraph !== 'undefined') refreshGraph();
                break;

            case MODES.HULLS:
                applyColors(dm.getNodes());
                applyCohesion();
                drawFileBoundaries();
                break;

            case MODES.MAP:
                clearBoundaries();
                applyFileGraphMode();
                break;

            case MODES.OFF:
            default:
                clearBoundaries();
                clearCohesion();
                break;
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function setEnabled(enabled) {
        _enabled = !!enabled;
        apply();

        // Update UI if available
        const btn = document.getElementById('cmd-files');
        if (btn) {
            btn.classList.toggle('active', _enabled);
        }
    }

    function toggle() {
        setEnabled(!_enabled);
        return _enabled;
    }

    function setMode(mode) {
        if (!MODES[mode.toUpperCase()] && !Object.values(MODES).includes(mode)) {
            console.warn(`[FILE_VIZ] Unknown mode: ${mode}`);
            return;
        }
        _mode = mode.toLowerCase();
        if (_enabled) apply();
    }

    function isEnabled() { return _enabled; }
    function getMode() { return _mode; }
    function getFileGraph() { return _fileGraph; }
    function getExpandedFiles() { return _expandedFiles; }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        clearBoundaries();
        clearCohesion();
        if (_hullVisualizer) {
            _hullVisualizer.dispose();
            _hullVisualizer = null;
        }
        _colorModel = null;
        _fileGraph = null;
        _expandedFiles.clear();
    }

    // =========================================================================
    // RETURN PUBLIC API
    // =========================================================================

    return {
        // Mode control
        setEnabled,
        toggle,
        setMode,
        apply,

        // Color functions
        getColor,
        applyColors,

        // Hull functions
        drawFileBoundaries,
        clearBoundaries,

        // Physics
        applyClusterForce,
        applyCohesion,
        clearCohesion,

        // File graph
        buildFileGraph,

        // Getters
        isEnabled,
        getMode,
        getFileGraph,
        getExpandedFiles,

        // Cleanup
        dispose,

        // Constants
        MODES
    };
})();

// Register globally
if (typeof window !== 'undefined') {
    window.FILE_VIZ = FILE_VIZ;
    // Backward compat aliases
    window.drawFileBoundaries = FILE_VIZ.drawFileBoundaries;
    window.getColorForMapping = FILE_VIZ.getColor;
    // Global getter for EXPANDED_FILES (read-only, like SELECTED_NODE_IDS)
    Object.defineProperty(window, 'EXPANDED_FILES', {
        get: () => FILE_VIZ.getExpandedFiles(),
        configurable: true
    });
}


// ═══ MODULE: modules/tooltips.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * TOOLTIPS MODULE - Tooltip and Toast Notifications
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles topology tooltips and toast notifications.
 * Depends on: TOOLTIP_STATE, HINTS_ENABLED, SMC_THEORY (globals)
 *
 * @module TOOLTIPS
 * @version 1.0.0
 * @confidence 99%
 */

window.TOOLTIPS = (function() {
    'use strict';

    // Module-local timeout reference
    let _toastTimeout = null;

    // ═══════════════════════════════════════════════════════════════════════
    // TOOLTIP OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize tooltip elements
     */
    function initTooltips() {
        const state = window.TOOLTIP_STATE;
        if (state) {
            state.element = document.getElementById('topo-tooltip');
        }
    }

    /**
     * Show topology tooltip with theory content
     * @param {string} category - Theory category (tiers, rings, families, etc.)
     * @param {string} key - Item key within category
     * @param {number} x - Screen X position
     * @param {number} y - Screen Y position
     */
    function showTopoTooltip(category, key, x, y) {
        const state = window.TOOLTIP_STATE;
        if (!state) return;

        if (!state.element) initTooltips();
        if (!state.element) return;

        const theory = window.SMC_THEORY;
        const content = theory?.[category]?.[key];
        if (!content) return;

        clearTimeout(state.hideTimeout);

        // Populate tooltip content
        const iconEl = document.getElementById('tooltip-icon');
        const titleEl = document.getElementById('tooltip-title');
        const subtitleEl = document.getElementById('tooltip-subtitle');
        const bodyEl = document.getElementById('tooltip-body');
        const theoryEl = document.getElementById('tooltip-theory');
        const examplesEl = document.getElementById('tooltip-examples');

        if (iconEl) iconEl.textContent = content.icon || '';
        if (titleEl) titleEl.textContent = content.title || key;
        if (subtitleEl) subtitleEl.textContent = content.subtitle || '';
        if (bodyEl) bodyEl.textContent = content.body || '';
        if (theoryEl) theoryEl.textContent = content.theory || '';
        if (examplesEl) {
            examplesEl.innerHTML = (content.examples || [])
                .map(ex => `<span class="topo-tooltip-example">${ex}</span>`)
                .join('');
        }

        // Position tooltip
        const tooltip = state.element;
        let left = x + 15, top = y + 15;
        if (left + 280 > window.innerWidth) left = x - 295;
        if (top + 200 > window.innerHeight) top = y - 215;
        if (left < 0) left = 15;
        if (top < 0) top = 15;

        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.classList.add('visible');

        state.visible = true;
        state.currentKey = `${category}:${key}`;
    }

    /**
     * Hide topology tooltip
     * @param {boolean} immediate - Hide immediately without delay
     */
    function hideTopoTooltip(immediate = false) {
        const state = window.TOOLTIP_STATE;
        if (!state || !state.element) return;

        if (immediate) {
            state.element.classList.remove('visible');
            state.visible = false;
        } else {
            state.hideTimeout = setTimeout(() => {
                state.element.classList.remove('visible');
                state.visible = false;
            }, 150);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Show a toast notification
     * @param {string} message - Message to display
     */
    function showToast(message) {
        const toast = document.getElementById('hud-toast');
        if (!toast) return;

        toast.textContent = message;
        toast.classList.add('visible');

        clearTimeout(toast._timer);
        toast._timer = setTimeout(() => {
            toast.classList.remove('visible');
        }, 2200);
    }

    /**
     * Show mode change toast (respects hints setting)
     * @param {string} message - Message to display
     */
    function showModeToast(message) {
        if (!window.HINTS_ENABLED) return;

        let toast = document.getElementById('mode-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'mode-toast';
            toast.className = 'mode-toast';
            document.body.appendChild(toast);
        }

        toast.textContent = message;
        toast.classList.add('visible');

        if (_toastTimeout) clearTimeout(_toastTimeout);
        _toastTimeout = setTimeout(() => {
            toast.classList.remove('visible');
        }, 1200);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        init: initTooltips,
        showTopo: showTopoTooltip,
        hideTopo: hideTopoTooltip,
        toast: showToast,
        modeToast: showModeToast
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.initTooltips = TOOLTIPS.init;
window.showTopoTooltip = TOOLTIPS.showTopo;
window.hideTopoTooltip = TOOLTIPS.hideTopo;
window.showToast = TOOLTIPS.toast;
window.showModeToast = TOOLTIPS.modeToast;

console.log('[Module] TOOLTIPS loaded - 5 functions');


// ═══ MODULE: modules/theme.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * THEME MODULE - Runtime Theme Management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles theme switching, persistence, and initialization.
 * Depends on: THEME_CONFIG (global), Graph (global), THREE (global)
 *
 * @module THEME
 * @version 1.0.0
 * @confidence 99%
 */

window.THEME = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // THEME OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Set the active theme by name.
     * Updates document data-theme attribute and stores preference.
     * @param {string} themeName - Theme name: 'dark', 'light', or 'high-contrast'
     */
    function setTheme(themeName) {
        const config = window.THEME_CONFIG;
        if (!config || !config.available.includes(themeName)) {
            console.warn(`[Theme] Unknown theme: ${themeName}. Available: ${config?.available?.join(', ') || 'none'}`);
            return;
        }

        // Update document attribute for CSS variable switching
        document.documentElement.setAttribute('data-theme', themeName);

        // Update global state
        config.current = themeName;

        // Store preference in localStorage
        try {
            localStorage.setItem('collider-theme', themeName);
        } catch (e) {
            console.warn('[Theme] Could not save preference:', e);
        }

        // Update canvas background if WebGL renderer is active
        const Graph = window.Graph;
        if (Graph && Graph.scene && Graph.scene()) {
            const scene = Graph.scene();
            if (scene.background) {
                const vizColors = window.VIZ_COLORS || {};
                const bgColor = getComputedStyle(document.documentElement)
                    .getPropertyValue('--color-viz-canvas-bg')?.trim() || vizColors.canvasBg || '#0a0a0f';
                scene.background = new THREE.Color(bgColor);
            }
        }

        // Update theme toggle buttons
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.theme === themeName);
        });

        const consoleColors = window.CONSOLE_COLORS || { success: '#4caf50' };
        console.log(`%c[Theme] Switched to: ${themeName}`, `color: ${consoleColors.success}; font-weight: bold`);

        // Show toast if available
        if (typeof window.showToast === 'function') {
            window.showToast(`Theme: ${themeName}`);
        }
    }

    /**
     * Get the current theme name.
     * @returns {string} Current theme name
     */
    function getTheme() {
        const config = window.THEME_CONFIG;
        return config ? config.current : 'dark';
    }

    /**
     * Get list of available themes.
     * @returns {string[]} Array of theme names
     */
    function getAvailableThemes() {
        const config = window.THEME_CONFIG;
        return config ? config.available : ['dark'];
    }

    /**
     * Cycle to the next theme in the list.
     */
    function cycleTheme() {
        const config = window.THEME_CONFIG;
        if (!config) return;

        const current = config.current;
        const themes = config.available;
        const currentIndex = themes.indexOf(current);
        const nextIndex = (currentIndex + 1) % themes.length;
        setTheme(themes[nextIndex]);
    }

    /**
     * Initialize theme from saved preference or default.
     */
    function initTheme() {
        const config = window.THEME_CONFIG;
        if (!config) {
            console.warn('[Theme] THEME_CONFIG not available');
            return;
        }

        // Check for saved preference
        let savedTheme = null;
        try {
            savedTheme = localStorage.getItem('collider-theme');
        } catch (e) {
            // Ignore storage errors
        }

        // Use saved preference if valid
        if (savedTheme && config.available.includes(savedTheme)) {
            setTheme(savedTheme);
            return;
        }

        // Fall back to default theme
        setTheme(config.default || 'dark');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        set: setTheme,
        get: getTheme,
        available: getAvailableThemes,
        cycle: cycleTheme,
        init: initTheme
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setTheme = THEME.set;
window.getTheme = THEME.get;
window.getAvailableThemes = THEME.available;
window.cycleTheme = THEME.cycle;
window.initTheme = THEME.init;

console.log('[Module] THEME loaded - 5 functions');


// ═══ MODULE: modules/upb/scales.js ═══
const UPB_SCALES = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - SCALES MODULE
     * Pure functions for mapping data values to normalized [0,1] ranges.
     */

    const SCALES = {
        // Linear mapping (standard)
        linear: (v, min, max) => (v - min) / (max - min || 1),

        // Logarithmic mapping (good for power-law distributions like LoC)
        log: (v, min, max) => {
            const logMin = Math.log10(Math.max(1, min));
            const logMax = Math.log10(Math.max(1, max));
            const logVal = Math.log10(Math.max(1, v));
            return (logVal - logMin) / (logMax - logMin || 1);
        },

        // Square root mapping (good for area/size to radius)
        sqrt: (v, min, max) => {
            const sqrtMin = Math.sqrt(Math.max(0, min));
            const sqrtMax = Math.sqrt(Math.max(0, max));
            const sqrtVal = Math.sqrt(Math.max(0, v));
            return (sqrtVal - sqrtMin) / (sqrtMax - sqrtMin || 1);
        },

        // Inverse linear (higher value = lower output)
        inverse: (v, min, max) => 1 - ((v - min) / (max - min || 1)),

        // Exponential (emphasizes extremes)
        exp: (v, min, max) => {
            const norm = (v - min) / (max - min || 1);
            return Math.pow(norm, 2);
        },

        // Discrete/Categorical mapping
        // Assumes value is an index or exact match in domain
        discrete: (v, min, max, domain) => {
            if (Array.isArray(domain)) {
                const idx = domain.indexOf(v);
                if (idx === -1) return 0.5; // Fallback
                return idx / Math.max(1, domain.length - 1);
            }
            return 0;
        },

        // Rank-based/Percentile (placeholder - requires sorted dataset context)
        percentile: (v, min, max) => (v - min) / (max - min || 1)
    };

    const SCALE_NAMES = Object.keys(SCALES);

    /**
     * Universal applicator
     * @param {string} name - Name of scale function
     * @param {number} value - Raw value to map
     * @param {number} min - Domain minimum
     * @param {number} max - Domain maximum
     * @param {Array} [domain] - Optional domain for discrete scales
     */
    function applyScale(name, value, min, max, domain) {
        const fn = SCALES[name] || SCALES.linear;
        // Clamp result to [0, 1] for safety
        const result = fn(value, min, max, domain);
        return Math.max(0, Math.min(1, result));
    }

    return {
        SCALES,
        SCALE_NAMES,
        applyScale
    };
})();

// Export to window for browser
if (typeof window !== 'undefined') window.UPB_SCALES = UPB_SCALES;
if (typeof module !== 'undefined') module.exports = UPB_SCALES;


// ═══ MODULE: modules/upb/endpoints.js ═══
const UPB_ENDPOINTS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - ENDPOINTS MODULE
     * Definitions/Schema for all Data Sources (inputs) and Visual Targets (outputs).
     */

    // =========================================================================
    // AVAILABLE DATA SOURCES (Mappings FROM)
    // =========================================================================
    const SOURCES = {
        // Structural metrics
        size_bytes: { label: 'File Size (bytes)', type: 'continuous', domain: 'file' },
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' },
        line_count: { label: 'Line Count', type: 'continuous', domain: 'file' },
        code_lines: { label: 'Code Lines', type: 'continuous', domain: 'file' },
        complexity_density: { label: 'Complexity Density', type: 'continuous', domain: 'file' },
        cohesion: { label: 'Cohesion', type: 'continuous', domain: 'file' },
        code_ratio: { label: 'Code Ratio', type: 'continuous', domain: 'file' },

        // Structural
        token_estimate: {
            Type: 'continuous',
            domain: 'file',
            label: 'Token Count',
            tags: ['structural', 'quantitative', 'size']
        },
        line_count: {
            Type: 'continuous',
            domain: 'file',
            label: 'Line Count',
            tags: ['structural', 'quantitative', 'verticality']
        },
        size_bytes: {
            Type: 'continuous',
            domain: 'file',
            label: 'File Size',
            tags: ['structural', 'quantitative', 'weight']
        },
        code_lines: {
            Type: 'continuous',
            domain: 'file',
            label: 'Code Lines',
            tags: ['structural', 'quantitative', 'density']
        },
        complexity_density: {
            Type: 'continuous',
            domain: 'file',
            label: 'Complexity',
            tags: ['structural', 'qualitative', 'entropy']
        },
        cohesion: {
            Type: 'continuous',
            domain: 'file',
            label: 'Cohesion',
            tags: ['structural', 'qualitative', 'unity']
        },

        // Temporal
        age_days: {
            Type: 'continuous',
            domain: 'file',
            label: 'Age (Days)',
            tags: ['temporal', 'quantitative', 'decay']
        },

        // Graph / Topology
        in_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'In-Degree',
            tags: ['topological', 'quantitative', 'popularity']
        },
        out_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'Out-Degree',
            tags: ['topological', 'quantitative', 'dependency']
        },

        // Categorical
        tier: {
            Type: 'discrete',
            domain: 'node',
            label: 'Tier (Layer)',
            tags: ['architectural', 'categorical', 'hierarchy']
        },
        role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Role',
            tags: ['semantic', 'categorical', 'purpose']
        },
        format_category: {
            Type: 'discrete',
            domain: 'file',
            label: 'Format',
            tags: ['technical', 'categorical', 'syntax']
        },

        // Boolean
        is_test: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Test',
            tags: ['functional', 'boolean', 'quality']
        },
        is_stale: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Stale',
            tags: ['temporal', 'boolean', 'risk']
        },

        // =====================================================================
        // TREE-SITTER ANALYSIS (T2-T6)
        // =====================================================================

        // T2: Purity Score (D6:EFFECT - continuous)
        D6_pure_score: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity Score',
            range: [0, 1],
            tags: ['theory', 'D6', 'purity', 'effect', 'tree-sitter']
        },

        // T3: Purity Rating (D6:EFFECT - categorical)
        D6_EFFECT: {
            Type: 'discrete',
            domain: 'node',
            label: 'Purity Rating',
            values: ['pure', 'mostly_pure', 'mixed', 'mostly_impure', 'impure'],
            tags: ['theory', 'D6', 'purity', 'categorical', 'tree-sitter']
        },

        // T4: PageRank (graph centrality)
        pagerank: {
            Type: 'continuous',
            domain: 'node',
            label: 'PageRank',
            range: [0, 1],
            tags: ['topological', 'centrality', 'influence', 'quantitative']
        },

        // T5: Betweenness Centrality (bridge nodes)
        betweenness_centrality: {
            Type: 'continuous',
            domain: 'node',
            label: 'Betweenness',
            range: [0, 1],
            tags: ['topological', 'centrality', 'bridge', 'quantitative']
        },

        // T6: Topology Role (categorical)
        topology_role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Topology Role',
            values: ['orphan', 'root', 'leaf', 'hub', 'internal'],
            tags: ['topological', 'categorical', 'structure']
        },

        // =====================================================================
        // CONTROL FLOW METRICS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity (McCabe metric)
        cyclomatic_complexity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Cyclomatic Complexity',
            range: [1, 50],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Complexity Rating (categorical)
        complexity_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Complexity Rating',
            values: ['simple', 'moderate', 'complex', 'very_complex'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // Max Nesting Depth
        max_nesting_depth: {
            Type: 'continuous',
            domain: 'node',
            label: 'Nesting Depth',
            range: [0, 10],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Nesting Rating (categorical)
        nesting_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Nesting Rating',
            values: ['shallow', 'moderate', 'deep', 'very_deep'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // =====================================================================
        // RPBL SCORES (P4-05/07/08) - Theory Character Dimensions
        // =====================================================================

        // Responsibility (R) - How much does this node do?
        rpbl_responsibility: {
            Type: 'continuous',
            domain: 'node',
            label: 'Responsibility (R)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D3', 'quantitative']
        },

        // Purity (P) - How pure is this node?
        rpbl_purity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity (P)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D6', 'quantitative']
        },

        // Boundary (B) - How exposed is this node?
        rpbl_boundary: {
            Type: 'continuous',
            domain: 'node',
            label: 'Boundary (B)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D4', 'quantitative']
        },

        // Lifecycle (L) - What lifecycle stage?
        rpbl_lifecycle: {
            Type: 'continuous',
            domain: 'node',
            label: 'Lifecycle (L)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D7', 'quantitative']
        }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Mappings TO)
    // =========================================================================
    const TARGETS = {
        // Geometric
        nodeSize: {
            category: 'geometry',
            range: [1, 30],
            minOutput: 1,           // Prevent zero-size nodes
            blendMode: 'max',       // Multiple bindings → take largest
            label: 'Node Size',
            tags: ['visual', 'geometric', 'magnitude', 'importance']
        },
        xPosition: {
            category: 'geometry',
            range: [-1000, 1000],
            blendMode: 'average',   // Blend positions via average
            label: 'X Position',
            tags: ['visual', 'geometric', 'spatial', 'horizontal']
        },
        yPosition: { label: 'Y Position', category: 'position', range: [-500, 500], blendMode: 'average' },
        zPosition: { label: 'Z Position (depth)', category: 'position', range: [-300, 300], blendMode: 'average' },
        radius: { label: 'Radial Distance', category: 'position', range: [50, 400], minOutput: 50, blendMode: 'max' },

        // Chromatic
        hue: {
            category: 'color',
            range: [0, 360],
            blendMode: 'replace',   // Hue doesn't blend well
            label: 'Color Hue',
            tags: ['visual', 'chromatic', 'identity', 'cyclical']
        },
        saturation: {
            category: 'color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Saturation',
            tags: ['visual', 'chromatic', 'intensity', 'purity']
        },
        lightness: {
            category: 'color',
            range: [0, 100],
            minOutput: 10,          // Prevent invisible (black) nodes
            blendMode: 'average',
            label: 'Lightness',
            tags: ['visual', 'chromatic', 'brightness', 'fade']
        },
        opacity: {
            category: 'color',
            range: [0.1, 1.0],
            minOutput: 0.1,         // Prevent fully transparent nodes
            blendMode: 'multiply',  // Stacked effects multiply
            label: 'Opacity',
            tags: ['visual', 'chromatic', 'presence', 'ghost']
        },

        // Physics / Simulation
        charge: {
            category: 'physics',
            range: [-500, 0],
            blendMode: 'add',       // Charges accumulate
            label: 'Repulsion',
            tags: ['simulation', 'force', 'space', 'isolation']
        },
        collisionRadius: {
            category: 'physics',
            range: [1, 50],
            minOutput: 1,           // Minimum collision body
            blendMode: 'max',
            label: 'Collision Body',
            tags: ['simulation', 'force', 'substance', 'barrier']
        },
        linkStrength: { label: 'Link Strength', category: 'physics', range: [0, 1], blendMode: 'average' },
        mass: { label: 'Mass (inertia)', category: 'physics', range: [1, 10], minOutput: 1, blendMode: 'add' },

        // Animation
        pulseSpeed: { label: 'Pulse Speed', category: 'animation', range: [0, 5], blendMode: 'max' },
        rotationSpeed: { label: 'Rotation Speed', category: 'animation', range: [0, 2], blendMode: 'max' },

        // Edge-specific targets
        edgeHue: {
            category: 'edge-color',
            range: [0, 360],
            blendMode: 'replace',
            label: 'Edge Hue',
            tags: ['visual', 'chromatic', 'edge', 'cyclical']
        },
        edgeSaturation: {
            category: 'edge-color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Edge Saturation',
            tags: ['visual', 'chromatic', 'edge', 'intensity']
        },
        edgeLightness: {
            category: 'edge-color',
            range: [0, 100],
            minOutput: 10,
            blendMode: 'average',
            label: 'Edge Lightness',
            tags: ['visual', 'chromatic', 'edge', 'brightness']
        },
        edgeOpacity: {
            category: 'edge-color',
            range: [0.01, 1.0],
            minOutput: 0.01,
            blendMode: 'multiply',
            label: 'Edge Opacity',
            tags: ['visual', 'chromatic', 'edge', 'presence']
        },
        edgeWidth: {
            category: 'edge-geometry',
            range: [0.5, 5],
            minOutput: 0.5,
            blendMode: 'max',
            label: 'Edge Width',
            tags: ['visual', 'geometric', 'edge', 'thickness']
        }
    };

    function getSource(name) {
        return SOURCES[name] || null;
    }

    function getTarget(name) {
        return TARGETS[name] || null;
    }

    function listSources(typeFilter) {
        if (!typeFilter) return Object.keys(SOURCES);
        return Object.keys(SOURCES).filter(k => SOURCES[k].type === typeFilter);
    }

    function listTargets(categoryFilter) {
        if (!categoryFilter) return Object.keys(TARGETS);
        return Object.keys(TARGETS).filter(k => TARGETS[k].category === categoryFilter);
    }

    return {
        SOURCES,
        TARGETS,
        getSource,
        getTarget,
        listSources,
        listTargets
    };
})();

// Export
if (typeof window !== 'undefined') window.UPB_ENDPOINTS = UPB_ENDPOINTS;
if (typeof module !== 'undefined') module.exports = UPB_ENDPOINTS;


// ═══ MODULE: modules/upb/blenders.js ═══
const UPB_BLENDERS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BLENDERS MODULE
     * Functions for combining multiple normalized [0,1] values into one.
     * Used when multiple data sources drive a single visual target.
     */

    const BLENDERS = {
        // Last one wins (Default legacy behavior)
        replace: (values) => {
            if (!values || values.length === 0) return 0;
            return values[values.length - 1];
        },

        // Average of all inputs
        average: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            let weightSum = 0;

            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
                weightSum += w;
            }
            return sum / Math.max(1, weightSum);
        },

        // Additive (clamped to 1)
        add: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
            }
            return Math.min(1, sum);
        },

        // Multiplicative
        multiply: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let product = 1;
            for (let i = 0; i < values.length; i++) {
                // Determine effect strength by weight
                // w=1 -> full effect, w=0 -> no change (multiplier 1)
                const w = (weights && weights[i]) || 1;
                const v = values[i];
                // Interpolate between 1 (no effect) and v (full effect)
                const effectiveValue = 1 - (w * (1 - v));
                product *= effectiveValue;
            }
            return product;
        },

        // Maximum value (dominant signal wins)
        max: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.max(...values);
        },

        // Minimum value
        min: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.min(...values);
        }
    };

    /**
     * Apply blending mode
     */
    function blend(mode, values, weights) {
        const fn = BLENDERS[mode] || BLENDERS.replace;
        return fn(values, weights);
    }

    return {
        BLENDERS,
        blend
    };

})();

// Export
if (typeof window !== 'undefined') window.UPB_BLENDERS = UPB_BLENDERS;
if (typeof module !== 'undefined') module.exports = UPB_BLENDERS;


// ═══ MODULE: modules/upb/bindings.js ═══
const UPB_BINDINGS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BINDINGS GRAPH MODULE
     * Core engine for Many-to-Many property binding.
     * 
     * Dependencies: UPB_SCALES, UPB_ENDPOINTS
     */

    // =========================================================================
    // CLASS: BINDING
    // A single connection between a Data Source and a Visual Target
    // =========================================================================
    function Binding(source, target, options) {
        options = options || {};

        this.id = options.id || Math.random().toString(36).substr(2, 9);
        this.source = source;      // e.g., 'token_estimate'
        this.target = target;      // e.g., 'nodeSize'
        this.scale = options.scale || 'linear';
        this.weight = options.weight !== undefined ? options.weight : 1.0;
        this.range = options.range || null; // Override target default range

        // Metadata
        this.active = true;
    }

    Binding.prototype.apply = function (node, sourceValue, dataMin, dataMax) {
        if (!this.active) return null;

        // 1. Normalize
        const SCALES = window.UPB_SCALES;
        if (!SCALES) {
            console.error('[UPB] UPB_SCALES not found');
            return 0;
        }

        // Get domain for discrete scales if needed
        const ENDPOINTS = window.UPB_ENDPOINTS;
        const sourceDef = ENDPOINTS ? ENDPOINTS.getSource(this.source) : null;
        const domain = sourceDef ? sourceDef.values : null;

        const normalized = SCALES.applyScale(this.scale, sourceValue, dataMin, dataMax, domain);

        // 2. Map to Target Range
        const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(this.target) : null;

        // Use binding override range, or target default, or fallback [0,1]
        const range = this.range || (targetDef ? targetDef.range : [0, 1]);

        // Interpolate
        return range[0] + normalized * (range[1] - range[0]);
    };


    // =========================================================================
    // CLASS: BINDING GRAPH
    // Manages all active bindings and evaluates them against nodes
    // =========================================================================
    function BindingGraph() {
        this._bindings = {}; // target_key -> [Binding, Binding, ...]
        this._dataRanges = {}; // source_key -> {min, max} cache
    }

    BindingGraph.prototype.bind = function (source, target, options) {
        if (!this._bindings[target]) {
            this._bindings[target] = [];
        }

        // Check for exclusivity (replace existing if 1:1 implied, or add if N:1 supported)
        // For now, simple append. Blending logic handles the rest.
        const binding = new Binding(source, target, options);
        this._bindings[target].push(binding);

        console.log(`[UPB] Bound ${source} -> ${target} (${options?.scale || 'linear'})`);
        return binding;
    };

    BindingGraph.prototype.unbind = function (source, target) {
        if (!this._bindings[target]) return;

        if (source === '*') {
            // Unbind all for this target
            delete this._bindings[target];
        } else {
            // Remove specific binding
            this._bindings[target] = this._bindings[target].filter(b => b.source !== source);
            if (this._bindings[target].length === 0) {
                delete this._bindings[target];
            }
        }
    };

    BindingGraph.prototype.clear = function () {
        this._bindings = {};
        this._dataRanges = {};
    };

    BindingGraph.prototype.getBindingsFor = function (target) {
        return this._bindings[target] || [];
    };

    /**
     * Set data ranges explicitly (usually calculated by data-manager)
     */
    BindingGraph.prototype.setDataRanges = function (ranges) {
        this._dataRanges = ranges || {};
    };

    /**
     * Evaluate all bindings for a single node
     * Returns: { nodeSize: 12.5, hue: 200, ... }
     */
    BindingGraph.prototype.evaluate = function (node) {
        const result = {};
        const targets = Object.keys(this._bindings);

        for (let i = 0; i < targets.length; i++) {
            const targetKey = targets[i];
            const bindings = this._bindings[targetKey];

            if (!bindings || bindings.length === 0) continue;

            const values = [];
            const weights = [];

            // Calculate contribution from each binding
            for (let j = 0; j < bindings.length; j++) {
                const binding = bindings[j];
                const sourceKey = binding.source;

                // Get safe value
                const val = this._getNodeValue(node, sourceKey);
                if (val === null || val === undefined) continue;

                // Get range
                const range = this._dataRanges[sourceKey] || { min: 0, max: 100 };

                const calculated = binding.apply(node, val, range.min, range.max);
                values.push(calculated);
                weights.push(binding.weight);
            }

            // BLEND using UPB_BLENDERS (Phase 6: Robustness)
            if (values.length > 0) {
                // Get target definition for blend mode and minOutput
                const ENDPOINTS = window.UPB_ENDPOINTS;
                const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(targetKey) : null;
                const blendMode = targetDef?.blendMode || 'replace';
                const minOutput = targetDef?.minOutput;

                // Apply blending
                const BLENDERS = window.UPB_BLENDERS;
                let finalValue;
                if (BLENDERS && typeof BLENDERS.blend === 'function') {
                    finalValue = BLENDERS.blend(blendMode, values, weights);
                } else {
                    // Fallback: last wins
                    finalValue = values[values.length - 1];
                }

                // Apply minOutput clamping
                if (minOutput !== undefined && finalValue < minOutput) {
                    finalValue = minOutput;
                }

                result[targetKey] = finalValue;
            }
        }
        return result;
    };

    BindingGraph.prototype.evaluateAll = function (nodes) {
        return nodes.map(n => ({
            id: n.id,
            visuals: this.evaluate(n)
        }));
    };

    // Helper to traverse node properties safely
    BindingGraph.prototype._getNodeValue = function (node, key) {
        if (node[key] !== undefined) return node[key];
        if (node.dimensions && node.dimensions[key] !== undefined) return node.dimensions[key];

        // Dimension alias map
        const aliases = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };
        if (aliases[key] && node.dimensions) return node.dimensions[aliases[key]];

        return null;
    };

    // Default singleton instance
    const defaultGraph = new BindingGraph();

    // =========================================================================
    // PRESET BINDINGS (T8-T9)
    // Recommended mappings for tree-sitter analysis data
    // =========================================================================
    const PRESETS = {
        // T8: Purity → Lightness (pure code appears brighter)
        'purity-lightness': {
            source: 'D6_pure_score',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],  // 30% dark (impure) to 90% bright (pure)
            description: 'Pure code appears brighter'
        },

        // T9: PageRank → Node Size (influential nodes are larger)
        'pagerank-size': {
            source: 'pagerank',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 25],
            description: 'Influential nodes appear larger'
        },

        // Bonus: Betweenness → Saturation (bridge nodes are more vivid)
        'betweenness-saturation': {
            source: 'betweenness_centrality',
            target: 'saturation',
            scale: 'sqrt',
            range: [20, 100],
            description: 'Bridge nodes appear more vivid'
        },

        // Bonus: Topology Role → Hue (different roles, different colors)
        'topology-hue': {
            source: 'topology_role',
            target: 'hue',
            scale: 'discrete',
            // orphan=red, root=green, leaf=blue, hub=purple, internal=gray
            range: [0, 360],
            description: 'Topology roles have distinct colors'
        },

        // =====================================================================
        // CONTROL FLOW PRESETS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity → Node Size (complex functions are larger)
        'complexity-size': {
            source: 'cyclomatic_complexity',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 30],
            description: 'Complex functions appear larger'
        },

        // Nesting Depth → Saturation (deeply nested = more vivid warning)
        'nesting-saturation': {
            source: 'max_nesting_depth',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Deeply nested code appears more vivid'
        },

        // Complexity → Hue (simple=green, complex=red gradient)
        'complexity-hue': {
            source: 'cyclomatic_complexity',
            target: 'hue',
            scale: 'linear',
            range: [120, 0],  // Green (120) → Red (0)
            description: 'Simple=green, Complex=red'
        },

        // =====================================================================
        // RPBL PRESETS (P4-05/07/08) - Theory Character Visualization
        // =====================================================================

        // Responsibility → Size (high responsibility = larger)
        'responsibility-size': {
            source: 'rpbl_responsibility',
            target: 'nodeSize',
            scale: 'linear',
            range: [3, 25],
            description: 'High responsibility nodes appear larger'
        },

        // Purity → Lightness (pure = bright, impure = dark)
        'rpbl-purity-lightness': {
            source: 'rpbl_purity',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],
            description: 'Pure code appears brighter'
        },

        // Boundary → Saturation (exposed = vivid, internal = muted)
        'boundary-saturation': {
            source: 'rpbl_boundary',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Exposed boundaries appear more vivid'
        },

        // Lifecycle → Opacity (stable = solid, transient = faded)
        'lifecycle-opacity': {
            source: 'rpbl_lifecycle',
            target: 'opacity',
            scale: 'linear',
            range: [0.3, 1.0],
            description: 'Long-lived code appears more solid'
        }
    };

    /**
     * Apply a named preset to the default graph
     * @param {string} presetName - Key from PRESETS
     * @returns {Binding|null}
     */
    function applyPreset(presetName) {
        const preset = PRESETS[presetName];
        if (!preset) {
            console.warn(`[UPB] Unknown preset: ${presetName}`);
            return null;
        }
        return defaultGraph.bind(preset.source, preset.target, {
            id: `preset-${presetName}`,
            scale: preset.scale,
            range: preset.range
        });
    }

    /**
     * Apply all presets
     */
    function applyAllPresets() {
        Object.keys(PRESETS).forEach(name => applyPreset(name));
        console.log(`[UPB] Applied ${Object.keys(PRESETS).length} preset bindings`);
    }

    /**
     * List available presets
     */
    function listPresets() {
        return Object.keys(PRESETS).map(name => ({
            name,
            ...PRESETS[name]
        }));
    }

    return {
        Binding,
        BindingGraph,
        defaultGraph,
        PRESETS,
        applyPreset,
        applyAllPresets,
        listPresets
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB_BINDINGS = UPB_BINDINGS;
if (typeof module !== 'undefined') module.exports = UPB_BINDINGS;


// ═══ MODULE: modules/upb/index.js ═══
const UPB = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - INDEX (AGGREGATOR)
     * Public API for the visualization intelligence layer.
     */

    // Dependency check
    const SCALES = window.UPB_SCALES;
    const ENDPOINTS = window.UPB_ENDPOINTS;
    const BLENDERS = window.UPB_BLENDERS;
    const BINDINGS = window.UPB_BINDINGS;

    if (!SCALES || !ENDPOINTS || !BLENDERS || !BINDINGS) {
        console.error('[UPB] Missing dependencies. Ensure all UPB modules are loaded.');
        return {};
    }

    // Public API
    return {
        // Version
        VERSION: '1.0.0',

        // Modules Access
        SCALES: SCALES,
        ENDPOINTS: ENDPOINTS,
        BLENDERS: BLENDERS,
        BINDINGS: BINDINGS,

        // Quick Aliases for Legacy Compatibility
        DATA_SOURCES: ENDPOINTS.SOURCES,
        VISUAL_TARGETS: ENDPOINTS.TARGETS,

        // Core Actions
        /**
         * Create a new binding
         * @param {string} sourceKey 
         * @param {string} targetKey 
         * @param {object} options 
         */
        bind: function (sourceKey, targetKey, options) {
            return BINDINGS.defaultGraph.bind(sourceKey, targetKey, options);
        },

        /**
         * Remove mappings
         * @param {string} sourceKey 
         * @param {string} targetKey 
         */
        unbind: function (sourceKey, targetKey) {
            return BINDINGS.defaultGraph.unbind(sourceKey, targetKey);
        },

        /**
         * Evaluate visual state for a node
         * @param {object} node 
         */
        evaluate: function (node) {
            return BINDINGS.defaultGraph.evaluate(node);
        },

        /**
         * Bulk evaluation
         * @param {Array} nodes 
         */
        apply: function (nodes) {
            // Note: Data ranges should be set on BINDINGS.defaultGraph before calling this
            // usually by the DataManager
            return BINDINGS.defaultGraph.evaluateAll(nodes);
        },

        /**
         * Initializer - call when data is ready
         */
        init: function (dataRanges) {
            if (dataRanges) {
                BINDINGS.defaultGraph.setDataRanges(dataRanges);
            }
            console.log('[UPB] Universal Property Binder Initialized');
        },

        /**
         * Check if a target has active bindings
         * Used by other modules to defer to UPB when bindings exist
         * @param {string} targetKey - e.g., 'hue', 'nodeSize'
         * @returns {boolean}
         */
        hasBinding: function (targetKey) {
            const bindings = BINDINGS.defaultGraph.getBindingsFor(targetKey);
            return bindings && bindings.length > 0;
        },

        /**
         * Check if any color-related target has active bindings
         * Convenience method for modules that set node.color
         * @returns {boolean}
         */
        hasColorBinding: function () {
            return this.hasBinding('hue') ||
                   this.hasBinding('saturation') ||
                   this.hasBinding('lightness') ||
                   this.hasBinding('opacity');
        },

        /**
         * Check if any edge-related target has active bindings
         * Convenience method for edge-system.js to defer to UPB
         * @returns {boolean}
         */
        hasEdgeBinding: function () {
            return this.hasBinding('edgeHue') ||
                   this.hasBinding('edgeSaturation') ||
                   this.hasBinding('edgeLightness') ||
                   this.hasBinding('edgeOpacity') ||
                   this.hasBinding('edgeWidth');
        }
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB = UPB;
if (typeof module !== 'undefined') module.exports = UPB;


// ═══ MODULE: modules/control-bar.js ═══
/**
 * CONTROL BAR MODULE - Visual Mapping Command Center
 *
 * A persistent control bar (like ChatGPT/Claude input) that allows dynamic
 * mapping of any data characteristic to any visual/physics property.
 *
 * Features:
 * - Always visible at bottom of screen
 * - Works with selected nodes or node groups
 * - Dropdown to choose data source (any field)
 * - Dropdown to choose visual target (size, color, position, physics...)
 * - Group comparison with numbered badges
 * - Real-time preview as you adjust
 *
 * Depends on: DATA, COLOR, ANIM, SELECT
 */

const CONTROL_BAR = (function () {
    'use strict';

    // =========================================================================
    // AVAILABLE DATA SOURCES (what we can map FROM)
    // =========================================================================

    // =========================================================================
    // AVAILABLE DATA SOURCES (Delegated to UPB)
    // =========================================================================
    const DATA_SOURCES = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.SOURCES) || {
        // Fallback for safety if UPB fails to load
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Delegated to UPB)
    // =========================================================================
    const VISUAL_TARGETS = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.TARGETS) || {
        // Fallback
        nodeSize: { label: 'Node Size', category: 'appearance', range: [1, 30] }
    };

    // =========================================================================
    // SCALE FUNCTIONS (Delegated to UPB)
    // =========================================================================
    const SCALES = (window.UPB && window.UPB.SCALES && window.UPB.SCALES.SCALES) || {
        linear: (v, min, max) => (v - min) / (max - min || 1)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _visible = false;
    let _container = null;
    let _activeMapping = null;
    let _groups = [];         // [{id, name, nodeIds, color}]
    let _groupCounter = 0;
    let _interval = null;

    // Current mapping configuration
    let _config = {
        source: 'token_estimate',
        target: 'nodeSize',
        scale: 'sqrt',
        scope: 'selection',   // 'selection' | 'all' | 'group:X'
        invert: false
    };

    // =========================================================================
    // UI BUILDING
    // =========================================================================

    let _isDocked = false;

    function createUI() {
        if (_container) return _container;

        const dockContainer = document.getElementById('control-bar-container');
        _isDocked = !!dockContainer;

        _container = document.createElement('div');
        _container.id = 'control-bar';
        _container.className = _isDocked ? 'control-bar docked' : 'control-bar';

        // Scope Section
        const scopeHTML = `
            <div class="control-section scope-section">
                <label>SCOPE</label>
                <div class="row-group">
                    <select id="cb-scope" class="cb-select">
                        <option value="selection">Selected Nodes</option>
                        <option value="all">All Nodes</option>
                        <optgroup label="Groups" id="cb-groups-optgroup"></optgroup>
                    </select>
                    <button id="cb-add-group" class="cb-btn cb-btn-small" title="Create group from selection">+G</button>
                    <span id="cb-node-count" class="cb-badge">0</span>
                </div>
            </div>
        `;

        // Map FROM
        const sourceHTML = `
            <div class="control-section">
                <label>MAP DATA SOURCE</label>
                <select id="cb-source" class="cb-select full-width">
                    <optgroup label="Structural">
                        <option value="token_estimate">Token Count</option>
                        <option value="line_count">Line Count</option>
                        <option value="size_bytes">File Size</option>
                        <option value="code_lines">Code Lines</option>
                        <option value="complexity_density">Complexity</option>
                        <option value="cohesion">Cohesion</option>
                    </optgroup>
                    <optgroup label="Temporal">
                        <option value="age_days">Age (days)</option>
                    </optgroup>
                    <optgroup label="Graph">
                        <option value="in_degree">In-Degree</option>
                        <option value="out_degree">Out-Degree</option>
                    </optgroup>
                    <optgroup label="Categorical">
                        <option value="tier">Tier</option>
                        <option value="ring">Ring</option>
                        <option value="layer">Layer</option>
                        <option value="role">Role</option>
                        <option value="format_category">Format</option>
                        <option value="effect">Effect</option>
                    </optgroup>
                    <optgroup label="Boolean">
                        <option value="is_test">Is Test?</option>
                        <option value="is_config">Is Config?</option>
                        <option value="is_stale">Is Stale?</option>
                    </optgroup>
                    <optgroup label="Tree-sitter Analysis">
                        <option value="D6_pure_score">Purity Score (0-1)</option>
                        <option value="D6_EFFECT">Purity Rating</option>
                        <option value="pagerank">PageRank Influence</option>
                        <option value="betweenness_centrality">Betweenness (Bridge)</option>
                        <option value="topology_role">Topology Role</option>
                    </optgroup>
                    <optgroup label="Control Flow (P3-09)">
                        <option value="cyclomatic_complexity">Cyclomatic Complexity</option>
                        <option value="complexity_rating">Complexity Rating</option>
                        <option value="max_nesting_depth">Nesting Depth</option>
                        <option value="nesting_rating">Nesting Rating</option>
                    </optgroup>
                    <optgroup label="RPBL Character">
                        <option value="rpbl_responsibility">Responsibility (R)</option>
                        <option value="rpbl_purity">Purity (P)</option>
                        <option value="rpbl_boundary">Boundary (B)</option>
                        <option value="rpbl_lifecycle">Lifecycle (L)</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Arrow (only for float mode, skip or style differently in dock)
        const arrowHTML = _isDocked ? '' : `
            <div class="control-section arrow-section">
                <span class="arrow">&#8594;</span>
            </div>
        `;

        // Map TO
        const targetHTML = `
            <div class="control-section">
                <label>TO VISUAL PROPERTY</label>
                <select id="cb-target" class="cb-select full-width">
                    <optgroup label="Appearance">
                        <option value="nodeSize">Node Size</option>
                        <option value="hue">Color Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="lightness">Lightness</option>
                        <option value="opacity">Opacity</option>
                    </optgroup>
                    <optgroup label="Position">
                        <option value="xPosition">X Position</option>
                        <option value="yPosition">Y Position</option>
                        <option value="zPosition">Z Depth</option>
                        <option value="radius">Radial Distance</option>
                    </optgroup>
                    <optgroup label="Physics">
                        <option value="charge">Charge (repel)</option>
                        <option value="mass">Mass</option>
                    </optgroup>
                    <optgroup label="Animation">
                        <option value="pulseSpeed">Pulse Speed</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Scale
        const scaleHTML = `
            <div class="control-section">
                <label>SCALING</label>
                <select id="cb-scale" class="cb-select full-width">
                    <option value="linear">Linear (even spread)</option>
                    <option value="sqrt" selected>Sqrt (compress giants)</option>
                    <option value="log">Log (heavy compress)</option>
                    <option value="exp">Exp (emphasize extremes)</option>
                    <option value="inverse">Inverse (flip)</option>
                </select>
            </div>
        `;

        // Actions
        const actionsHTML = `
            <div class="control-section actions-section">
                <button id="cb-apply" class="cb-btn cb-btn-primary full-width">APPLY MAPPING</button>
                <button id="cb-reset" class="cb-btn full-width" style="margin-top:4px">Reset</button>
            </div>
        `;

        // Groups Display
        const groupsHTML = `
            <div class="control-section groups-section" id="cb-groups-display"></div>
        `;

        // Toggle (only for float mode)
        const toggleHTML = _isDocked ? '' : `
            <button id="cb-toggle" class="cb-toggle" title="Toggle Control Bar">
                <span class="chevron">&#9660;</span>
            </button>
        `;

        _container.innerHTML = `
            <div class="control-bar-inner">
                ${scopeHTML}
                ${sourceHTML}
                ${arrowHTML}
                ${targetHTML}
                ${scaleHTML}
                ${actionsHTML}
                ${groupsHTML}
                ${toggleHTML}
            </div>
        `;

        // Add styles
        addStyles();

        // Attach event listeners
        attachListeners();

        if (_isDocked) {
            dockContainer.appendChild(_container);
        } else {
            document.body.appendChild(_container);
        }

        _visible = true;

        return _container;
    }

    function addStyles() {
        if (document.getElementById('control-bar-styles')) return;

        const style = document.createElement('style');
        style.id = 'control-bar-styles';
        style.textContent = `
            /* BASE STYLES */
            .control-bar {
                font-family: 'SF Mono', 'Consolas', monospace;
            }

            /* FLOATING MODE */
            .control-bar:not(.docked) {
                position: fixed;
                bottom: 16px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 900px;
                width: calc(100% - 48px);
                z-index: 9999;
                background: linear-gradient(180deg, rgba(28, 30, 35, 0.95) 0%, rgba(22, 24, 28, 0.98) 100%);
                backdrop-filter: blur(12px);
                border: 1px solid rgba(100, 105, 115, 0.15);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.35);
                transition: transform 0.3s ease, opacity 0.3s ease;
            }

            .control-bar:not(.docked) .control-bar-inner {
                display: flex;
                align-items: center;
                gap: 16px;
                padding: 12px 20px;
                overflow-x: auto;
            }

            /* DOCKED MODE */
            .control-bar.docked {
                position: static;
                width: 100%;
                background: transparent;
                border: none;
                box-shadow: none;
                padding: 0;
            }

            .control-bar.docked .control-bar-inner {
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 0;
            }

            /* SHARED COMPONENTS */
            .control-section {
                display: flex;
                flex-direction: column;
                gap: 4px;
                width: 100%; /* Full width when docked */
            }

            .control-section label {
                font-size: 9px;
                font-weight: 600;
                color: rgba(140, 145, 155, 0.6);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .row-group {
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .cb-select {
                background: rgba(35, 38, 45, 0.85);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #c8ccd5;
                padding: 6px 10px;
                font-size: 11px;
                font-family: inherit;
                cursor: pointer;
                transition: all 0.2s;
                flex: 1;
            }

            .cb-select:hover {
                background: rgba(45, 48, 55, 0.9);
                border-color: rgba(120, 125, 135, 0.35);
            }
            
            .cb-select:focus {
                outline: none;
                border-color: var(--accent, #4a9eff);
            }

            .full-width {
                width: 100%;
            }

            .cb-btn {
                background: rgba(50, 55, 65, 0.6);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #b0b5c0;
                padding: 6px 12px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
            }
            .actions-section {
                width: 100%;
            }
            .cb-btn:hover {
                background: rgba(65, 70, 80, 0.75);
                color: #fff;
            }

            .cb-btn-primary {
                background: var(--accent-dim, rgba(74, 158, 255, 0.15));
                color: var(--accent, #4a9eff);
                border-color: var(--accent, #4a9eff);
            }

            .cb-btn-primary:hover {
                background: var(--accent, #4a9eff);
                color: #000;
            }

            .cb-btn-small {
                padding: 4px 8px;
                min-width: 30px;
            }

            .cb-badge {
                font-size: 10px;
                color: #666;
                min-width: 15px;
                text-align: center;
            }

            /* GROUP CHIPS */
            .groups-section {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 4px;
            }

            .group-chip {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
                padding: 2px 8px;
                font-size: 10px;
                cursor: default;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .group-color {
                width: 6px;
                height: 6px;
                border-radius: 50%;
            }

            .group-remove {
                margin-left: 4px;
                cursor: pointer;
                opacity: 0.5;
            }
            .group-remove:hover { opacity: 1; }
        `;

        document.head.appendChild(style);
    }

    function attachListeners() {
        // Toggle collapse
        const toggleBtn = document.getElementById('cb-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', toggle);
        }

        // Scope change
        const scopeSelect = document.getElementById('cb-scope');
        if (scopeSelect) {
            scopeSelect.addEventListener('change', (e) => {
                _config.scope = e.target.value;
                updateNodeCount();
            });
        }

        // Source change
        const sourceSelect = document.getElementById('cb-source');
        if (sourceSelect) {
            sourceSelect.addEventListener('change', (e) => {
                _config.source = e.target.value;
            });
        }

        // Target change
        const targetSelect = document.getElementById('cb-target');
        if (targetSelect) {
            targetSelect.addEventListener('change', (e) => {
                _config.target = e.target.value;
            });
        }

        // Scale change
        const scaleSelect = document.getElementById('cb-scale');
        if (scaleSelect) {
            scaleSelect.addEventListener('change', (e) => {
                _config.scale = e.target.value;
            });
        }

        // Apply button
        const applyBtn = document.getElementById('cb-apply');
        if (applyBtn) {
            applyBtn.addEventListener('click', applyMapping);
        }

        // Reset button
        const resetBtn = document.getElementById('cb-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', resetMapping);
        }

        // Add group button
        const addGroupBtn = document.getElementById('cb-add-group');
        if (addGroupBtn) {
            addGroupBtn.addEventListener('click', createGroupFromSelection);
        }

        // Update node count periodically
        _interval = setInterval(updateNodeCount, 1000);
    }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        if (_interval) {
            clearInterval(_interval);
            _interval = null;
        }

        // Remove listeners by cloning/replacing (brute force clean)
        // or by removing specific named listeners if we refactored attachListeners
        // Here we just remove the container from DOM which unhooks DOM listeners
        if (_container && _container.parentNode) {
            _container.parentNode.removeChild(_container);
        }
        _container = null;
        _visible = false;

        console.log('[CONTROL_BAR] Disposed');
    }

    // =========================================================================
    // GROUP MANAGEMENT
    // =========================================================================

    const GROUP_COLORS = [
        '#4a9eff', '#ff6b6b', '#51cf66', '#ffd43b',
        '#cc5de8', '#20c997', '#ff922b', '#748ffc'
    ];

    function createGroupFromSelection() {
        const selectedIds = getSelectedNodeIds();
        if (selectedIds.length === 0) {
            showToast('Select nodes first to create a group');
            return;
        }

        _groupCounter++;
        const groupId = `group-${_groupCounter}`;
        const color = GROUP_COLORS[(_groupCounter - 1) % GROUP_COLORS.length];

        const group = {
            id: groupId,
            name: `Group ${_groupCounter}`,
            nodeIds: [...selectedIds],
            color: color
        };

        _groups.push(group);
        updateGroupsUI();
        showToast(`Created ${group.name} with ${selectedIds.length} nodes`);
    }

    function removeGroup(groupId) {
        _groups = _groups.filter(g => g.id !== groupId);
        updateGroupsUI();
    }

    function updateGroupsUI() {
        // Update dropdown
        const optgroup = document.getElementById('cb-groups-optgroup');
        if (optgroup) {
            optgroup.innerHTML = _groups.map(g =>
                `<option value="group:${g.id}">${g.name} (${g.nodeIds.length})</option>`
            ).join('');
        }

        // Update chips display
        const display = document.getElementById('cb-groups-display');
        if (display) {
            display.innerHTML = _groups.map(g => `
                <div class="group-chip" data-group="${g.id}">
                    <span class="group-color" style="background: ${g.color}"></span>
                    <span class="group-name">${g.name}</span>
                    <span class="group-count">${g.nodeIds.length}</span>
                    <span class="group-remove" onclick="CONTROL_BAR.removeGroup('${g.id}')">&times;</span>
                </div>
            `).join('');
        }
    }

    // =========================================================================
    // MAPPING APPLICATION
    // =========================================================================

    function getTargetNodes() {
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        const allNodes = dm?.getNodes ? dm.getNodes() : (typeof graphNodes !== 'undefined' ? graphNodes : []);

        if (_config.scope === 'all') {
            return allNodes;
        }

        if (_config.scope === 'selection') {
            const selectedIds = getSelectedNodeIds();
            return allNodes.filter(n => selectedIds.includes(n.id));
        }

        if (_config.scope.startsWith('group:')) {
            const groupId = _config.scope.replace('group:', '');
            const group = _groups.find(g => g.id === groupId);
            if (group) {
                return allNodes.filter(n => group.nodeIds.includes(n.id));
            }
        }

        return [];
    }

    function applyMapping() {
        if (!window.UPB) {
            console.error('UPB not loaded');
            return;
        }

        const nodes = getTargetNodes();
        if (nodes.length === 0) {
            showToast('No nodes to map. Select nodes or change scope.');
            return;
        }

        const sourceKey = _config.source;
        const targetKey = _config.target;

        // 1. Create/Update Binding in UPB Graph
        window.UPB.bind(sourceKey, targetKey, {
            id: `cb-binding-${Date.now()}`,
            scale: _config.scale,
            range: VISUAL_TARGETS[targetKey]?.range
        });

        // 2. Set Data Ranges for normalization (Phase 6: use DATA.getRange)
        // Map control-bar scope to DATA.getRange scope
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        if (dm && typeof dm.getRange === 'function') {
            const dataScope = _config.scope === 'selection' ? 'selection' :
                _config.scope === 'all' ? 'global' : 'visible';
            const range = dm.getRange(sourceKey, dataScope);
            if (window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = range;
            }
        } else {
            // Fallback: calculate ad-hoc if DATA.getRange not available
            const values = nodes.map(n => getNodeValue(n, sourceKey)).filter(v => typeof v === 'number');
            if (values.length > 0 && window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = {
                    min: Math.min(...values),
                    max: Math.max(...values)
                };
            }
        }

        // 3. Apply to Nodes
        const updates = window.UPB.apply(nodes);

        // 4. Render Updates
        updates.forEach(update => {
            const node = nodes.find(n => n.id === update.id);
            if (node) {
                Object.keys(update.visuals).forEach(key => {
                    applyToNode(node, key, update.visuals[key]);
                });
            }
        });

        // Refresh graph
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }

        showToast(`Bound ${sourceKey} -> ${targetKey} via UPB`);
        console.log(`[CONTROL_BAR] UPB Binding Active: ${sourceKey} -> ${targetKey}`);
    }

    function getNodeValue(node, key) {
        // Direct property
        if (node[key] !== undefined) return node[key];

        // Nested in dimensions
        if (node.dimensions && node.dimensions[key] !== undefined) {
            return node.dimensions[key];
        }

        // Check common dimension mappings
        const dimMap = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };

        if (dimMap[key] && node.dimensions) {
            return node.dimensions[dimMap[key]];
        }

        return null;
    }

    function applyToNode(node, targetKey, value) {
        switch (targetKey) {
            case 'nodeSize':
                node.val = value;
                break;

            case 'hue':
                // Use OKLCH color space via COLOR module
                const hueOklch = window.COLOR.hexToOklch(node.color || '#808080');
                hueOklch.h = value;
                node.color = window.COLOR.toHex(hueOklch);
                break;

            case 'saturation':
                // Map saturation (0-100) to OKLCH chroma (0-0.3)
                const satOklch = window.COLOR.hexToOklch(node.color || '#808080');
                satOklch.c = (value / 100) * 0.3;
                node.color = window.COLOR.toHex(satOklch);
                break;

            case 'lightness':
                // Map lightness (0-100) to OKLCH lightness (0-1)
                const litOklch = window.COLOR.hexToOklch(node.color || '#808080');
                litOklch.l = value / 100;
                node.color = window.COLOR.toHex(litOklch);
                break;

            case 'opacity':
                node.opacity = value;
                // Update color alpha if using rgba
                if (node.color && !node.color.startsWith('hsl')) {
                    node.color = setAlpha(node.color, value);
                }
                break;

            case 'xPosition':
                node.fx = value;
                break;

            case 'yPosition':
                node.fy = value;
                break;

            case 'zPosition':
                node.fz = value;
                break;

            case 'radius':
                // Position on a circle at given radius
                const angle = (node.fileIdx || Math.random() * 100) * 0.618 * Math.PI * 2;
                node.fx = Math.cos(angle) * value;
                node.fy = Math.sin(angle) * value;
                break;

            case 'charge':
                node.__charge = value;
                break;

            case 'mass':
                node.__mass = value;
                break;

            case 'pulseSpeed':
                node.__pulseSpeed = value;
                break;

            default:
                node[targetKey] = value;
        }
    }

    function setAlpha(colorStr, alpha) {
        // Simple alpha injection
        if (colorStr.startsWith('rgba')) {
            return colorStr.replace(/[\d.]+\)$/, `${alpha})`);
        }
        if (colorStr.startsWith('rgb')) {
            return colorStr.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        }
        return colorStr;
    }

    function resetMapping() {
        // Clear fixed positions
        const nodes = getTargetNodes();
        nodes.forEach(n => {
            delete n.fx;
            delete n.fy;
            delete n.fz;
            delete n.__charge;
            delete n.__mass;
            delete n.__pulseSpeed;
        });

        // Reheat simulation
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3ReheatSimulation();
        }

        showToast('Reset node positions and custom properties');
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function getSelectedNodeIds() {
        if (typeof SELECT !== 'undefined' && SELECT.getSelectedNodes) {
            return SELECT.getSelectedNodes().map(n => n.id);
        }
        if (typeof SELECTED_NODE_IDS !== 'undefined') {
            return Array.from(SELECTED_NODE_IDS);
        }
        return [];
    }

    function updateNodeCount() {
        const badge = document.getElementById('cb-node-count');
        if (!badge) return;

        const nodes = getTargetNodes();
        badge.textContent = nodes.length;
    }

    function showToast(msg) {
        if (typeof window.showToast === 'function') {
            window.showToast(msg);
        } else {
            console.log(`[CONTROL_BAR] ${msg}`);
        }
    }

    function toggle() {
        if (_container) {
            _container.classList.toggle('collapsed');
            _visible = !_container.classList.contains('collapsed');
        }
    }

    function show() {
        if (_container) {
            _container.classList.remove('collapsed');
            _visible = true;
        }
    }

    function hide() {
        if (_container) {
            _container.classList.add('collapsed');
            _visible = false;
        }
    }

    // =========================================================================
    // INIT
    // =========================================================================

    function init() {
        createUI();
        updateNodeCount();
        console.log('[CONTROL_BAR] Initialized');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        toggle,
        show,
        hide,
        applyMapping,
        resetMapping,
        createGroupFromSelection,
        removeGroup,
        get visible() { return _visible; },
        get config() { return _config; },
        get groups() { return _groups; },
        DATA_SOURCES,
        VISUAL_TARGETS,
        SCALES,
        dispose
    };

})();

// Auto-init when DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => CONTROL_BAR.init());
} else {
    // Small delay to ensure other modules are loaded
    setTimeout(() => CONTROL_BAR.init(), 100);
}


// ═══ MODULE: modules/main.js ═══
/**
 * MAIN.JS - MODULE INTEGRATION ENTRY POINT
 *
 * This file wires up all modules and provides backward compatibility
 * for HTML onclick handlers and global function calls.
 *
 * Module Loading Order (already handled by visualize_graph_webgl.py):
 * 1. performance.js       - Performance subsystem
 * 2. core.js              - Constants & utilities
 * 3. node-accessors.js    - Node property functions
 * 4. color-engine.js      - OKLCH color system
 * 5. refresh-throttle.js  - Throttled graph updates
 * 6. legend-manager.js    - Legend system
 * 7. data-manager.js      - Data access layer
 * 8. animation.js         - Layout & animation controller
 * 9. selection.js         - Selection system
 * 10. panels.js           - Panel management
 * 11. sidebar.js          - Sidebar controls
 * 12. edge-system.js      - Edge coloring & modes
 * 13. file-viz.js         - File visualization modes
 * 14. control-bar.js      - Visual mapping command bar
 * 15. main.js             - This file (wiring)
 * 16. app.js              - Legacy monolith (shrinking)
 */

;(function() {
    'use strict';

    // =========================================================================
    // VERIFY MODULE LOADING
    // =========================================================================

    const REQUIRED_MODULES = [
        { name: 'CORE', module: typeof CORE !== 'undefined' ? CORE : null },
        { name: 'NODE', module: typeof NODE !== 'undefined' ? NODE : null },
        { name: 'COLOR', module: typeof COLOR !== 'undefined' ? COLOR : null },
        { name: 'REFRESH', module: typeof REFRESH !== 'undefined' ? REFRESH : null },
        { name: 'LEGEND', module: typeof LEGEND !== 'undefined' ? LEGEND : null },
        { name: 'DATA', module: typeof DATA !== 'undefined' ? DATA : null },
        { name: 'LAYOUT', module: typeof LAYOUT !== 'undefined' ? LAYOUT : null },  // UI Layout Engine
        { name: 'ANIM', module: typeof ANIM !== 'undefined' ? ANIM : null },
        { name: 'SELECT', module: typeof SELECT !== 'undefined' ? SELECT : null },
        { name: 'PANELS', module: typeof PANELS !== 'undefined' ? PANELS : null },
        { name: 'SIDEBAR', module: typeof SIDEBAR !== 'undefined' ? SIDEBAR : null },
        { name: 'EDGE', module: typeof EDGE !== 'undefined' ? EDGE : null },
        { name: 'FILE_VIZ', module: typeof FILE_VIZ !== 'undefined' ? FILE_VIZ : null },
        { name: 'CONTROL_BAR', module: typeof CONTROL_BAR !== 'undefined' ? CONTROL_BAR : null },
        // STARS module removed - nodes ARE the stars
        { name: 'HUD', module: typeof HUD !== 'undefined' ? HUD : null },
        { name: 'DIMENSION', module: typeof DIMENSION !== 'undefined' ? DIMENSION : null }
    ];

    const loaded = REQUIRED_MODULES.filter(m => m.module !== null);
    const missing = REQUIRED_MODULES.filter(m => m.module === null);

    console.log(`[MAIN] Modules loaded: ${loaded.length}/${REQUIRED_MODULES.length}`);
    if (missing.length > 0) {
        console.warn('[MAIN] Missing modules:', missing.map(m => m.name).join(', '));
    }

    // =========================================================================
    // WINDOW-LEVEL EXPORTS FOR HTML ONCLICK HANDLERS
    // =========================================================================

    // Selection functions
    if (typeof SELECT !== 'undefined') {
        window.clearSelection = SELECT.clear;
        window.setSelection = SELECT.set;
        window.toggleSelection = SELECT.toggle;
        window.getSelectedNodes = SELECT.getSelectedNodes;
    }

    // Animation functions
    if (typeof ANIM !== 'undefined') {
        window.applyLayoutPreset = ANIM.applyLayout;
        window.stopAnimation = ANIM.stop;
    }

    // Edge functions
    if (typeof EDGE !== 'undefined') {
        window.setEdgeMode = EDGE.setMode;
        window.cycleEdgeMode = EDGE.cycleMode;
        window.applyEdgeMode = EDGE.apply;
    }

    // File visualization functions
    if (typeof FILE_VIZ !== 'undefined') {
        window.setFileVizMode = FILE_VIZ.setMode;
        window.toggleFileMode = FILE_VIZ.toggle;
    }

    // Panel functions
    if (typeof PANELS !== 'undefined') {
        window.openPanel = PANELS.open;
        window.closePanel = PANELS.close;
        window.togglePanel = PANELS.toggle;
    }

    // Sidebar functions
    if (typeof SIDEBAR !== 'undefined') {
        window.setColorMode = SIDEBAR.setColorMode;
        window.setLayout = SIDEBAR.setLayout;
    }

    // Refresh function
    if (typeof REFRESH !== 'undefined') {
        window.throttledRefresh = REFRESH.throttled;
    }

    // Control bar functions
    if (typeof CONTROL_BAR !== 'undefined') {
        window.toggleControlBar = CONTROL_BAR.toggle;
        window.showControlBar = CONTROL_BAR.show;
        window.hideControlBar = CONTROL_BAR.hide;
        window.applyVisualMapping = CONTROL_BAR.applyMapping;
    }

    // =========================================================================
    // CROSS-MODULE INTEGRATION
    // =========================================================================

    /**
     * Initialize all modules with data
     * NOTE: Currently unused - app.js calls module inits directly in setupControls()
     * Kept for potential future centralization
     * @deprecated Use direct module init calls instead
     */
    window.initializeModules = function(data) {
        console.log('[MAIN] Initializing modules with data...');

        // Initialize DATA module
        if (typeof DATA !== 'undefined' && DATA.init) {
            DATA.init(data);
            console.log('[MAIN] DATA module initialized');
        }

        // Initialize LEGEND module
        if (typeof LEGEND !== 'undefined' && LEGEND.init) {
            LEGEND.init(data.nodes, data.links || data.edges);
            console.log('[MAIN] LEGEND module initialized');
        }

        // Initialize SIDEBAR
        if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
            SIDEBAR.init();
            console.log('[MAIN] SIDEBAR module initialized');
        }

        // Initialize PANELS command bar
        if (typeof PANELS !== 'undefined' && PANELS.initCommandBar) {
            PANELS.initCommandBar();
            console.log('[MAIN] PANELS module initialized');
        }

        // Initialize LAYOUT (replaces HudLayoutManager from app.js)
        if (typeof LAYOUT !== 'undefined' && LAYOUT.init) {
            LAYOUT.init();
            console.log('[MAIN] LAYOUT module initialized (Ctrl+Shift+L for debug overlay)');
        }

        // STARS module removed - nodes ARE the stars

        // Initialize HUD (fade behavior)
        if (typeof HUD !== 'undefined' && HUD.setupFade) {
            HUD.setupFade();
            console.log('[MAIN] HUD module initialized');
        }

        // Initialize DIMENSION toggle
        if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) {
            DIMENSION.setup();
            console.log('[MAIN] DIMENSION module initialized');
        }

        console.log('[MAIN] Module initialization complete');
    };

    /**
     * Global refresh function that uses the throttled refresher
     */
    window.moduleRefresh = function() {
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }
    };

    // =========================================================================
    // MODULE HEALTH CHECK
    // =========================================================================

    window.checkModuleHealth = function() {
        console.log('=== MODULE HEALTH CHECK ===');
        REQUIRED_MODULES.forEach(({ name, module }) => {
            const status = module ? 'OK' : 'MISSING';
            const color = module ? 'color: green' : 'color: red';
            console.log(`%c[${status}] ${name}`, color);
        });

        if (typeof REFRESH !== 'undefined') {
            console.log('REFRESH stats:', REFRESH.stats);
        }

        console.log('===========================');
    };

    // =========================================================================
    // INITIALIZATION MESSAGE
    // =========================================================================

    console.log('[MAIN] Entry point loaded. Modules ready for initialization.');

})();


// ═══ MODULE: modules/circuit-breaker.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * CIRCUIT BREAKER MODULE - UI Control Validator
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Runtime self-test system that validates all visualization UI controls.
 * Acts as a quality guardian - detects binding failures, state issues,
 * and provides actionable fix recommendations.
 *
 * @module CIRCUIT
 * @version 2.0.0
 *
 * ## API
 *
 * | Method | Returns | Description |
 * |--------|---------|-------------|
 * | `runAll()` | `{passed, failed, total, results}` | Run all tests |
 * | `test(name)` | `{passed, error, trace}` | Test single control |
 * | `report()` | `Map<name, result>` | Get all results |
 * | `listTests()` | `string[]` | List test names |
 * | `diagnose()` | `{category, failures}[]` | Get categorized fix recommendations |
 * | `inventory()` | `string` | Markdown table of all controls |
 * | `inventoryJSON()` | `object[]` | JSON array of control definitions |
 *
 * ## CLI Integration
 *
 * ```bash
 * python tools/validate_ui.py <html_path> --verbose
 * ```
 *
 * ## Browser Console
 *
 * ```javascript
 * CIRCUIT.runAll()        // Run all tests
 * CIRCUIT.inventory()     // Print control table
 * CIRCUIT.diagnose()      // Get fix recommendations
 * ```
 *
 * @see tools/validate_ui.py - Headless test runner
 * @see CLAUDE.md - UI Controls section
 */

const CIRCUIT = (function() {
    'use strict';

    // Test results storage
    const _results = new Map();
    let _running = false;

    // =========================================================================
    // DIAGNOSTIC HELPERS
    // =========================================================================

    function getStateValue(path) {
        try {
            const parts = path.split('.');
            let obj = window;
            for (const part of parts) {
                if (obj === undefined || obj === null) return { exists: false, value: undefined };
                obj = obj[part];
            }
            return { exists: true, value: obj };
        } catch (e) {
            return { exists: false, value: undefined, error: e.message };
        }
    }

    function traceBinding(elementId, statePath, graphMethod) {
        const trace = {
            element: { id: elementId, found: false, hasListeners: false },
            state: { path: statePath, exists: false, value: undefined },
            graph: { method: graphMethod, callable: false },
            chain: []
        };

        // Check element
        const el = document.getElementById(elementId);
        if (el) {
            trace.element.found = true;
            trace.element.tagName = el.tagName;
            trace.element.type = el.type || el.tagName;
            trace.element.value = el.value;
            trace.chain.push(`✓ DOM element #${elementId} exists`);
        } else {
            trace.chain.push(`✗ DOM element #${elementId} NOT FOUND`);
            return trace;
        }

        // Check state
        if (statePath) {
            const stateResult = getStateValue(statePath);
            trace.state.exists = stateResult.exists;
            trace.state.value = stateResult.value;
            if (stateResult.exists) {
                trace.chain.push(`✓ State ${statePath} = ${JSON.stringify(stateResult.value)}`);
            } else {
                trace.chain.push(`✗ State ${statePath} is undefined`);
            }
        }

        // Check Graph method
        if (graphMethod && typeof Graph !== 'undefined' && Graph) {
            const method = Graph[graphMethod];
            trace.graph.callable = typeof method === 'function';
            if (trace.graph.callable) {
                trace.chain.push(`✓ Graph.${graphMethod}() is callable`);
            } else {
                trace.chain.push(`✗ Graph.${graphMethod}() NOT a function`);
            }
        }

        return trace;
    }

    // =========================================================================
    // TEST DEFINITIONS - Enhanced with diagnostics
    // =========================================================================

    const TESTS = [
        // --- EDGE CONTROLS ---
        {
            name: 'edge-opacity',
            type: 'slider',
            elementId: 'cfg-edge-opacity',
            statePath: 'APPEARANCE_STATE.edgeOpacity',
            graphMethod: 'linkOpacity',
            expected: 0.8,
            trigger: (el) => {
                el.value = '0.8';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeOpacity');
                return {
                    passed: state.exists && state.value === 0.8,
                    expected: 0.8,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0.6';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Ensure bindSlider() in app.js updates APPEARANCE_STATE.edgeOpacity and calls applyEdgeMode()'
        },
        {
            name: 'edge-width',
            type: 'slider',
            elementId: 'cfg-edge-width',
            statePath: 'APPEARANCE_STATE.edgeWidth',
            graphMethod: 'linkWidth',
            expected: 'changed',
            trigger: (el) => {
                // Store initial value, then change it
                window._edgeWidthBefore = getStateValue('APPEARANCE_STATE.edgeWidth').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeWidth');
                const changed = state.exists && state.value !== window._edgeWidthBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeWidthBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeWidthBefore;
            },
            fix: 'Check if cfg-edge-width has oninput handler that updates APPEARANCE_STATE.edgeWidth'
        },
        {
            name: 'edge-curvature',
            type: 'slider',
            elementId: 'cfg-edge-curve',
            statePath: 'APPEARANCE_STATE.edgeCurvature',
            graphMethod: 'linkCurvature',
            expected: 'changed',
            trigger: (el) => {
                window._edgeCurveBefore = getStateValue('APPEARANCE_STATE.edgeCurvature').value;
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeCurvature');
                const changed = state.exists && state.value !== window._edgeCurveBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeCurveBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeCurveBefore;
            },
            fix: 'Check if cfg-edge-curve has oninput handler that updates APPEARANCE_STATE.edgeCurvature'
        },

        // --- NODE CONTROLS ---
        {
            name: 'node-size',
            type: 'slider',
            elementId: 'cfg-node-size',
            statePath: 'APPEARANCE_STATE.nodeScale',
            graphMethod: 'nodeRelSize',
            expected: 'changed',
            trigger: (el) => {
                // Slider has max=4, so use valid value
                window._nodeSizeBefore = getStateValue('APPEARANCE_STATE.nodeScale').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeScale');
                const changed = state.exists && state.value !== window._nodeSizeBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._nodeSizeBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._nodeSizeBefore;
            },
            fix: 'Check if cfg-node-size has oninput handler that updates APPEARANCE_STATE.nodeScale'
        },
        {
            name: 'node-opacity',
            type: 'slider',
            elementId: 'cfg-node-opacity',
            statePath: 'APPEARANCE_STATE.nodeOpacity',
            graphMethod: 'nodeOpacity',
            expected: 0.5,
            trigger: (el) => {
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeOpacity');
                return {
                    passed: state.exists && state.value === 0.5,
                    expected: 0.5,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Check if cfg-node-opacity has oninput handler that updates APPEARANCE_STATE.nodeOpacity'
        },

        // --- TOGGLES ---
        {
            name: 'toggle-arrows',
            type: 'toggle',
            elementId: 'cfg-toggle-arrows',
            statePath: null,
            graphMethod: 'linkDirectionalArrowLength',
            expected: 'toggled',
            trigger: (el) => {
                window._arrowsActiveBefore = el.classList.contains('active');
                el.click();
            },
            validate: () => {
                const el = document.getElementById('cfg-toggle-arrows');
                if (!el) return { passed: false, error: 'Element not found' };
                const isActiveNow = el.classList.contains('active');
                return {
                    passed: isActiveNow !== window._arrowsActiveBefore,
                    expected: !window._arrowsActiveBefore,
                    actual: isActiveNow,
                    stateExists: true
                };
            },
            cleanup: (el) => {
                el.click();
                delete window._arrowsActiveBefore;
            },
            fix: 'Ensure toggle click handler toggles .active class and calls Graph.linkDirectionalArrowLength()'
        },

        // --- PHYSICS CONTROLS ---
        {
            name: 'physics-charge',
            type: 'slider',
            elementId: 'physics-charge',
            statePath: null,  // Bypasses PHYSICS_STATE, goes direct to Graph
            graphMethod: 'd3Force',
            expected: -200,
            trigger: (el) => {
                window._originalChargeValue = el.value;
                el.value = '-200';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                // Use window.Graph explicitly (Graph is exposed at app.js:1111)
                const G = window.Graph;
                if (!G) {
                    return { passed: false, error: 'Graph not defined', stateExists: false };
                }
                if (!G.d3Force) {
                    return { passed: false, error: 'Graph.d3Force not available', stateExists: false };
                }
                try {
                    const chargeForce = G.d3Force('charge');
                    if (!chargeForce || !chargeForce.strength) {
                        return { passed: false, error: 'charge force not configured', stateExists: false };
                    }
                    // d3-force strength() returns accessor function, not value
                    // Call it with dummy node to get actual strength
                    const strengthFn = chargeForce.strength();
                    const strength = typeof strengthFn === 'function' ? strengthFn({}, 0, []) : strengthFn;
                    return {
                        passed: strength === -200,
                        expected: -200,
                        actual: strength,
                        stateExists: true
                    };
                } catch (e) {
                    return { passed: false, error: e.message, stateExists: false };
                }
            },
            cleanup: (el) => {
                if (window._originalChargeValue) {
                    el.value = window._originalChargeValue;
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    delete window._originalChargeValue;
                }
            },
            fix: 'Ensure physics-charge slider calls Graph.d3Force("charge").strength(value) - check sidebar.js binding'
        },

        // NOTE: btn-edge-mode test removed - button never existed in template.html
        // The EDGE module handles missing button gracefully (line 443-446 of edge-system.js)

        // --- DIMENSION TOGGLE ---
        {
            name: 'dimension-toggle',
            type: 'button',
            elementId: 'btn-2d',
            statePath: 'DIMENSION_TRANSITION',
            graphMethod: null,
            expected: 'transition started',
            trigger: (el) => {
                // Animation takes 3s, so we check DIMENSION_TRANSITION flag (set immediately)
                window._transitionBefore = window.DIMENSION_TRANSITION;
                el.click();
            },
            validate: () => {
                // DIMENSION_TRANSITION is set true immediately on click, then false after 3s animation
                // We check that clicking triggered the transition (flag went true or animation completed)
                const transitionStarted = window.DIMENSION_TRANSITION === true ||
                                         window.DIMENSION_TRANSITION !== window._transitionBefore;
                return {
                    passed: transitionStarted || window.DIMENSION_TRANSITION === true,
                    expected: 'DIMENSION_TRANSITION = true (animation in progress)',
                    actual: window.DIMENSION_TRANSITION,
                    stateExists: typeof window.DIMENSION_TRANSITION !== 'undefined'
                };
            },
            cleanup: () => {
                // Don't click again - let animation complete naturally
                delete window._transitionBefore;
            },
            fix: 'Check if btn-2d click handler sets DIMENSION_TRANSITION and calls DIMENSION.toggle() - see dimension.js'
        },

        // --- VIEW MODE ---
        {
            name: 'view-mode-files',
            type: 'button',
            elementId: null,
            selector: '[data-mode="files"]',
            statePath: 'GRAPH_MODE',
            graphMethod: null,
            expected: 'files',
            trigger: (el) => {
                el.click();
            },
            validate: () => {
                const state = getStateValue('GRAPH_MODE');
                return {
                    passed: state.exists && state.value === 'files',
                    expected: 'files',
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: () => {
                const atomsBtn = document.querySelector('[data-mode="atoms"]');
                if (atomsBtn) atomsBtn.click();
            },
            fix: 'Ensure [data-mode="files"] button sets GRAPH_MODE = "files" and rebuilds graph'
        }
    ];

    // =========================================================================
    // TEST RUNNER - Enhanced with diagnostics
    // =========================================================================

    async function runTest(testDef) {
        const result = {
            name: testDef.name,
            type: testDef.type,
            passed: false,
            error: null,
            elementFound: false,
            // Enhanced diagnostics
            expected: testDef.expected,
            actual: null,
            stateExists: false,
            trace: null,
            fix: testDef.fix || null
        };

        try {
            // Find element
            const el = testDef.elementId
                ? document.getElementById(testDef.elementId)
                : document.querySelector(testDef.selector);

            if (!el) {
                result.error = 'Element not found';
                result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);
                return result;
            }
            result.elementFound = true;

            // Trace binding chain before test
            result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);

            // Run trigger
            testDef.trigger(el);

            // Small delay for async effects
            await new Promise(r => setTimeout(r, 50));

            // Validate with enhanced result
            const validateResult = testDef.validate();
            if (typeof validateResult === 'object') {
                result.passed = validateResult.passed;
                result.expected = validateResult.expected !== undefined ? validateResult.expected : testDef.expected;
                result.actual = validateResult.actual;
                result.stateExists = validateResult.stateExists;
                if (validateResult.error) result.error = validateResult.error;
            } else {
                result.passed = validateResult;
            }

            // Cleanup
            if (testDef.cleanup) {
                await new Promise(r => setTimeout(r, 50));
                testDef.cleanup(el);
            }

        } catch (err) {
            result.error = err.message;
            result.passed = false;
        }

        return result;
    }

    async function runAll() {
        if (_running) {
            console.warn('[CIRCUIT] Already running');
            return;
        }
        _running = true;
        _results.clear();

        console.log('%c[CIRCUIT] Starting control validation...', 'color: #4dd4ff; font-weight: bold');

        const startTime = performance.now();
        let passed = 0;
        let failed = 0;

        for (const test of TESTS) {
            const result = await runTest(test);
            _results.set(test.name, result);

            if (result.passed) {
                passed++;
                console.log(`  %c✓ ${test.name}`, 'color: #4ade80');
            } else {
                failed++;
                const reason = result.error || (!result.elementFound ? 'Element not found' : 'Validation failed');
                console.log(`  %c✗ ${test.name}: ${reason}`, 'color: #f87171');
                if (result.expected !== undefined && result.actual !== undefined) {
                    console.log(`    Expected: ${JSON.stringify(result.expected)}, Got: ${JSON.stringify(result.actual)}`);
                }
            }

            // Small delay between tests
            await new Promise(r => setTimeout(r, 100));
        }

        const elapsed = (performance.now() - startTime).toFixed(0);
        const total = passed + failed;
        const pct = ((passed / total) * 100).toFixed(1);

        console.log('%c─────────────────────────────────────', 'color: #666');
        if (failed === 0) {
            console.log(`%c[CIRCUIT] ALL PASS: ${passed}/${total} controls (${elapsed}ms)`,
                'color: #4ade80; font-weight: bold');
        } else {
            console.log(`%c[CIRCUIT] ${passed}/${total} passed (${pct}%), ${failed} FAILED (${elapsed}ms)`,
                'color: #f87171; font-weight: bold');
        }

        _running = false;
        return { passed, failed, total, results: Object.fromEntries(_results) };
    }

    async function test(name) {
        const testDef = TESTS.find(t => t.name === name);
        if (!testDef) {
            console.error(`[CIRCUIT] Unknown test: ${name}`);
            return null;
        }
        const result = await runTest(testDef);
        _results.set(name, result);
        return result;
    }

    function report() {
        return Object.fromEntries(_results);
    }

    function listTests() {
        return TESTS.map(t => ({ name: t.name, type: t.type }));
    }

    /**
     * Get detailed fix recommendations for all failures
     */
    function diagnose() {
        const failures = [];
        for (const [name, result] of _results) {
            if (!result.passed) {
                failures.push({
                    control: name,
                    type: result.type,
                    error: result.error,
                    expected: result.expected,
                    actual: result.actual,
                    elementFound: result.elementFound,
                    stateExists: result.stateExists,
                    trace: result.trace ? result.trace.chain : [],
                    fix: result.fix
                });
            }
        }
        return failures;
    }

    // =========================================================================
    // INVENTORY - Generate control tables for documentation
    // =========================================================================

    /**
     * Generate markdown table of all tested controls
     * @returns {string} Markdown table
     */
    function inventory() {
        const lines = [
            '| Control | Type | Element ID | State Path | Purpose |',
            '|---------|------|------------|------------|---------|'
        ];
        TESTS.forEach(t => {
            const purpose = t.fix ? t.fix.split(' - ')[0].replace(/^(Check|Ensure) /, '') : t.name;
            lines.push(`| ${t.name} | ${t.type} | \`${t.elementId || '-'}\` | \`${t.statePath || '-'}\` | ${purpose.substring(0, 40)} |`);
        });
        return lines.join('\n');
    }

    /**
     * Generate JSON inventory of all controls
     * @returns {Array} Control definitions
     */
    function inventoryJSON() {
        return TESTS.map(t => ({
            name: t.name,
            type: t.type,
            elementId: t.elementId,
            statePath: t.statePath,
            graphMethod: t.graphMethod,
            expected: t.expected
        }));
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        runAll,
        test,
        report,
        listTests,
        diagnose,
        inventory,
        inventoryJSON,
        get isRunning() { return _running; },
        TESTS
    };
})();

// Global shortcut
window.CIRCUIT = CIRCUIT;

console.log('[Module] CIRCUIT loaded - UI control validator with diagnostics');


// ═══ MAIN APPLICATION ═══
window.process = window.process || { env: { NODE_ENV: "production" } };
window.global = window.global || window;
// UMD globals: THREE, ForceGraph3D, pako already loaded
// Three.js addons attach to THREE global: THREE.ConvexGeometry
const ConvexGeometry = THREE.ConvexGeometry;
// Note: Post-processing (bloom) removed for simplicity - addons not available in r149+ UMD builds

// COMPRESSED_PAYLOAD: Base64-encoded gzipped JSON data
const COMPRESSED_PAYLOAD = "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";

// --------------------------------------------------------------------
// WEB WORKER: JSON Parsing Only (Decompression in main thread)
// OPTIMIZED: Main thread uses already-loaded pako, no duplicate CDN fetch
// --------------------------------------------------------------------
const workerScript = `
        self.onmessage = function(e) {
            const jsonStr = e.data;
            try {
                self.postMessage({status: 'PARSING...'});
                const data = JSON.parse(jsonStr);
                self.postMessage({status: 'ANALYZING COSMOS...', result: data});
            } catch (err) {
                self.postMessage({error: err.message});
            }
        };
        `;

// Initialize Worker (minimal - no pako needed)
const blob = new Blob([workerScript], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));

// OPTIMIZED: Decompress in main thread using already-loaded pako
function decompressPayload(payload) {
    // Update status
    const statusEl = document.getElementById('loader-status');
    if (statusEl) statusEl.innerText = 'DECOMPRESSING...';

    // 1. Decode Base64
    const charData = atob(payload);
    const binData = new Uint8Array(charData.length);
    for (let i = 0; i < charData.length; i++) {
        binData[i] = charData.charCodeAt(i);
    }

    // 2. Inflate using main thread's pako (already loaded from CDN)
    if (statusEl) statusEl.innerText = 'INFLATING...';
    const jsonStr = pako.ungzip(binData, { to: 'string' });

    return jsonStr;
}

let FULL_GRAPH = null;
let Graph = null;
let DM = null;  // DataManager instance - initialized in initGraph()
let Legend = null;  // LegendManager instance - initialized in initGraph()
let CURRENT_DENSITY = 1; // Default: show all nodes
let SHOW_CODOME = false; // Default: hide CODOME boundary nodes
let ACTIVE_DATAMAPS = new Set();
let DATAMAP_CONFIGS = [];
let DATAMAP_INDEX = {};
let DATAMAP_UI = new Map();
let HOVERED_NODE = null;
// SELECTED_NODE_IDS - provided by selection.js module (getter to SELECT.ids)
let DATASET_KEY = 'default';
let GROUPS_STORAGE_KEY = 'collider_groups_default';
let GROUPS = [];
let ACTIVE_GROUP_ID = null;
// MARQUEE_ACTIVE, MARQUEE_START, MARQUEE_ADDITIVE, LAST_MARQUEE_END_TS - provided by selection.js module
let SELECTION_BOX = null;
const SELECTION_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
const GROUP_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
let SPACE_PRESSED = false;
let IS_3D = true;
// Expose for circuit-breaker tests (dimension-toggle test checks window.IS_3D)
Object.defineProperty(window, 'IS_3D', {
    get: () => IS_3D,
    set: (v) => { IS_3D = v; },
    configurable: true
});
let DIMENSION_TRANSITION = false;
// Expose for dimension.js module and circuit-breaker tests
Object.defineProperty(window, 'DIMENSION_TRANSITION', {
    get: () => DIMENSION_TRANSITION,
    set: (v) => { DIMENSION_TRANSITION = v; },
    configurable: true
});
// STARFIELD & BLOOM - REMOVED (nodes ARE the stars, post-processing not in r149+ UMD builds)
// EDGE_MODE - provided by edge-system.js module
let EDGE_DEFAULT_OPACITY = null;  // Initialized from appearance.tokens at runtime (token value: 0.08)

// PERF_MONITOR - provided by perf-monitor.js module (window.PERF, window.PERF_MONITOR)

// Initialize after DOM ready
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => PERF_MONITOR.init(), 100);
    // Initialize SidebarManager facade for sidebar controls
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
        SIDEBAR.init();
    }
});
let DEFAULT_LINK_DISTANCE = null;

// =================================================================
// THEME CONFIGURATION: Loaded from payload at runtime
// =================================================================
let THEME_CONFIG = {
    available: ['dark'],
    default: 'dark',
    current: 'dark',
    colors: {
        edge: {},
        viz: {},
        console: {},
        schemes: {}
    }
};

// Default color configs - will be overridden by payload tokens
// Edge mode configuration - populated from appearance.tokens at runtime
// Fallback values are defined in appearance.tokens.json:131-204
let EDGE_MODE_CONFIG = {
    resolution: {},
    weight: {},
    confidence: {},
    width: {},
    dim: {},
    opacity: null
};
// Edge type colors - populated from theme.tokens.json:501-512 at runtime
let EDGE_COLOR_CONFIG = {};
// File color config - strategy, lightness, saturation, chroma
let FILE_COLOR_CONFIG = {};
// EDGE_RANGES, NODE_FILE_INDEX - provided by modules (edge-system.js)
let NODE_COLOR_CONFIG = { tier: {}, ring: {}, unknown: '#666666' };

// Console logging colors - populated from theme config
let CONSOLE_COLORS = {
    success: '#4ade80',
    error: '#f87171',
    warning: '#ffaa00',
    info: '#4dd4ff'
};

// Viz colors for canvas and fallbacks - populated from theme config
let VIZ_COLORS = {
    canvasBg: '#03040a',
    nodeFallback: '#888888',
    edgeFallback: '#333333',
    groupHalo: '#88d0ff'
};
let FLOW_CONFIG = {};  // Flow mode settings from THE REMOTE CONTROL
window.GRAPH_MODE = 'atoms'; // atoms | files | hybrid - on window for FILE_VIZ access

// Layout stability: cache node positions to prevent re-randomization on toggles
let NODE_POSITION_CACHE = new Map();
let LAYOUT_FROZEN = false;  // When true, don't reheat simulation
let HINTS_ENABLED = true;   // Show mode toasts

// FILE_GRAPH, FILE_NODE_IDS, EXPANDED_FILES, FILE_EXPAND_MODE - provided by file-viz.js module
let LAST_FILTER_SUMMARY = null;
let FILE_NODE_POSITIONS = new Map();
let NODE_COLOR_MODE = 'tier';
let COLOR_TWEAKS = {
    hueShift: 0,
    chromaScale: 1,
    lightnessShift: 0
};
let VIS_FILTERS = {
    tiers: new Set(),
    rings: new Set(),
    roles: new Set(),
    edges: new Set(),
    families: new Set(),  // Atom families: LOG, DAT, ORG, EXE, EXT
    files: new Set(),     // File-based filtering
    layers: new Set(),    // D2_LAYER: Interface, Application, Core, Infrastructure, Test
    effects: new Set(),   // D6_EFFECT: Pure, Read, Write, ReadWrite
    edgeFamilies: new Set(), // Edge families: Structural, Dependency, Inheritance, Semantic, Temporal
    metadata: {
        showLabels: true,
        showFilePanel: true,
        showReportPanel: true,
        showEdges: true
    }
};
let SIDEBAR_STATE = {
    open: false,
    locked: false
};
let APPEARANCE_STATE = {
    nodeScale: 1,
    nodeOpacity: 1,
    labelSize: 1,
    showLabels: true,
    highlightSelected: true,
    edgeOpacity: null,
    edgeWidth: 1,
    edgeCurvature: 0,
    showArrows: false,
    gradientEdges: true,
    boundaryFill: null,
    boundaryWire: null,
    backgroundBase: null,
    backgroundBrightness: 1,
    fileLightness: null,
    clusterStrength: null,
    currentPreset: 'tier',
    colorMode: 'tier',
    sizeMode: 'fanout',
    edgeMode: 'type',
    // Amplifier: Power law exponent for visual contrast
    // γ=1 linear, γ>1 amplifies differences, γ<1 compresses
    amplifier: 1.0,
    amplifierTarget: 'all'  // 'all', 'edges', 'nodes', 'opacity'
};
// Expose for modules and circuit-breaker tests
window.APPEARANCE_STATE = APPEARANCE_STATE;

// =====================================================================
// FILE BOUNDARY & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
// fileBoundaryMeshes, fileMode, fileVizMode - provided by file-viz.js module
let originalNodeColors = new Map();
let clusterForceActive = false;
let hullRedrawTimer = null;
let hullRedrawAttempts = 0;
const originalColorsForDim = new Map();
let flowMode = false; // Hoisted from line 7333

// REGISTRY - provided by registry.js module (window.REGISTRY)


// =================================================================
// GLOBAL CONSTANTS (Hoisted for safety)
// =================================================================
const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

// OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
const PENDULUM = {
    hue: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,        // Set from appearance.tokens
        gravity: null,        // Set from appearance.tokens
        length: 1.0,
        rotationSpeed: null   // Set from appearance.tokens
    },
    chroma: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,
        gravity: null,
        length: 1.0,
        center: null,
        amplitude: null
    },
    lightness: {
        phase: 0,
        speed: null,
        center: null,
        amplitude: null
    },
    ripple: {
        speed: null,
        scale: null
    },
    currentHue: Math.random() * 360,
    lastTime: 0,
    running: false
};
// =====================================================================
// HOVER & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
let _lastHoveredNodeId = null;
const selectionOriginals = new Map();

// amplify, amplifyContrast - provided by core.js module

// =====================================================================
// DATA MANAGER: Minimal runtime checks for deterministic self-test/parity
// =====================================================================

// =====================================================================
// COLOR ORCHESTRATOR: Centralized Color Intelligence System
// =====================================================================
// SINGLE SOURCE OF TRUTH for ALL colors in the visualization.
// Everything reads from here. OKLCH transforms apply here.
// =====================================================================
const ColorOrchestrator = {
    // =================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =================================================================
    palette: {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    },

    // =================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =================================================================
    transform: {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    },

    // =================================================================
    // INTERVAL MAPPINGS: For numeric data → color gradients
    // =================================================================
    intervals: {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        }
    },

    // =================================================================
    // CORE API: Get color with transforms applied
    // =================================================================
    get(dimension, category) {
        const base = this.palette[dimension]?.[category];
        if (!base) return this._toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray

        return this._applyTransform(base);
    },

    // Get color for a numeric value using interval mapping
    getInterval(intervalName, value) {
        const interval = this.intervals[intervalName];
        if (!interval) return this._toHex({ h: 0, c: 0.02, l: 0.40 });

        const stops = interval.stops;
        const v = Math.max(0, Math.min(1, value));

        // Find surrounding stops
        let lower = stops[0];
        let upper = stops[stops.length - 1];

        for (let i = 0; i < stops.length - 1; i++) {
            if (v >= stops[i].value && v <= stops[i + 1].value) {
                lower = stops[i];
                upper = stops[i + 1];
                break;
            }
        }

        // Interpolate between stops
        const range = upper.value - lower.value;
        const t = range > 0 ? (v - lower.value) / range : 0;

        const interpolated = {
            h: lower.h + (upper.h - lower.h) * t,
            c: lower.c + (upper.c - lower.c) * t,
            l: lower.l + (upper.l - lower.l) * t
        };

        return this._applyTransform(interpolated);
    },

    // Get raw OKLCH values (for advanced use)
    getRaw(dimension, category) {
        return this.palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
    },

    // Get all categories for a dimension
    getCategories(dimension) {
        return Object.keys(this.palette[dimension] || {});
    },

    // Get label for a category
    getLabel(dimension, category) {
        return this.palette[dimension]?.[category]?.label || category;
    },

    // =================================================================
    // TRANSFORM CONTROLS: Update OKLCH state
    // =================================================================
    setTransform(key, value) {
        if (key in this.transform) {
            this.transform[key] = value;
            this._notifySubscribers('transform-change', { key, value });
        }
    },

    setAllTransforms(transforms) {
        Object.assign(this.transform, transforms);
        this._notifySubscribers('transform-change', transforms);
    },

    resetTransforms() {
        this.transform = {
            hueShift: 0,
            chromaScale: 1.0,
            lightnessShift: 0,
            amplifier: 1.0
        };
        this._notifySubscribers('transform-change', this.transform);
    },

    // =================================================================
    // INTERNAL: Apply OKLCH transforms and convert to hex
    // =================================================================
    _applyTransform(oklch) {
        const t = this.transform;

        // Apply transforms
        let h = (oklch.h + t.hueShift + 360) % 360;
        let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
        let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

        // Apply amplifier to chroma for contrast
        if (t.amplifier !== 1) {
            c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
        }

        return this._toHex({ h, c, l });
    },

    _toHex(oklch) {
        // OKLCH to sRGB conversion (simplified)
        // Using CSS color conversion would be ideal, but this approximation works
        const { h, c, l } = oklch;

        // Convert OKLCH to approximate RGB
        const hRad = h * Math.PI / 180;
        const a = c * Math.cos(hRad);
        const b = c * Math.sin(hRad);

        // Simplified OKLab to linear RGB (approximate)
        const L = l;
        const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

        const l3 = l_ * l_ * l_;
        const m3 = m_ * m_ * m_;
        const s3 = s_ * s_ * s_;

        let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
        let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
        let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

        // Clamp and convert to sRGB
        const toSRGB = (x) => {
            x = Math.max(0, Math.min(1, x));
            return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
        };

        r = Math.round(toSRGB(r) * 255);
        g = Math.round(toSRGB(g) * 255);
        bl = Math.round(toSRGB(bl) * 255);

        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        bl = Math.max(0, Math.min(255, bl));

        return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
    },

    // =================================================================
    // REACTIVE SUBSCRIPTIONS
    // =================================================================
    _subscribers: [],

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    },

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    },

    // =================================================================
    // DEBUG: Log current state
    // =================================================================
    debug() {
        console.log('[ColorOrchestrator] Transform state:', this.transform);
        console.log('[ColorOrchestrator] Palette dimensions:', Object.keys(this.palette));
        console.log('[ColorOrchestrator] Interval mappings:', Object.keys(this.intervals));
    }
};

// Global alias for convenience
const Color = ColorOrchestrator;



// =====================================================================
// FLOATING PANEL CONTROL SYSTEM - CONSOLIDATED INTO modules/panels.js
// =====================================================================
// openPanel, closePanel, togglePanel, initCommandBar - ALL IN panels.js
// (backward compat shims in panels.js)


// Populate filter chips in floating panels
function populateFilterChips() {
    if (!DM) return;  // ALL DATA FROM DM

    // Use DM cached aggregations (O(1) lookups)
    const tierCounts = DM.getTierCounts();
    const ringCounts = DM.getRingCounts();
    const edgeCounts = DM.getEdgeTypeCounts();

    buildChipGroup('chips-tiers', tierCounts, VIS_FILTERS.tiers, refreshGraph);
    buildChipGroup('chips-rings', ringCounts, VIS_FILTERS.rings, refreshGraph);
    buildChipGroup('chips-edges', edgeCounts, VIS_FILTERS.edges, refreshGraph);
}

// renderLegendSection, renderAllLegends - MOVED TO modules/legend-manager.js
// (debounce is now built into legend-manager.js, no monkey-patching needed)

// =====================================================================
// HUD LAYOUT MANAGER: MIGRATED TO modules/layout.js
// =====================================================================
// HudLayoutManager (390 lines) has been migrated to modules/layout.js
// which provides the LAYOUT module with:
//   - All original panel placement functionality
//   - NEW: Toast/control-bar collision detection
//   - NEW: Min-width graph validation
//   - NEW: Debug overlay (Ctrl+Shift+L)
//   - NEW: Component registration system
//
// Backward compatibility: window.HudLayoutManager = LAYOUT (alias)
// =====================================================================

worker.onmessage = function (e) {
    if (e.data.status && !e.data.result) {
        document.getElementById('loader-status').innerText = e.data.status;
    } else if (e.data.error) {
        document.getElementById('loader-status').innerText = "ERROR: " + e.data.error;
        document.getElementById('loader-status').style.color = "red";
    } else if (e.data.result) {
        FULL_GRAPH = e.data.result;
        FILE_GRAPH = null;
        FILE_NODE_POSITIONS = new Map();
        EXPANDED_FILES.clear();
        window.GRAPH_MODE = 'atoms';
        document.getElementById('loader-status').innerText = "INITIALIZING VISUALIZATION...";
        initGraph(FULL_GRAPH);
    }
};

// Start Work: Decompress in main thread, then send JSON string to worker for parsing
try {
    const jsonStr = decompressPayload(COMPRESSED_PAYLOAD);
    worker.postMessage(jsonStr);
} catch (err) {
    document.getElementById('loader-status').innerText = "ERROR: " + err.message;
    document.getElementById('loader-status').style.color = "red";
    console.error('[Decompression] Failed:', err);
}

// =====================================================================
// 2D CANVAS FALLBACK: Used when WebGL is unavailable
// =====================================================================
function initFallback2D(container, graphData, fullData) {
    console.log('[2D Fallback] Initializing canvas renderer');
    showToast('WebGL unavailable - using 2D fallback');

    const loader = document.getElementById('loader');
    if (loader) loader.style.display = 'none';

    // Update HUD stats even in 2D fallback mode
    updateHudStats(fullData);

    container.innerHTML = '';
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.background = VIZ_COLORS.canvasBg;
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    let width = container.clientWidth || window.innerWidth;
    let height = container.clientHeight || window.innerHeight;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    // Layout: simple force-directed positions
    const nodes = graphData.nodes || [];
    const links = graphData.links || [];
    const nodeMap = new Map();

    nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        const radius = Math.min(width, height) * 0.35;
        n._x = width / 2 + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);
        n._y = height / 2 + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5);
        n._vx = 0;
        n._vy = 0;
        nodeMap.set(n.id, n);
    });

    // Camera state
    let camX = 0, camY = 0, zoom = 1;
    let dragging = false, lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mousemove', e => {
        if (!dragging) return;
        camX += (e.clientX - lastX) / zoom;
        camY += (e.clientY - lastY) / zoom;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        zoom = Math.max(0.1, Math.min(5, zoom * factor));
    }, { passive: false });

    function toScreen(x, y) {
        return {
            x: (x + camX - width / 2) * zoom + width / 2,
            y: (y + camY - height / 2) * zoom + height / 2
        };
    }

    function parseColor(c) {
        if (typeof c === 'number') {
            return '#' + c.toString(16).padStart(6, '0');
        }
        return c || VIZ_COLORS.nodeFallback;
    }

    function render() {
        ctx.fillStyle = VIZ_COLORS.canvasBg;
        ctx.fillRect(0, 0, width, height);

        // Draw edges
        ctx.strokeStyle = 'rgba(100,100,100,0.3)';
        ctx.lineWidth = 0.5;
        for (const link of links) {
            const src = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
            const tgt = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);
            if (!src || !tgt) continue;
            const p1 = toScreen(src._x, src._y);
            const p2 = toScreen(tgt._x, tgt._y);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // Draw nodes
        for (const node of nodes) {
            const p = toScreen(node._x, node._y);
            const r = Math.max(2, (node.val || 1) * zoom * 0.5);
            ctx.fillStyle = parseColor(node.color);
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Info overlay
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '11px monospace';
        ctx.fillText('2D Fallback Mode (WebGL unavailable)', 10, 20);
        ctx.fillText('Drag to pan, scroll to zoom', 10, 35);
        ctx.fillText(`Nodes: ${nodes.length} | Edges: ${links.length}`, 10, 50);

        requestAnimationFrame(render);
    }

    function resize() {
        width = container.clientWidth || window.innerWidth;
        height = container.clientHeight || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', resize);
    render();

    // Initialize DataManager (required for UI controls)
    DM = new DataManager();
    DM.init(fullData);
    window.DM = DM;

    // Setup UI controls (they work independently of 3D graph)
    setupControls(fullData);
    setupReport(fullData);
    setupAIInsights(fullData);
    setupMetrics(fullData);
    setupHudFade();
    setupDimensionToggle();

    // Update stats with actual node/edge counts
    updateHudStats(graphData);
}

function initGraph(data) {
    // =================================================================
    // DATA MANAGER: Self-test + parity checks
    // =================================================================
    DM = new DataManager();
    DM.init(data);
    window.DM = DM;
    DM.selfTest();
    runDmParity(DM, data);

    // =================================================================
    // HUD STATS: Populate header and stats panel with graph data
    // =================================================================
    updateHudStats(data);

    // =================================================================
    // SIDEBAR: Populate filter chips from loaded data
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.populateFilterChips) {
        SIDEBAR.populateFilterChips(data);
    }

    // =================================================================
    // SIDEBAR: Apply deferred view mode (files mode if saved in localStorage)
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.applyDeferredViewMode) {
        SIDEBAR.applyDeferredViewMode();
    }

    // =================================================================
    // TOKEN-DRIVEN CONFIG: Extract from payload
    // =================================================================
    const physicsConfig = data.physics || {};
    const appearanceConfig = data.appearance || {};
    window.APPEARANCE_CONFIG = appearanceConfig;

    // =================================================================
    // THEME CONFIG: Load theme configuration for runtime switching
    // =================================================================
    if (data.theme_config) {
        THEME_CONFIG = {
            ...THEME_CONFIG,
            available: data.theme_config.available || ['dark'],
            default: data.theme_config.default || 'dark',
            current: data.theme_config.default || 'dark',
            colors: data.theme_config.colors || THEME_CONFIG.colors
        };

        // Apply edge colors from theme config
        if (THEME_CONFIG.colors.edge) {
            EDGE_COLOR_CONFIG = { ...EDGE_COLOR_CONFIG, ...THEME_CONFIG.colors.edge };
        }

        // Apply viz colors from theme config
        if (THEME_CONFIG.colors.viz) {
            const viz = THEME_CONFIG.colors.viz;
            VIZ_COLORS = {
                canvasBg: viz['canvas-bg'] || VIZ_COLORS.canvasBg,
                nodeFallback: viz['node-fallback'] || VIZ_COLORS.nodeFallback,
                edgeFallback: viz['edge-fallback'] || VIZ_COLORS.edgeFallback,
                groupHalo: viz['group-halo'] || VIZ_COLORS.groupHalo
            };
        }

        // Apply console colors from theme config
        if (THEME_CONFIG.colors.console) {
            CONSOLE_COLORS = { ...CONSOLE_COLORS, ...THEME_CONFIG.colors.console };
        }

        console.log(`%c[Theme] Loaded: ${THEME_CONFIG.available.join(', ')}`, `color: ${CONSOLE_COLORS.info}; font-weight: bold`);
    }
    const simulation = physicsConfig.simulation || {};
    // background.bloom, background.stars - REMOVED (post-processing not available in r149+ UMD builds)
    // renderConfig, highlightConfig - REMOVED (unused, features not implemented)
    FLOW_CONFIG = appearanceConfig.flow_mode || {};

    // Merge animation tokens into PENDULUM (T004)
    const animationConfig = appearanceConfig.animation || {};
    if (animationConfig.hue) {
        PENDULUM.hue.damping = animationConfig.hue.damping ?? 0.9995;
        PENDULUM.hue.gravity = animationConfig.hue.speed ?? 0.0008;
        PENDULUM.hue.rotationSpeed = animationConfig.hue.rotation ?? 0.8;
    }
    if (animationConfig.chroma) {
        PENDULUM.chroma.damping = animationConfig.chroma.damping ?? 0.998;
        PENDULUM.chroma.gravity = animationConfig.chroma.gravity ?? 0.0004;
        PENDULUM.chroma.center = animationConfig.chroma.center ?? 0.32;
        PENDULUM.chroma.amplitude = animationConfig.chroma.amplitude ?? 0.08;
    }
    if (animationConfig.lightness) {
        PENDULUM.lightness.speed = animationConfig.lightness.speed ?? 0.02;
        PENDULUM.lightness.center = animationConfig.lightness.center ?? 82;
        PENDULUM.lightness.amplitude = animationConfig.lightness.amplitude ?? 10;
    }
    if (animationConfig.ripple) {
        PENDULUM.ripple.speed = animationConfig.ripple.speed ?? 0.035;
        PENDULUM.ripple.scale = animationConfig.ripple.scale ?? 200;
    }
    const edgeModes = appearanceConfig.edge_modes || {};
    EDGE_MODE_CONFIG = {
        resolution: edgeModes.resolution || { internal: '#4dd4ff', external: '#ff6b6b', unresolved: '#9aa0a6', unknown: '#666666' },
        weight: edgeModes.weight || { hue_min: 210, hue_max: 50, saturation: 45, lightness: 42 },
        confidence: edgeModes.confidence || { hue_min: 20, hue_max: 120, saturation: 45, lightness: 44 },
        width: edgeModes.width || { base: 0.6, weight_scale: 2.0, confidence_scale: 1.5 },
        dim: edgeModes.dim || { interfile_factor: 0.25 },
        opacity: (typeof edgeModes.opacity === 'number') ? edgeModes.opacity : 0.08
    };

    FILE_COLOR_CONFIG = Object.assign({}, FILE_COLOR_CONFIG, appearanceConfig.file_color || {});
    // Token value 0.08 from appearance.tokens.json:202, fallback only if token system fails
    EDGE_DEFAULT_OPACITY =
        (typeof EDGE_MODE_CONFIG.opacity === 'number') ? EDGE_MODE_CONFIG.opacity : 0.08;
    const boundaryConfig = appearanceConfig.boundary || {};
    APPEARANCE_STATE.edgeOpacity = EDGE_DEFAULT_OPACITY;
    APPEARANCE_STATE.boundaryFill = boundaryConfig.fill_opacity ?? APPEARANCE_STATE.boundaryFill;
    APPEARANCE_STATE.boundaryWire = boundaryConfig.wire_opacity ?? APPEARANCE_STATE.boundaryWire;
    const background = appearanceConfig.background || {};
    APPEARANCE_STATE.backgroundBase = background.color || '#000000';
    APPEARANCE_STATE.fileLightness = FILE_COLOR_CONFIG.lightness ?? APPEARANCE_STATE.fileLightness;
    const nodeColor = appearanceConfig.node_color || {};
    NODE_COLOR_CONFIG = {
        tier: nodeColor.tier || {},
        ring: nodeColor.ring || {},
        unknown: nodeColor.unknown || '#666666'
    };
    const edgeColor = appearanceConfig.edge_color || {};
    EDGE_COLOR_CONFIG = {
        default: edgeColor.default || '#333333',
        calls: edgeColor.calls || '#4dd4ff',
        contains: edgeColor.contains || '#00ff9d',
        uses: edgeColor.uses || '#ffb800',
        imports: edgeColor.imports || '#9aa0a6',
        inherits: edgeColor.inherits || '#ff6b6b'
    };

    // Initial Filter: show full graph
    const filtered = filterGraph(data, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);

    // ═══════════════════════════════════════════════════════════════════
    // DATA PREP FOR ANIMATIONS: Assign file indices for wave patterns
    // ═══════════════════════════════════════════════════════════════════
    const fileMap = new Map();
    let nextFileIdx = 0;
    filtered.nodes.forEach(node => {
        // Extract filename from ID (assuming file path is in ID or explicit file prop)
        const file = node.file || (node.id.includes('/') ? node.id.split(':')[0] : 'unknown');
        if (!fileMap.has(file)) fileMap.set(file, nextFileIdx++);
        node.file_idx = fileMap.get(file);
    });

    const div = document.getElementById('3d-graph');

    // ═══════════════════════════════════════════════════════════════════
    // GRADIENT EDGES: Custom THREE.js lines with vertex colors
    // Creates beautiful gradients from source to target node colors
    // ═══════════════════════════════════════════════════════════════════
    let GRADIENT_EDGES_ENABLED = true;  // Toggle for gradient edges

    function hexToRgb(hex) {
        // Convert hex color to RGB array [0-1, 0-1, 0-1]
        if (typeof hex === 'number') {
            return [
                ((hex >> 16) & 255) / 255,
                ((hex >> 8) & 255) / 255,
                (hex & 255) / 255
            ];
        }
        if (typeof hex === 'string') {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                ((num >> 16) & 255) / 255,
                ((num >> 8) & 255) / 255,
                (num & 255) / 255
            ];
        }
        return [0.5, 0.5, 0.5];  // Default gray
    }

    function createGradientEdge(link) {
        // Get source and target nodes
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        // Get colors from nodes (using current color mode)
        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        // Create geometry with 2 vertices
        const geometry = new THREE.BufferGeometry();

        // Positions will be updated by linkPositionUpdate
        const positions = new Float32Array([0, 0, 0, 0, 0, 0]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Vertex colors: source color at start, target color at end
        const colors = new Float32Array([
            srcRgb[0], srcRgb[1], srcRgb[2],  // Source vertex color
            tgtRgb[0], tgtRgb[1], tgtRgb[2]   // Target vertex color
        ]);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Material with vertex colors
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: link.opacity ?? EDGE_DEFAULT_OPACITY,
            linewidth: 1  // Note: linewidth > 1 only works on some platforms
        });

        return new THREE.Line(geometry, material);
    }

    function updateGradientEdge(line, link, coords) {
        // Update line positions
        const posArr = line.geometry.attributes.position.array;
        posArr[0] = coords.start.x || 0;
        posArr[1] = coords.start.y || 0;
        posArr[2] = coords.start.z || 0;
        posArr[3] = coords.end.x || 0;
        posArr[4] = coords.end.y || 0;
        posArr[5] = coords.end.z || 0;
        line.geometry.attributes.position.needsUpdate = true;

        // Update colors based on current node colors
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        const colArr = line.geometry.attributes.color.array;
        colArr[0] = srcRgb[0]; colArr[1] = srcRgb[1]; colArr[2] = srcRgb[2];
        colArr[3] = tgtRgb[0]; colArr[4] = tgtRgb[1]; colArr[5] = tgtRgb[2];
        line.geometry.attributes.color.needsUpdate = true;
    }

    // Refresh all gradient edge colors (call when node color mode changes)
    function refreshGradientEdgeColors() {
        if (!GRADIENT_EDGES_ENABLED || !Graph) return;
        // Force rebuild of all link objects to update colors
        Graph.linkThreeObject(link => createGradientEdge(link));
    }

    // Make it globally accessible for color mode changes
    window.refreshGradientEdgeColors = refreshGradientEdgeColors;

    // TOKEN-DRIVEN: Read render config from THE REMOTE CONTROL
    const renderConfig = appearanceConfig.render || {};
    const dimensions = renderConfig.dimensions || 3;
    const nodeRes = renderConfig.nodeResolution || 8;

    try {
        Graph = ForceGraph3D({
            rendererConfig: {
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            }
        })
            (div)
            .graphData(filtered)
            .numDimensions(dimensions)
            .backgroundColor(toColorNumber(background.color, 0x000000))
            .nodeLabel('name')
            .nodeColor(node => toColorNumber(node.color, 0x888888))
            .nodeVal(node => {
                // Boundary nodes get 1.5x size multiplier
                const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
                const baseSize = node.val || 1;
                return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
            })
            // ═══════════════════════════════════════════════════════════════════
            // GRADIENT EDGES: Custom THREE.Line with vertex colors
            // Each edge smoothly transitions from source node color to target node color
            // ═══════════════════════════════════════════════════════════════════
            .linkThreeObject(link => GRADIENT_EDGES_ENABLED ? createGradientEdge(link) : null)
            .linkPositionUpdate((line, coords, link) => {
                if (GRADIENT_EDGES_ENABLED && line) {
                    updateGradientEdge(line, link, coords);
                }
                return true;  // Keep default behavior for non-gradient
            })
            .linkColor(link => GRADIENT_EDGES_ENABLED ? null : toColorNumber(getEdgeColor(link), 0x222222))
            .linkOpacity(link => GRADIENT_EDGES_ENABLED ? 0 : (link.opacity ?? EDGE_DEFAULT_OPACITY))
            .nodeThreeObjectExtend(true)
            .nodeThreeObject(node => ensureNodeOverlays(node))
            .nodeResolution(Math.max(nodeRes, 16))
            .linkResolution(6)
            .showNavInfo(false)
            .warmupTicks(simulation.warmupTicks || 30)
            .cooldownTicks(simulation.cooldownTicks || 0)
            .onNodeHover(node => handleNodeHover(node, data))
            .onNodeClick((node, event) => handleNodeClick(node, event))
            .onBackgroundClick(() => maybeClearSelection())
            // ═══════════════════════════════════════════════════════════════════
            // GROUP DRAG: Move all selected nodes together, maintaining offsets
            // Note: onNodeDragStart doesn't exist - detect start via flag
            // ═══════════════════════════════════════════════════════════════════
            .onNodeDrag((node, _translate) => {
                // Only handle group drag if multiple nodes selected and this node is selected
                if (SELECTED_NODE_IDS.size > 1 && SELECTED_NODE_IDS.has(node.id)) {
                    // First drag frame: store relative offsets
                    if (!window._groupDragActive) {
                        window._groupDragActive = true;
                        window._groupDragOffsets = new Map();
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            if (SELECTED_NODE_IDS.has(n.id) && n.id !== node.id) {
                                window._groupDragOffsets.set(n.id, {
                                    dx: (n.x || 0) - (node.x || 0),
                                    dy: (n.y || 0) - (node.y || 0),
                                    dz: (n.z || 0) - (node.z || 0)
                                });
                            }
                        });
                    }
                    // Move all other selected nodes with their offsets
                    if (window._groupDragOffsets) {
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            const offset = window._groupDragOffsets.get(n.id);
                            if (offset) {
                                n.fx = node.x + offset.dx;
                                n.fy = node.y + offset.dy;
                                n.fz = node.z + offset.dz;
                            }
                        });
                    }
                }
            })
            .onNodeDragEnd(_node => {
                // Clear group drag state
                window._groupDragActive = false;
                window._groupDragOffsets = null;
                // Fix all selected nodes at their final positions
                if (SELECTED_NODE_IDS.size > 0) {
                    const nodes = Graph.graphData().nodes;
                    nodes.forEach(n => {
                        if (SELECTED_NODE_IDS.has(n.id)) {
                            n.fx = n.x; n.fy = n.y; n.fz = n.z;
                        }
                    });
                }
            })
            .onEngineStop(() => {
                // Physics-dependent operations (run after simulation stabilizes)
                drawFileBoundaries(data);
                // LAYOUT STABILITY: Freeze layout after initial simulation completes
                if (!LAYOUT_FROZEN) {
                    saveNodePositions();
                    freezeLayout();
                }
            });
    } catch (err) {
        console.error('[WebGL] Failed to initialize 3D graph:', err);
        initFallback2D(div, filtered, data);
        return;
    }

    window.Graph = Graph;

    // FIX: Drift on resize
    // Updates Graph renderer size when window creates
    function onWindowResize() {
        if (Graph) {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        }
    }

    // Remove existing listener if function already exists (unlikely in pure script, but good practice)
    if (window.onWindowResize) {
        window.removeEventListener('resize', window.onWindowResize);
    }
    window.onWindowResize = onWindowResize;
    window.addEventListener('resize', onWindowResize);

    // OPTIMIZATION: Hide loader immediately after Graph creation (don't wait for physics)
    // This makes the visualization appear 200-500ms faster
    document.getElementById('loader').style.display = 'none';

    // Hook up Advanced Observability (if available)
    if (typeof PERF_MONITOR !== 'undefined' && PERF_MONITOR.setRenderer) {
        PERF_MONITOR.setRenderer(Graph.renderer());
    }

    // =================================================================
    // RENDERER QUALITY: Enable anti-aliasing and high DPI
    // =================================================================
    const renderer = Graph.renderer();
    if (renderer) {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Enable high quality rendering
        renderer.antialias = true;
        renderer.alpha = true;
        renderer.powerPreference = 'high-performance';
    }

    initSelectionState(data);
    setupSelectionInteractions();
    // updateSelectionVisuals is in selection.js (window scope), may not be loaded yet
    if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();

    // =================================================================
    // CONTROLS: keep default camera behavior, enable damping
    // =================================================================
    const controls = Graph.controls();
    if (controls) {
        // TOKEN-DRIVEN: Read from payload (if available), else use defaults
        // Allow remote configuration of mouse buttons and damping
        const navConfig = data.config?.controls || data.controls || {};

        controls.enableDamping = navConfig.enableDamping !== undefined ? navConfig.enableDamping : true;
        controls.dampingFactor = navConfig.dampingFactor || 0.1;
        controls.enableRotate = navConfig.enableRotate !== undefined ? navConfig.enableRotate : true;
        controls.enablePan = navConfig.enablePan !== undefined ? navConfig.enablePan : true;

        // Mouse Buttons: Use Registry if available, otherwise fallback
        if (typeof ControlRegistry !== 'undefined') {
            controls.mouseButtons = ControlRegistry.getMapping();

            // Listen for runtime updates from Settings Panel
            window.addEventListener('controls-updated', () => {
                console.log('[App] Controls updated from registry');
                controls.mouseButtons = ControlRegistry.getMapping();
            });
        } else {
            // Fallback: Map generic names to integer constants
            // 0: ROTATE, 1: DOLLY (Zoom), 2: PAN
            const defaultButtons = {
                LEFT: 2, // PAN
                MIDDLE: 1, // DOLLY
                RIGHT: 0 // ROTATE
            };

            if (navConfig.mouseButtons) {
                controls.mouseButtons = {
                    LEFT: navConfig.mouseButtons.LEFT ?? defaultButtons.LEFT,
                    MIDDLE: navConfig.mouseButtons.MIDDLE ?? defaultButtons.MIDDLE,
                    RIGHT: navConfig.mouseButtons.RIGHT ?? defaultButtons.RIGHT
                };
            } else {
                controls.mouseButtons = defaultButtons;
            }
        }

        // Spacebar toggling disabled to ensure stability
    }

    // =================================================================
    // TOKEN-DRIVEN: Force Configuration
    // =================================================================
    const forces = physicsConfig.forces || {};
    if (forces.charge?.enabled) {
        Graph.d3Force('charge').strength(forces.charge.strength || -120);
        Graph.d3Force('charge').distanceMax(forces.charge.distanceMax || 500);
    }
    if (forces.link?.enabled) {
        const linkDistance = forces.link.distance || 50;
        Graph.d3Force('link').distance(linkDistance);
        DEFAULT_LINK_DISTANCE = linkDistance;
    }
    if (forces.center?.enabled) {
        Graph.d3Force('center').strength(forces.center.strength || 0.05);
    }

    // =================================================================
    // STARFIELD REMOVED - Nodes ARE the stars
    // Rationale: Adding background dots creates visual confusion with actual data nodes.
    // The cosmos metaphor works better when the data itself forms the starfield.
    // =================================================================

    // =================================================================
    // TOKEN-DRIVEN: Bloom Post-Processing (DISABLED - UMD build compatibility)
    // Post-processing addons require ES modules; using UMD for file:// support
    // =================================================================
    // Bloom disabled for compatibility - visualization works without it

    // Setup Hud Controls (TOKEN-DRIVEN)
    // OPTIMIZATION: Defer UI setup to next frame so graph renders first
    // This makes the visualization appear 150-200ms faster
    Promise.resolve().then(() => {
        setupControls(data);
        setupReport(data);
        setupAIInsights(data);
        setupMetrics(data);
        setupHudFade();
        setupDimensionToggle();
        applyEdgeMode();

        // Initialize Settings Panel
        if (typeof SettingsPanel !== 'undefined') SettingsPanel.init();

        // SELF-TEST: Deterministic validation of UI controls (deferred)
        runSelfTest(data);
    });
}

function runSelfTest(data) {
    const results = {
        timestamp: new Date().toISOString(),
        passed: [],
        failed: []
    };

    const test = (name, condition) => {
        if (condition) {
            results.passed.push(name);
        } else {
            results.failed.push(name);
        }
    };

    // Test 1: Core UI structure (dual-sidebar layout)

    // Main layout containers
    test('header-exists', !!document.getElementById('header'));
    test('left-sidebar-exists', !!document.getElementById('left-sidebar'));
    test('right-sidebar-exists', !!document.getElementById('right-sidebar'));
    test('graph-container-exists', !!document.getElementById('3d-graph'));

    // Header stats
    test('stat-nodes-exists', !!document.getElementById('stat-nodes'));
    test('stat-edges-exists', !!document.getElementById('stat-edges'));
    test('target-name-exists', !!document.getElementById('target-name'));

    // Left sidebar configuration sections
    test('section-node-config-exists', !!document.getElementById('section-node-config'));
    test('section-edge-config-exists', !!document.getElementById('section-edge-config'));
    test('section-layout-exists', !!document.getElementById('section-layout'));
    test('section-physics-exists', !!document.getElementById('section-physics'));
    test('section-filters-exists', !!document.getElementById('section-filters'));
    test('section-actions-exists', !!document.getElementById('section-actions'));

    // Left sidebar action buttons
    test('btn-reset-exists', !!document.getElementById('btn-reset'));
    test('btn-screenshot-exists', !!document.getElementById('btn-screenshot'));
    test('btn-2d-exists', !!document.getElementById('btn-2d'));
    test('btn-freeze-exists', !!document.getElementById('btn-freeze'));

    // Right sidebar panels
    test('hover-panel-exists', !!document.getElementById('hover-panel'));
    test('section-schemes-exists', !!document.getElementById('section-schemes'));
    test('section-color-exists', !!document.getElementById('section-color'));

    // Selection elements
    test('selection-count-exists', !!document.getElementById('selection-count'));
    test('selection-list-exists', !!document.getElementById('selection-list'));

    // Stats panel
    test('stats-nodes-exists', !!document.getElementById('stats-nodes'));
    test('stats-edges-exists', !!document.getElementById('stats-edges'));

    // Performance HUD
    test('perf-hud-exists', !!document.getElementById('perf-hud'));
    test('perf-fps-exists', !!document.getElementById('perf-fps'));

    // Test 1b: Color mode buttons exist
    const colorButtons = document.querySelectorAll('.color-btn[data-preset]');
    test('color-mode-buttons-exist', colorButtons.length >= 4);

    // Test 1c: HUD Layout Manager tests
    test('hud-layout-manager-exists', typeof HudLayoutManager === 'object' && HudLayoutManager !== null);
    test('hud-layout-manager-has-reflow', typeof HudLayoutManager.reflow === 'function');
    test('hud-layout-manager-has-placePanel', typeof HudLayoutManager.placePanel === 'function');

    // Test 1d: HUD placement with synthetic rects (collision avoidance)
    if (typeof HudLayoutManager.placePanel === 'function') {
        // Create a test scenario: occupied rect on top-left, panel should avoid it
        const fakeOccupied = [{ left: 0, top: 0, right: 300, bottom: 200 }];
        const fakeCandidates = [
            { left: 20, top: 100 },   // Would overlap with occupied
            { left: 400, top: 100 }   // Should be clear
        ];
        // Create a mock panel element
        const mockPanel = document.createElement('div');
        mockPanel.style.width = '200px';
        mockPanel.style.height = '150px';
        mockPanel.style.position = 'fixed';
        document.body.appendChild(mockPanel);

        const result = HudLayoutManager.placePanel(mockPanel, fakeCandidates, fakeOccupied);
        // Should choose the second candidate (no overlap)
        const pickedNonOverlapping = result && result.left >= 300;
        test('hud-placement-avoids-overlap', pickedNonOverlapping);

        document.body.removeChild(mockPanel);
    }

    // Test 1e: Canonical taxonomy field tests
    // Test that node.tier is preferred over atom prefix inference
    const mockNodeWithTier = { tier: 'T2', atom: 'CORE.001', ring: 'DOMAIN' };
    const tierResult = getNodeTier(mockNodeWithTier);
    test('node-tier-prefers-field', tierResult === 'T2');  // Should use tier field, not infer T0 from CORE.

    // Test that node.ring is used when present
    const mockNodeWithRing = { ring: 'PRESENTATION', layer: 'APPLICATION' };
    const ringResult = getNodeRing(mockNodeWithRing);
    test('node-ring-prefers-field', ringResult === 'PRESENTATION');  // Should use ring, not layer

    // Test tier aliases work (CORE → T0, EXT → T2)
    test('tier-alias-core-to-t0', normalizeTier('CORE') === 'T0');
    test('tier-alias-ext-to-t2', normalizeTier('EXT') === 'T2');

    // Test atom_family extraction
    const mockNodeWithFamily = { atom_family: 'LOG', atom: 'ORG.AGG.M' };
    const familyResult = getNodeAtomFamily(mockNodeWithFamily);
    test('node-atom-family-prefers-field', familyResult === 'LOG');  // Should use atom_family, not infer ORG

    // Test 1f: Hover panel tests
    test('hover-panel-exists', document.getElementById('hover-panel') !== null);

    // Test hover panel uses canonical fields
    const mockCanonicalNode = {
        name: 'TestNode',
        atom_family: 'LOG',
        ring: 'PRESENTATION',
        tier: 'T2',
        atom: 'ORG.AGG.M',
        kind: 'function',
        role: 'Utility'
    };
    // Simulate updateHoverPanel with mock node
    if (typeof updateHoverPanel === 'function') {
        updateHoverPanel(mockCanonicalNode);
        const hoverFamily = document.getElementById('hover-family')?.textContent;
        const hoverRing = document.getElementById('hover-ring')?.textContent;
        const hoverTier = document.getElementById('hover-tier')?.textContent;
        // Verify canonical fields are used (LOG not ORG, PRESENTATION, T2)
        test('hover-panel-uses-canonical-fields',
            hoverFamily === 'LOG' && hoverRing === 'PRESENTATION' && hoverTier === 'T2');
        // Clean up: hide panel
        updateHoverPanel(null);
    }

    // Test 2: Header stats populated (stat-* elements - these are set early)
    const headerNodes = document.getElementById('stat-nodes');
    const headerEdges = document.getElementById('stat-edges');
    test('header-nodes-populated', headerNodes && headerNodes.textContent !== '0');
    test('header-edges-populated', headerEdges && headerEdges.textContent !== '0');

    // Test 3: Data integrity
    test('nodes-count-positive', data.nodes && data.nodes.length > 0);
    test('links-count-positive', data.links && data.links.length > 0);
    test('graph-initialized', !!window.Graph);

    // Test 4: Controls config loaded
    test('controls-config-exists', !!data.controls);
    test('appearance-config-exists', !!data.appearance);
    test('physics-config-exists', !!data.physics);

    // Test 5: Initial state correct
    const physicsCharge = document.getElementById('physics-charge');
    test('physics-slider-has-value', physicsCharge && physicsCharge.value !== undefined);
    test('3d-mode-default', IS_3D === true);

    // Test 6: VIS_STATE module loaded
    test('vis-state-module-exists', typeof VIS_STATE !== 'undefined');
    test('vis-state-has-applyState', typeof VIS_STATE?.applyState === 'function');
    test('vis-state-has-getState', typeof VIS_STATE?.getState === 'function');

    // Expose results to window for external testing
    window.SELF_TEST_RESULTS = results;

    // Log summary
    const total = results.passed.length + results.failed.length;
    const passRate = ((results.passed.length / total) * 100).toFixed(1);

    if (results.failed.length === 0) {
        console.log(`%c✅ SELF-TEST PASSED: ${results.passed.length}/${total} tests (${passRate}%)`, 'color: #00ff00; font-weight: bold');
    } else {
        console.warn(`%c⚠️ SELF-TEST: ${results.passed.length}/${total} passed (${passRate}%)`, 'color: #ffaa00; font-weight: bold');
        console.warn('Failed tests:', results.failed);
    }

    return results;
}

// TIER_ALIASES, normalizeTier, getNodeTier, getNodeAtomFamily, normalizeRingValue,
// getNodeRing, getNodeLayer, getNodeEffect - provided by node-accessors.js module

// getNodeColorByMode, getSubsystem, getPhase, getFileType, getRoleCategory, applyNodeColors - MOVED TO modules/node-helpers.js
// normalize - MOVED TO modules/utils.js

function filterGraph(data, minVal, datamapSet, filters) {
    // ALL DATA FROM DM - the processing pipeline
    const allNodes = DM ? DM.getNodes() : (data?.nodes || []);
    const allLinks = DM ? DM.getLinks() : (data?.links || []);

    const tierFilter = filters?.tiers || new Set();
    const ringFilter = filters?.rings || new Set();
    const roleFilter = filters?.roles || new Set();
    const edgeFilter = filters?.edges || new Set();
    const familyFilter = filters?.families || new Set();
    const layerFilter = filters?.layers || new Set();
    const effectFilter = filters?.effects || new Set();
    const edgeFamilyFilter = filters?.edgeFamilies || new Set();
    const showEdges = filters?.metadata?.showEdges !== false;

    const availableRings = Array.from(new Set(allNodes.map(n => getNodeRing(n)))).sort();
    let ringFilterValues = Array.from(ringFilter);
    let ringIntersection = ringFilterValues.filter(r => availableRings.includes(r));
    if (ringFilterValues.length > 0 && ringIntersection.length === 0) {
        console.warn('[Filters] Ring filter values not present in dataset; clearing.', {
            ringValues: ringFilterValues,
            availableRings
        });
        ringFilter.clear();
        ringFilterValues = [];
        ringIntersection = [];
    }

    // Filter nodes by size/importance
    let visibleNodes = allNodes.filter(n => (n.val ?? 1) >= minVal);

    if (datamapSet && datamapSet.size > 0) {
        visibleNodes = visibleNodes.filter(n => {
            for (const id of datamapSet) {
                const config = DATAMAP_INDEX[id];
                if (config && datamapMatches(n, config)) return true;
            }
            return false;
        });
    }
    // Filter out CODOME boundary nodes if toggle is OFF
    if (!SHOW_CODOME) {
        visibleNodes = visibleNodes.filter(n => !n.is_codome_boundary && !n._fromCodome);
    }


    const tierFilterActive = tierFilter.size > 0;
    const ringFilterActive = ringFilter.size > 0;
    const roleFilterActive = roleFilter.size > 0;
    const familyFilterActive = familyFilter.size > 0;
    const layerFilterActive = layerFilter.size > 0;
    const effectFilterActive = effectFilter.size > 0;

    const filterSummary = {
        active: {
            tier: tierFilter.size,
            ring: ringFilter.size,
            role: roleFilter.size,
            family: familyFilter.size,
            layer: layerFilter.size,
            effect: effectFilter.size
        },
        ringValues: ringFilterValues.slice().sort(),
        availableRings,
        ringIntersectionSize: ringIntersection.length
    };
    const filterSummaryKey = JSON.stringify(filterSummary);
    if (filterSummaryKey !== LAST_FILTER_SUMMARY) {
        console.log('[Filters] summary', filterSummary);
        LAST_FILTER_SUMMARY = filterSummaryKey;
    }

    visibleNodes = visibleNodes.filter(n => {
        if (tierFilterActive && !tierFilter.has(getNodeTier(n))) return false;
        if (ringFilterActive && !ringFilter.has(getNodeRing(n))) return false;
        if (roleFilterActive && !roleFilter.has(String(n.role || 'Unknown'))) return false;
        if (familyFilterActive && !familyFilter.has(getNodeAtomFamily(n))) return false;
        if (layerFilterActive && !layerFilter.has(getNodeLayer(n))) return false;
        if (effectFilterActive && !effectFilter.has(getNodeEffect(n))) return false;
        return true;
    });



    // Zero-node protection: warn when dimension filters result in empty graph
    if (visibleNodes.length === 0 && (tierFilterActive || ringFilterActive || roleFilterActive || familyFilterActive || layerFilterActive || effectFilterActive)) {
        const activeFilters = [];
        if (tierFilterActive) activeFilters.push(`tiers: [${Array.from(tierFilter).join(', ')}]`);
        if (ringFilterActive) activeFilters.push(`rings: [${Array.from(ringFilter).join(', ')}]`);
        if (roleFilterActive) activeFilters.push(`roles: [${Array.from(roleFilter).join(', ')}]`);
        if (familyFilterActive) activeFilters.push(`families: [${Array.from(familyFilter).join(', ')}]`);
        if (layerFilterActive) activeFilters.push(`layers: [${Array.from(layerFilter).join(', ')}]`);
        if (effectFilterActive) activeFilters.push(`effects: [${Array.from(effectFilter).join(', ')}]`);
        console.warn('[filterGraph] Zero nodes match filters:', activeFilters.join(', '));
    }

    const visibleIds = new Set(visibleNodes.map(n => n.id));

    // Keep edges only between visible nodes
    let visibleLinks = allLinks.filter(l =>
        visibleIds.has(l.source.id || l.source) &&
        visibleIds.has(l.target.id || l.target)
    );

    if (edgeFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFilter.has(String(l.edge_type || l.type || 'default')));
    }

    if (edgeFamilyFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFamilyFilter.has(l.family || 'Dependency'));
    }

    // Filter out inferred edges from CODOME if toggle is OFF
    if (!SHOW_CODOME) {
        visibleLinks = visibleLinks.filter(l => !l._fromCodome && !l.inferred);
    }

    if (!showEdges) {
        visibleLinks = [];
    }

    return { nodes: visibleNodes, links: visibleLinks };
}

// ====================================================================
// LAYOUT STABILITY: saveNodePositions, restoreNodePositions, freezeLayout, unfreezeLayout, resetLayout - MOVED TO modules/layout-helpers.js
// showModeToast - MOVED TO modules/tooltips.js
// getLinkEndpointId, getFileTarget - MOVED TO modules/layout-helpers.js
// stableOffset - MOVED TO modules/utils.js

// buildFileGraph - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.buildFileGraph)
// captureFileNodePositions - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.captureFileNodePositions)

function buildHybridGraph(data) {
    // ALL DATA FROM DM - the reaction chamber for data chemistry
    if (!FILE_GRAPH) {
        FILE_GRAPH = buildFileGraph(data);
    }
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const nodes = DM ? DM.getNodes() : (data?.nodes || []);
    const links = DM ? DM.getLinks() : (data?.links || []);

    const totalFiles = boundaries.length;
    const clusterConfig = data?.physics?.cluster || {};
    const detachRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius * 1.3 : 200;
    const detachZ = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing * 2 : 80;
    const expandRadius = 30;
    const expandedSet = new Set(EXPANDED_FILES);

    const fileNodes = FILE_GRAPH.nodes.map(node => {
        const copy = Object.assign({}, node);
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach' && expandedSet.has(node.fileIdx))
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        copy.x = anchor.x + detachOffset.x;
        copy.y = anchor.y + detachOffset.y;
        copy.z = (anchor.z || 0) + detachOffset.z;
        return copy;
    });

    const nodeFileIdx = new Map();
    nodes.forEach(n => {
        if (n && n.id) {
            nodeFileIdx.set(n.id, n.fileIdx ?? -1);
        }
    });

    const childNodes = [];
    nodes.forEach(node => {
        if (!expandedSet.has(node.fileIdx)) return;
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach')
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        const local = stableOffset(node, `file-${node.fileIdx}`, expandRadius);
        const copy = Object.assign({}, node);
        copy.x = anchor.x + detachOffset.x + local.x;
        copy.y = anchor.y + detachOffset.y + local.y;
        copy.z = (anchor.z || 0) + detachOffset.z + (IS_3D ? local.z : 0);
        childNodes.push(copy);
    });

    const childLinks = [];
    links.forEach(link => {
        const srcId = getLinkEndpointId(link, 'source');
        const tgtId = getLinkEndpointId(link, 'target');
        const srcIdx = nodeFileIdx.get(srcId) ?? -1;
        const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;
        if (srcIdx < 0 || tgtIdx < 0 || srcIdx !== tgtIdx) return;
        if (!expandedSet.has(srcIdx)) return;
        childLinks.push({
            source: srcId,
            target: tgtId,
            color: link.color,
            opacity: link.opacity,
            edge_type: link.edge_type,
            weight: link.weight,
            confidence: link.confidence,
            resolution: link.resolution
        });
    });

    return {
        nodes: fileNodes.concat(childNodes),
        links: FILE_GRAPH.links.concat(childLinks)
    };
}

function setupControls(data) {
    // Initialize the Unified UI Manager
    UIManager.init(data);

    // Initialize modules that require data/DOM to be ready
    // (SIDEBAR.init() is called earlier in DOMContentLoaded)
    if (typeof LAYOUT !== 'undefined' && LAYOUT.init) LAYOUT.init();
    if (typeof HUD !== 'undefined' && HUD.setupFade) HUD.setupFade();
    if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) DIMENSION.setup();

    // Initialize Command Bar and Floating Panels
    initCommandBar();

    // Initialize Selection Detail Modal
    initSelectionModal();

    // Initialize Node & Edge Config Controls (PRIME SECTIONS)
    setupConfigControls();

    // Render color-coded legends with counts
    renderAllLegends();

    // Flow mode button (attached here for proper DOM timing)
    const btnFlow = document.getElementById('btn-flow');
    if (btnFlow) btnFlow.onclick = () => toggleFlowMode();
}

/**
 * =================================================================
 * setupConfigControls: Initialize NODE CONFIG and EDGE CONFIG panels
 * =================================================================
 * These are the "prime position" controls at the top of the sidebar
 */
function setupConfigControls() {
    // Helper: Bind slider with value display
    const bindSlider = (id, valueId, onChange, decimals = 1) => {
        const slider = document.getElementById(id);
        const valueEl = document.getElementById(valueId);
        if (!slider) return;
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (valueEl) valueEl.textContent = decimals === 0 ? val.toString() : val.toFixed(decimals);
            onChange(val);
        });
    };

    // Helper: Bind toggle switch
    const bindToggle = (id, initialState, onChange) => {
        const toggle = document.getElementById(id);
        if (!toggle) return;
        if (initialState) toggle.classList.add('active');
        else toggle.classList.remove('active');
        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            onChange(isActive);
        });
    };

    // Helper: Bind button group (radio-like selection)
    const bindButtonGroup = (container, dataAttr, onChange) => {
        const buttons = container.querySelectorAll(`[${dataAttr}]`);
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                onChange(btn.getAttribute(dataAttr));
            });
        });
    };

    // ═══════════════════════════════════════════════════════════════════
    // NODE CONFIG
    // ═══════════════════════════════════════════════════════════════════

    // Size Mode Selector
    const nodeCfg = document.getElementById('section-node-config');
    if (nodeCfg) {
        bindButtonGroup(nodeCfg, 'data-size-mode', (mode) => {
            APPEARANCE_STATE.sizeMode = mode;
            applyNodeSizeMode(mode);
            console.log('[CONFIG] Size mode:', mode);
        });
    }

    // Node Base Size
    bindSlider('cfg-node-size', 'cfg-node-size-val', (val) => {
        APPEARANCE_STATE.nodeScale = val;
        applyNodeSizeMode(APPEARANCE_STATE.sizeMode || 'uniform');
    });

    // Node Opacity
    bindSlider('cfg-node-opacity', 'cfg-node-opacity-val', (val) => {
        APPEARANCE_STATE.nodeOpacity = val;
        if (Graph) Graph.nodeOpacity(val);
    });

    // Node Resolution (sphere segments)
    bindSlider('cfg-node-res', 'cfg-node-res-val', (val) => {
        APPEARANCE_STATE.nodeResolution = Math.round(val);
        if (Graph) Graph.nodeResolution(Math.round(val));
    }, 0);

    // Label Size
    bindSlider('cfg-label-size', 'cfg-label-size-val', (val) => {
        APPEARANCE_STATE.labelSize = val;
        if (Graph && APPEARANCE_STATE.showLabels) {
            Graph.nodeLabel(node => val > 0.2 ? (node.name || node.id) : null);
        }
    });

    // Show Labels Toggle
    bindToggle('cfg-toggle-labels', APPEARANCE_STATE.showLabels, (active) => {
        APPEARANCE_STATE.showLabels = active;
        if (Graph) Graph.nodeLabel(node => active ? (node.name || node.id) : null);
    });

    // Highlight Selected Toggle
    bindToggle('cfg-toggle-highlight', APPEARANCE_STATE.highlightSelected, (active) => {
        APPEARANCE_STATE.highlightSelected = active;
        if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();
    });

    // Pulse Animation Toggle
    bindToggle('cfg-toggle-pulse', false, (active) => {
        APPEARANCE_STATE.pulseAnimation = active;
        console.log('[CONFIG] Pulse animation:', active ? 'ON' : 'OFF');
    });

    // 3D Depth Shading Toggle
    bindToggle('cfg-toggle-depth', true, (active) => {
        APPEARANCE_STATE.depthShading = active;
        console.log('[CONFIG] Depth shading:', active ? 'ON' : 'OFF');
    });

    // ═══════════════════════════════════════════════════════════════════
    // EDGE CONFIG - Enhanced with better visibility and flow animation
    // ═══════════════════════════════════════════════════════════════════

    // Edge Style Selector
    const edgeCfg = document.getElementById('section-edge-config');
    if (edgeCfg) {
        bindButtonGroup(edgeCfg, 'data-edge-style', (style) => {
            APPEARANCE_STATE.edgeStyle = style;
            applyEdgeStyle(style);
            console.log('[CONFIG] Edge style:', style);
        });
    }

    // Edge Opacity - ENHANCED: Higher default for visibility
    bindSlider('cfg-edge-opacity', 'cfg-edge-opacity-val', (val) => {
        APPEARANCE_STATE.edgeOpacity = val;
        // Use applyEdgeMode to ensure consistent function-based opacity
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Width - ENHANCED: Thicker default
    bindSlider('cfg-edge-width', 'cfg-edge-width-val', (val) => {
        APPEARANCE_STATE.edgeWidth = val;
        // Use applyEdgeMode to ensure consistent function-based width
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Curvature - Direct Graph API (not handled by EDGE module)
    bindSlider('cfg-edge-curve', 'cfg-edge-curve-val', (val) => {
        APPEARANCE_STATE.edgeCurvature = val;
        if (Graph) Graph.linkCurvature(val);
    });

    // Particle Speed - For FLOW visualization
    bindSlider('cfg-particle-speed', 'cfg-particle-speed-val', (val) => {
        APPEARANCE_STATE.particleSpeed = val;
        if (Graph) Graph.linkDirectionalParticleSpeed(val);
    }, 3);

    // Particle Density - For FLOW visualization
    bindSlider('cfg-particle-count', 'cfg-particle-count-val', (val) => {
        APPEARANCE_STATE.particleCount = Math.round(val);
        if (Graph) Graph.linkDirectionalParticles(Math.round(val));
    }, 0);

    // NOTE: Toggle bindings moved to sidebar.js (_bindAppearanceControls)
    // Keeping only initial state sync here
    const arrowToggle = document.getElementById('cfg-toggle-arrows');
    if (arrowToggle && APPEARANCE_STATE.showArrows) arrowToggle.classList.add('active');

    const gradientToggle = document.getElementById('cfg-toggle-gradient');
    if (gradientToggle && APPEARANCE_STATE.gradientEdges) gradientToggle.classList.add('active');

    // Highlight Edges on Hover Toggle
    bindToggle('cfg-toggle-edge-hover', true, (active) => {
        APPEARANCE_STATE.edgeHoverHighlight = active;
    });

    // Show CODOME Boundaries Toggle
    bindToggle('cfg-toggle-codome', SHOW_CODOME, (active) => {
        SHOW_CODOME = active;
        console.log('[CONFIG] CODOME boundaries:', SHOW_CODOME ? 'ON' : 'OFF');
        // Re-render graph with updated filtering
        const filtered = filterGraph(FULL_GRAPH, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        if (Graph) Graph.graphData(filtered);
    });

    // ═══════════════════════════════════════════════════════════════════
    // Section Collapse Handlers
    // ═══════════════════════════════════════════════════════════════════
    document.querySelectorAll('.section-header[data-section]').forEach(header => {
        header.addEventListener('click', () => {
            const sectionId = header.dataset.section;
            const content = document.getElementById(`section-${sectionId}`);
            if (!content) return;
            const isCollapsed = header.classList.toggle('collapsed');
            content.classList.toggle('collapsed', isCollapsed);
        });
    });

    console.log('[CONFIG] Node & Edge config controls initialized');
}

// applyNodeSizeMode - MOVED TO modules/node-helpers.js

/**
 * Apply edge style - controls edge rendering mode
 */
function applyEdgeStyle(style) {
    if (!Graph) return;
    const opacity = APPEARANCE_STATE.edgeOpacity || 0.4;
    const speed = APPEARANCE_STATE.particleSpeed || 0.01;
    const count = APPEARANCE_STATE.particleCount || 0;

    switch (style) {
        case 'solid':
            Graph.linkLineDash(null);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'dashed':
            Graph.linkLineDash([4, 4]);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'particle':
            // Particle mode: dim lines, bright particles for flow effect
            Graph.linkLineDash(null);
            Graph.linkOpacity(Math.max(0.1, opacity * 0.3));
            Graph.linkDirectionalParticles(Math.max(4, count));
            Graph.linkDirectionalParticleSpeed(speed);
            Graph.linkDirectionalParticleWidth(3);
            Graph.linkDirectionalParticleColor(link => {
                // Use source node color for particles
                if (link.source && typeof link.source === 'object') {
                    return link.source.__threeObj?.material?.color?.getStyle() || '#00d4ff';
                }
                return '#00d4ff';
            });
            break;
    }
}

// UIManager - provided by ui-manager.js module (window.UI_MANAGER, window.UIManager)

function refreshGraph() {
    if (!DM || !Graph) return;  // ALL DATA FROM DM

    // LAYOUT STABILITY: Save current positions before any graph update
    saveNodePositions();

    if (GRAPH_MODE === 'files') {
        if (!FILE_GRAPH) {
            FILE_GRAPH = buildFileGraph(null);  // Uses DM internally
        }
        restoreNodePositions(FILE_GRAPH.nodes);
        Graph.graphData(FILE_GRAPH);
        applyFileColors(FILE_GRAPH.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel('name');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    if (GRAPH_MODE === 'hybrid') {
        const hybrid = buildHybridGraph(null);  // Uses DM internally
        restoreNodePositions(hybrid.nodes);
        Graph.graphData(hybrid);
        applyFileColors(hybrid.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    const subset = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);  // Uses DM internally
    if (ACTIVE_DATAMAPS.size > 0 && subset.nodes.length === 0) {
        showToast('No nodes for that datamap selection.');
        ACTIVE_DATAMAPS.clear();
        const fallback = filterGraph(null, CURRENT_DENSITY, new Set(), VIS_FILTERS);  // Uses DM internally
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        // Force re-evaluation of accessors
        Graph.nodeColor(Graph.nodeColor());
        Graph.nodeRelSize(Graph.nodeRelSize());
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        if (fileMode && GRAPH_MODE === 'atoms') {
            applyFileVizMode();
        }
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    // Zero-node protection for VIS_FILTERS (tier/ring/family/role)
    const hasActiveFilters = VIS_FILTERS.tiers.size > 0 || VIS_FILTERS.rings.size > 0 ||
        VIS_FILTERS.families.size > 0 || VIS_FILTERS.roles.size > 0;
    if (subset.nodes.length === 0 && hasActiveFilters) {
        showToast('No nodes match current filters. Clearing filters.');
        clearAllFilters();
        const fallback = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    applyNodeColors(subset.nodes);
    restoreNodePositions(subset.nodes);
    Graph.graphData(subset);
    Graph.nodeVal(node => {
        // Boundary nodes get 1.5x size multiplier
        const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
        const baseSize = node.val || 1;
        return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
    });
    Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
    applyEdgeMode();
    if (fileMode && GRAPH_MODE === 'atoms') {
        applyFileVizMode();
    }
    updateDatamapControls();
    syncSelectionAfterGraphUpdate();
    if (LAYOUT_FROZEN) freezeLayout();
}

// ═══════════════════════════════════════════════════════════════════════
// THEORY CONSTANTS - MOVED TO modules/theory.js
// ═══════════════════════════════════════════════════════════════════════
// SCALE_16_LEVELS, THREE_LAYERS, SMC_THEORY, LEVEL_ZONES, VIS_PRESETS
// Now provided by THEORY module with backward-compat shims

// Tooltip state - shared with modules/tooltips.js
const TOOLTIP_STATE = { visible: false, currentKey: null, element: null, hideTimeout: null };

// initTooltips, showTopoTooltip, hideTopoTooltip - MOVED TO modules/tooltips.js

// ═══════════════════════════════════════════════════════════════════════
// getTopoColor - MOVED TO modules/color-helpers.js

// ═══════════════════════════════════════════════════════════════════════
// LAYOUT PRESETS - MOVED TO modules/animation.js
// ═══════════════════════════════════════════════════════════════════════
// LAYOUT_PRESETS, STAGGER_PATTERNS, CURRENT_LAYOUT, LAYOUT_ANIMATION_ID,
// LAYOUT_TIME, CURRENT_STAGGER_PATTERN, applyLayoutPreset, cycleStaggerPattern,
// startLayoutMotion, startFlockSimulation, groupNodesByTier
// All now provided by ANIM module with O(n) spatial hashing (fixes ARCH-002)








// Count nodes by tier and family







// Hermite basis functions for C¹ continuous color interpolation




// ═══════════════════════════════════════════════════════════════









// OKLCH-inspired colors (converted to linear RGB for Three.js)
// Chaos (bottom): OKLCH(0.25, 0.12, 240) ≈ deep cosmic blue




// ═══════════════════════════════════════════════════════════════


























// clearAllFilters - MOVED TO modules/visibility.js







// collectCounts, buildCheckboxRow, buildFilterGroup - MOVED TO modules/ui-builders.js
// resolveDefaults - MOVED TO modules/utils.js
// normalizeDatamapConfig, resolveDatamapConfigs, datamapMatches - MOVED TO modules/datamap.js
// buildDatamapToggle, buildExclusiveOptions - MOVED TO modules/ui-builders.js

// ═══════════════════════════════════════════════════════════════════════════
// APPEARANCE SLIDERS - Orchestration layer (uses UI_BUILDERS for pure UI)
// This function owns the business logic: what sliders exist, their values,
// and what happens when they change. UI_BUILDERS.buildAppearanceSliders
// handles the DOM creation.
// ═══════════════════════════════════════════════════════════════════════════

function buildAppearanceSliders(containerId, sliderConfigs) {

    const resolveSlider = (key, fallback) => {
        const config = (sliderConfigs && sliderConfigs[key]) ? sliderConfigs[key] : {};
        return {
            label: config.label || fallback.label,
            min: (config.min !== undefined) ? config.min : fallback.min,
            max: (config.max !== undefined) ? config.max : fallback.max,
            step: (config.step !== undefined) ? config.step : fallback.step,
            default: (config.default !== undefined) ? config.default : fallback.value
        };
    };

    const sliderDefs = [
        (() => {
            const config = resolveSlider('edgeOpacity', {
                label: 'EDGE OPACITY',
                min: 0.02,
                max: 0.4,
                step: 0.01,
                value: EDGE_DEFAULT_OPACITY
            });
            return {
                id: 'edge-opacity',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.edgeOpacity ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.edgeOpacity = val;
                    applyEdgeMode();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('nodeScale', {
                label: 'NODE SCALE',
                min: 0.6,
                max: 2.5,
                step: 0.1,
                value: 1
            });
            return {
                id: 'node-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.nodeScale ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.nodeScale = val;
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('backgroundBrightness', {
                label: 'BACKGROUND',
                min: 0,
                max: 1,
                step: 0.05,
                value: 1
            });
            return {
                id: 'bg-brightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.backgroundBrightness ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.backgroundBrightness = val;
                    updateBackgroundBrightness();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('fileLightness', {
                label: 'FILE LIGHT',
                min: 20,
                max: 80,
                step: 1,
                value: 50
            });
            return {
                id: 'file-lightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.fileLightness ?? config.default,
                onChange: (val) => {
                    FILE_COLOR_CONFIG.lightness = val;
                    APPEARANCE_STATE.fileLightness = val;
                    if (fileMode) {
                        applyFileVizMode();
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hueShift', {
                label: 'HUE SHIFT',
                min: -180,
                max: 180,
                step: 1,
                value: 0
            });
            return {
                id: 'hue-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.hueShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.hueShift = val;
                    Color.setTransform('hueShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('chromaScale', {
                label: 'CHROMA SCALE',
                min: 0,
                max: 2,
                step: 0.05,
                value: 1
            });
            return {
                id: 'chroma-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.chromaScale ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.chromaScale = val;
                    Color.setTransform('chromaScale', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('lightnessShift', {
                label: 'LIGHT SHIFT',
                min: -20,
                max: 20,
                step: 1,
                value: 0
            });
            return {
                id: 'lightness-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.lightnessShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.lightnessShift = val;
                    Color.setTransform('lightnessShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('boundaryOpacity', {
                label: 'HULL OPACITY',
                min: 0.02,
                max: 0.25,
                step: 0.01,
                value: 0.1
            });
            return {
                id: 'boundary-fill',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryFill ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryFill = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hullWireOpacity', {
                label: 'HULL WIRE',
                min: 0.05,
                max: 0.6,
                step: 0.02,
                value: 0.35
            });
            return {
                id: 'boundary-wire',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryWire ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryWire = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('clusterStrength', {
                label: 'CLUSTER FORCE',
                min: 0,
                max: 1,
                step: 0.1,
                value: 0.45
            });
            return {
                id: 'cluster-strength',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.clusterStrength ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.clusterStrength = val;
                    if (fileMode && fileVizMode === 'cluster') {
                        applyClusterForce(null);  // Uses DM internally
                    }
                }
            };
        })(),
        // ═══════════════════════════════════════════════════════════
        // AMPLIFIER SLIDER - Power law exponent for visual contrast
        // γ=1 linear, γ>1 amplifies small differences, γ<1 compresses
        // Formula: amplified = value^(1/γ)
        // ═══════════════════════════════════════════════════════════
        (() => {
            const config = resolveSlider('amplifier', {
                label: 'AMPLIFIER (γ)',
                min: 0.3,
                max: 5.0,
                step: 0.1,
                value: 1.0
            });
            return {
                id: 'amplifier',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.amplifier ?? config.default,
                className: 'meta-amplifier',  // Special styling for meta-slider
                description: 'γ>1 amplifies differences, γ<1 compresses',
                onChange: (val) => {
                    APPEARANCE_STATE.amplifier = val;
                    // Re-apply edge mode to update widths with new amplification
                    applyEdgeMode();
                    // If in flow mode, re-apply flow visualization
                    if (flowMode) {
                        applyFlowVisualization();
                    }
                }
            };
        })()
    ];

    // Use UI_BUILDERS for pure DOM creation (decoupled architecture)
    // Each sliderDef has its own onChange handler - business logic stays here
    UI_BUILDERS.buildAppearanceSliders(containerId, sliderDefs);
}

// ═══════════════════════════════════════════════════════════════════════
// PHYSICS CONTROLS - Real-time force simulation adjustment
// ═══════════════════════════════════════════════════════════════════════
const PHYSICS_STATE = {
    charge: -120,
    linkDistance: 50,
    centerStrength: 0.05,
    velocityDecay: 0.4
};

const PHYSICS_PRESETS = {
    default: { charge: -120, linkDistance: 50, centerStrength: 0.05, velocityDecay: 0.4, label: 'DEFAULT' },
    tight: { charge: -80, linkDistance: 30, centerStrength: 0.1, velocityDecay: 0.5, label: 'TIGHT' },
    loose: { charge: -200, linkDistance: 80, centerStrength: 0.02, velocityDecay: 0.3, label: 'LOOSE' },
    explosive: { charge: -400, linkDistance: 120, centerStrength: 0.01, velocityDecay: 0.2, label: 'EXPLOSIVE' }
};

// applyPhysicsState, applyPhysicsPreset, updatePhysicsSliders, buildPhysicsControls - MOVED TO modules/physics.js

// updateBackgroundBrightness, applyMetadataVisibility - MOVED TO modules/visibility.js

// Deprecated setupSidebar - replaced by UIManager
// Deprecated buildDatamapControls - replaced by UIManager


// ═══════════════════════════════════════════════════════════════
// PRESET BUTTONS - Quick visualization mode selection (Tier, Family, etc.)
// Uses VIS_STATE for unified state management
// ═══════════════════════════════════════════════════════════════
const presetGrid = document.getElementById('dock-presets');
const presetBtnGrid = document.getElementById('preset-grid');
if (presetBtnGrid) {
    presetBtnGrid.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const presetKey = btn.dataset.preset;

            // Use VIS_STATE for unified state management
            if (typeof VIS_STATE !== 'undefined') {
                VIS_STATE.applyPreset(presetKey);
                return;
            }

            // Fallback for when VIS_STATE not loaded
            const preset = VIS_PRESETS[presetKey];
            if (!preset) return;

            presetBtnGrid.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            APPEARANCE_STATE.currentPreset = presetKey;
            APPEARANCE_STATE.colorMode = preset.colorBy;

            setNodeColorMode(preset.colorBy);

            const edgeModes = { 'type': 'gradient-tier', 'weight': 'weight', 'resolution': 'gradient-file' };
            EDGE_MODE = edgeModes[preset.edgeBy] || preset.edgeBy || 'gradient-tier';
            applyEdgeMode();

            if (presetKey === 'flow') {
                if (!flowMode && typeof toggleFlowMode === 'function') toggleFlowMode();
            } else if (flowMode && typeof disableFlowMode === 'function') {
                disableFlowMode();
            }

            if (typeof window.refreshGradientEdgeColors === 'function') {
                window.refreshGradientEdgeColors();
            }

            if (typeof renderAllLegends === 'function') {
                renderAllLegends();
            }

            console.log('[Preset] Applied:', preset.name, '| colorBy:', preset.colorBy, '| edgeBy:', preset.edgeBy);
        });
    });
}

// ═══════════════════════════════════════════════════════════════
// NOTE: Color scheme buttons are now handled by sidebar.js via SIDEBAR.initSchemeNavigator()
// The 33 named schemes (viridis, plasma, thermal, etc.) are defined in color-engine.js schemePaths
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// LAYOUT BUTTONS - Graph layout presets with perpetual motion
// ═══════════════════════════════════════════════════════════════
const layoutGrid = document.getElementById('layout-grid');
if (layoutGrid) {
    layoutGrid.querySelectorAll('.layout-btn').forEach(btn => {
        const layoutKey = btn.dataset.layout;
        // Assign ID if missing for Registry
        if (!btn.id) btn.id = `layout-btn-${layoutKey}`;

        REGISTRY.register(btn.id, () => {
            if (!layoutKey || !LAYOUT_PRESETS[layoutKey]) return;

            // Update active state
            layoutGrid.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Apply the layout
            applyLayoutPreset(layoutKey, true);

            console.log('[Layout] Applied:', LAYOUT_PRESETS[layoutKey].name);
        }, { desc: `Activate ${layoutKey} layout` });
    });
}

// VIEW section controls
buildExclusiveOptions('filter-node-color', [
    { label: 'TIER', value: 'tier' },
    { label: 'RING', value: 'ring' },
    { label: 'FAMILY', value: 'family' },
    { label: 'LAYER', value: 'layer' },
    { label: 'FILE', value: 'file' },
    { label: 'ATOM', value: 'atom' },
    { label: 'COMPLEXITY', value: 'complexity' },
    { label: 'CHURN', value: 'churn' }
], NODE_COLOR_MODE, setNodeColorMode);
buildExclusiveOptions('filter-edge-mode', [
    { label: 'GRAD-FILE', value: 'gradient-file' },
    { label: 'GRAD-TIER', value: 'gradient-tier' },
    { label: 'GRAD-FLOW', value: 'gradient-flow' },
    { label: 'TYPE', value: 'type' },
    { label: 'WEIGHT', value: 'weight' },
    { label: 'MONO', value: 'mono' }
], EDGE_MODE, setEdgeMode);
buildMetadataControls('filter-metadata', VIS_FILTERS.metadata);
buildAppearanceSliders('appearance-sliders', {}); // controlsConfig removed - sliders built dynamically
buildPhysicsControls('physics-sliders');  // Physics/forces controls

applyMetadataVisibility();
updateBackgroundBrightness();
refreshGraph();

// setupCollapsibleSections - MOVED TO modules/visibility.js

// setupReport, setupAIInsights, setupMetrics - MOVED TO modules/report.js

// escapeHtml - MOVED TO modules/utils.js

// setupHudFade, updateHudStats - MOVED TO modules/hud.js

// showToast - MOVED TO modules/tooltips.js
// updateDatamapControls - MOVED TO modules/datamap.js

// toggleDimensions, setupDimensionToggle, animateDimensionChange - MOVED TO modules/dimension.js

// stableSeed, stableZ - MOVED TO modules/utils.js

// ====================================================================
// EDGE VISUALIZATION MODES - GRADIENT & DATA-DRIVEN SYSTEM
// ====================================================================
// NEW: Edge modes with gradients showing data progression & regions
const EDGE_MODE_ORDER = [
    'gradient-tier',      // Source→Target tier flow (architecture layers)
    'gradient-file',      // File boundaries (module regions)
    'gradient-flow',      // Markov probability (hot paths)
    'gradient-depth',     // Call depth progression
    'gradient-semantic',  // Semantic distance (type similarity)
    'type',               // Classic type-based
    'weight',             // Weight intensity
    'mono'                // Minimal monochrome
];
const EDGE_MODE_LABELS = {
    'gradient-tier': '▼ TIER FLOW',
    'gradient-file': '▼ FILE REGIONS',
    'gradient-flow': '▼ HOT PATHS',
    'gradient-depth': '▼ CALL DEPTH',
    'gradient-semantic': '▼ SEMANTIC',
    type: 'EDGE: TYPE',
    weight: 'EDGE: WEIGHT',
    mono: 'EDGE: MONO'
};
const EDGE_MODE_HINTS = {
    'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
    'gradient-file': 'Color by file region - shows module boundaries',
    'gradient-flow': 'Hot paths - markov probability gradient',
    'gradient-depth': 'Color by call chain depth',
    'gradient-semantic': 'Color by semantic similarity of endpoints',
    type: 'Edge color by type (calls, imports, etc.)',
    weight: 'Edge width & color by weight',
    mono: 'Minimal monochrome'
};

// Gradient color palettes for different modes
const GRADIENT_PALETTES = {
    tier: {
        // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
        T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
        T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
        T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
        UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
    },
    file: {
        // Rainbow hues distributed across files
        saturation: 65,
        lightness: 48
    },
    flow: {
        // Cold (low prob) to Hot (high prob)
        cold: { h: 220, s: 60, l: 45 },   // Blue
        warm: { h: 45, s: 85, l: 50 },    // Yellow
        hot: { h: 0, s: 90, l: 55 }       // Red
    },
    depth: {
        // Shallow (bright) to Deep (dark, saturated)
        shallow: { h: 180, s: 50, l: 65 },  // Light cyan
        mid: { h: 260, s: 70, l: 50 },      // Purple
        deep: { h: 320, s: 80, l: 40 }      // Magenta
    },
    semantic: {
        // Similar (harmonious) to Different (contrasting)
        similar: { h: 150, s: 60, l: 50 },    // Green - same type
        related: { h: 200, s: 65, l: 48 },    // Cyan - related
        different: { h: 340, s: 75, l: 50 }   // Pink - different
    }
};

// FILE_HUE_MAP, buildFileHueMap - provided by edge-system.js module

// Get node tier value (0=T0, 1=T1, 2=T2)
// getNodeTierValue, getNodeDepth, getSemanticSimilarity - MOVED TO modules/node-helpers.js

// interpolateColor, applyColorTweaks, oklchToSrgb, oklchColor - MOVED TO modules/color-engine.js
// Use COLOR.interpolate() and COLOR.get() instead

// getGradientEdgeColor - MOVED TO modules/edge-system.js
// clamp01, clampValue - MOVED TO modules/utils.js
// hslColor REMOVED - Using OKLCH Native via Color.interpolate
// parseOklchString - MOVED TO modules/utils.js
// normalizeColorInput, toColorNumber - MOVED TO modules/color-helpers.js

// updateEdgeRanges, refreshNodeFileIndex, getLinkFileIdx - MOVED TO modules/edge-system.js
// (shims delegate to EDGE.updateRanges, EDGE.refreshNodeFileIndex; getLinkFileIdx is internal)

// normalizeMetric - MOVED TO modules/utils.js
// getEdgeColor, getEdgeWidth, applyEdgeMode, cycleEdgeMode, setEdgeMode - MOVED TO modules/edge-system.js
// (backward compat shims in edge-system.js)

// Datamap toggles are wired in buildDatamapControls().
const btnReport = document.getElementById('btn-report');
if (btnReport) {
    btnReport.onclick = () => {
        const panel = document.getElementById('report-panel');
        const btn = document.getElementById('btn-report');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// AI INSIGHTS PANEL TOGGLE
const btnInsights = document.getElementById('btn-insights');
if (btnInsights) {
    btnInsights.onclick = () => {
        const panel = document.getElementById('insights-panel');
        const btn = document.getElementById('btn-insights');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// setStarsVisible, STARS_STORAGE_KEY, stars toggle binding - MOVED TO modules/stars.js
// Call STARS.init() to initialize (done in modules/main.js)

// Reset Layout button - explicitly re-run physics
const btnResetLayout = document.getElementById('btn-reset-layout');
if (btnResetLayout) {
    btnResetLayout.onclick = () => resetLayout();
}

// Hints toggle - enable/disable mode toasts
const btnHints = document.getElementById('btn-hints');
if (btnHints) {
    btnHints.onclick = () => {
        HINTS_ENABLED = !HINTS_ENABLED;
        btnHints.classList.toggle('active', HINTS_ENABLED);
        if (HINTS_ENABLED) {
            showModeToast('Hints enabled');
        }
    };
}

const btnEdgeMode = document.getElementById('btn-edge-mode');
if (btnEdgeMode) {
    btnEdgeMode.onclick = () => cycleEdgeMode();
}

// ====================================================================
// FLOW MODE: Markov Chain Visualization (Token-Driven)
// ====================================================================
// flowMode hoisted to top
let originalLinkWidths = new Map();
let highEntropyNodes = new Set();
// FLOW_CONFIG is set in initGraph() from THE REMOTE CONTROL tokens

// getFlowPresetColor, getFlowPresetValue - MOVED TO modules/flow.js

// FLOW_PRESETS, currentFlowPreset - MOVED TO modules/flow.js

// toggleFlowMode, disableFlowMode, applyFlowVisualization, clearFlowVisualization - MOVED TO modules/flow.js

// setDatamap, setNodeColorMode, applyDatamap - MOVED TO modules/datamap.js

// ====================================================================
// FILE BOUNDARIES & HOVER SYSTEM
// ====================================================================
// NOTE: fileBoundaryMeshes, fileMode, fileVizMode, etc. declared at top of file

// hashToUnit - MOVED TO modules/utils.js
// getFileHue, getFileColor - MOVED TO modules/color-helpers.js
// updateHoverPanel, handleNodeHover, handleNodeClick - MOVED TO modules/hover.js
// buildDatasetKey - MOVED TO modules/utils.js
// loadGroups, saveGroups, getNextGroupColor, getGroupById, getPrimaryGroupForNode - MOVED TO modules/groups.js
// renderGroupList, updateGroupButtonState, createGroupFromSelection - MOVED TO modules/groups.js

// getSelectedNodes, setSelection, toggleSelection, clearSelection, maybeClearSelection - MOVED TO modules/selection.js
// Use SELECT.getSelectedNodes(), SELECT.set(), SELECT.toggle(), SELECT.clear(), SELECT.maybeClear()
// Shims in selection.js provide global function names for backward compatibility


function handleNodeHover(node, data) {
    const filePanel = document.getElementById('file-panel');
    HOVERED_NODE = node || null;

    // Always update hover panel (separate from file panel)
    updateHoverPanel(node);

    // Guard: file-panel may not exist in minimal template
    if (!filePanel) return;

    if (!VIS_FILTERS.metadata.showFilePanel) {
        filePanel.classList.remove('visible');
        return;
    }

    if (!node) {
        // Mouse left node - hide panel after delay
        setTimeout(() => {
            if (!fileMode) filePanel.classList.remove('visible');
        }, 300);
        return;
    }

    // Get file info from boundaries
    const boundaries = data.file_boundaries || [];
    const fileIdx = node.fileIdx;

    if (fileIdx < 0 || fileIdx >= boundaries.length) {
        return;
    }

    const fileInfo = boundaries[fileIdx];

    // Update panel content (with null checks for minimal template)
    const setEl = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.textContent = val;
    };
    setEl('file-name', fileInfo.file_name || 'unknown');
    setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
    setEl('file-purpose', fileInfo.purpose || '--');
    setEl('file-atom-count', fileInfo.atom_count || 0);
    setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
    setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
    setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

    // Show code preview from node body
    const code = node.body || '// no source available';
    setEl('file-code', code);

    // Show panel and trigger smart placement
    filePanel.classList.add('visible');
    HudLayoutManager.reflow();
}

function handleNodeClick(node, event) {
    if (!node) return;
    const additive = event && event.shiftKey;
    if (additive) {
        toggleSelection(node);
        return;
    }
    if (node.id) {
        setSelection([node.id]);
    }
    if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
        toggleFileExpand(node.fileIdx);
    }
}


// ====================================================================
// FILE MODE HANDLERS
// ====================================================================

// setFileModeState - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setEnabled)

const btnFiles = document.getElementById('btn-files');
if (btnFiles) btnFiles.onclick = () => setFileModeState(!fileMode);

// COLOR mode - atoms colored by file
const btnFileColor = document.getElementById('btn-file-color');
if (btnFileColor) btnFileColor.onclick = () => setFileVizMode('color');

// HULLS mode - draw boundary spheres
const btnFileHulls = document.getElementById('btn-file-hulls');
if (btnFileHulls) btnFileHulls.onclick = () => setFileVizMode('hulls');

// CLUSTER mode - force clustering by file
const btnFileCluster = document.getElementById('btn-file-cluster');
if (btnFileCluster) btnFileCluster.onclick = () => setFileVizMode('cluster');

// MAP mode - show file nodes
const btnFileMap = document.getElementById('btn-file-map');
if (btnFileMap) btnFileMap.onclick = () => setFileVizMode('map');

// SPHERES mode - show containment spheres (button may be hidden)
const spheresBtn = document.getElementById('btn-file-spheres');
if (spheresBtn) spheresBtn.onclick = () => setFileVizMode('spheres');

// POP button - toggle boundary pop/restore (button may be hidden)
const popBtn = document.getElementById('btn-file-pop');
if (popBtn) {
    popBtn.onclick = () => {
        if (!FILE_CONTAINMENT.boundariesPopped) {
            popBoundaries(3000);
            popBtn.classList.add('active');
            popBtn.textContent = 'RESTORE';
            showToast('Boundaries popped! Particles in slow-motion chaos...');
        } else {
            restoreBoundaries(2000);
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
            showToast('Boundaries restored. Order from chaos.');
        }
    };
}

// Expand mode toggles (only relevant in MAP mode)
const btnExpandInline = document.getElementById('btn-expand-inline');
if (btnExpandInline) {
    btnExpandInline.onclick = () => {
        FILE_EXPAND_MODE = 'inline';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}

const btnExpandDetach = document.getElementById('btn-expand-detach');
if (btnExpandDetach) {
    btnExpandDetach.onclick = () => {
        FILE_EXPAND_MODE = 'detach';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}


// setFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setMode)

// applyFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.apply)

// scheduleHullRedraw - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.scheduleHullRedraw)

// applyFileColors - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.applyColors)

// clearFileBoundaries - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearBoundaries)

// Moved here to avoid temporal dead zone issue
let fileCohesionActive = false;

// clearAllFileModes - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearAllModes)

// applyClusterForce, applyFileCohesion, clearFileCohesion - MOVED TO modules/file-viz.js

// ════════════════════════════════════════════════════════════════════════
// SURFACE PARITY HANDLERS - Architectural Enforcements
// ════════════════════════════════════════════════════════════════════════

// Panel Handlers - use togglePanel('view') etc. or PANELS.toggle('view')
// togglePanelView/Filter/Style/Settings - simplified via modules/panels.js


// Action Handlers
function handleCmdFlow() { toggleFlowMode(); }
function handleCmd3d() { toggleDimensions(); }

// PanelManager - provided by panels.js module (window.PANEL_DRAG, window.PanelManager)

// =================================================================
// THEME SWITCHING - MOVED TO modules/theme.js
// setTheme, getTheme, getAvailableThemes, cycleTheme, initTheme

// Initialize theme on DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        // Small delay to ensure CSS vars are loaded
        setTimeout(initTheme, 50);
    });
} else {
    setTimeout(initTheme, 50);
}

// Expose theme functions globally
window.setTheme = setTheme;
window.getTheme = getTheme;
window.getAvailableThemes = getAvailableThemes;
window.cycleTheme = cycleTheme;
window.THEME_CONFIG = THEME_CONFIG;

// Expose filtering/graph globals for module access
window.VIS_FILTERS = VIS_FILTERS;
window.refreshGraph = refreshGraph;

    </script>
</body>

</html>