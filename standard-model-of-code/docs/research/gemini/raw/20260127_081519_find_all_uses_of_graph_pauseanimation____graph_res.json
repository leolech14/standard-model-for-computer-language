{
  "_meta": {
    "saved_at": "2026-01-27T08:15:19.550321",
    "source": "gemini",
    "model": "gemini-3-pro-preview",
    "query": "Find all uses of Graph.pauseAnimation(), Graph.resumeAnimation(), Graph.onRenderFramePost, Graph.d3Force(), and animation lifecycle management in the current codebase. I need to understand:\n1. Do we currently use pauseAnimation/resumeAnimation anywhere?\n2. How do we control the force simulation lifecycle?\n3. What callbacks are available from 3d-force-graph?\n4. How do animation.js and the Graph interact?\n5. What's the current pattern for stopping/starting animations?",
    "query_length": 470,
    "checksum": "sha256:90a65a64f9cd87fe00a412f55d0554c8ffc862738f3198e267a7f0a6146d4149"
  },
  "response": {
    "content": "Based on the provided codebase context, here is the analysis of the animation lifecycle and graph control mechanisms.\n\n### 1. Do we currently use `pauseAnimation` / `resumeAnimation`?\n\n**No.** A search of the provided files (`animation.js`, `panel-handlers.js`, `physics.js`, `layout-helpers.js`, etc.) reveals **zero usages** of `Graph.pauseAnimation()` or `Graph.resumeAnimation()`.\n\nThe codebase does not pause the WebGL render loop. Instead, it controls the **physics simulation engine** to stop node movement while keeping the canvas responsive for interaction (cam rotation, hovering).\n\n### 2. How do we control the force simulation lifecycle?\n\nThe codebase uses a mix of D3-specific controls and a custom animation loop in `animation.js`.\n\n*   **Freezing (Stopping Physics):**\n    *   **Method 1 (`cooldownTicks`):** In `layout-helpers.js` and `panel-handlers.js`, `Graph.cooldownTicks(0)` is used to stop the simulation immediately.\n    *   **Method 2 (`d3AlphaTarget`):** `Graph.d3AlphaTarget(0)` is used in `dimension.js` to let the simulation cool down naturally or stop during transitions.\n    *   **Method 3 (Nullifying Forces):** `panel-handlers.js` (Freeze button) explicitly removes forces:\n        ```javascript\n        Graph.d3Force('charge', null);\n        Graph.d3Force('link', null);\n        ```\n    *   **Method 4 (Pinning):** `LAYOUT_HELPERS.freeze()` sets `node.fx`, `node.fy`, `node.fz` to current positions, effectively locking nodes in place.\n\n*   **Heating (Starting Physics):**\n    *   **Reheating:** `Graph.d3ReheatSimulation()` is called frequently (e.g., in `physics.js` after slider updates, `layout-forces.js` after applying new forces).\n    *   **Alpha Decay:** `Graph.d3AlphaDecay(...)` is adjusted in `panel-handlers.js` to control how fast the simulation settles.\n\n### 3. What callbacks are available from 3d-force-graph?\n\nBased on the code provided, the system does **not** explicitly hook into `3d-force-graph`'s native render callbacks (like `onRenderFramePost`) within the modules provided.\n\n*   **Custom Monitoring:** Instead of relying on Graph callbacks, `perf-monitor.js` sets up its own `requestAnimationFrame` loop to measure FPS and render calls.\n*   **Custom Animation Loop:** `animation.js` runs its own `requestAnimationFrame` loop to handle tweening and non-D3 layouts (like Orbital or Grid) and calls `REFRESH.throttled()` to update the graph.\n\n### 4. How do `animation.js` and the `Graph` interact?\n\n`animation.js` acts as an **external controller** that overrides the Graph's internal physics when applying specific layouts.\n\n*   **The \"Owner\" Pattern:** `animation.js` enforces a single active animation via `_acquireOwnership(owner)`. This prevents `crossfade`, `layout`, and `flock` animations from fighting.\n*   **Position Manipulation:**\n    *   For layouts like **Grid** or **Orbital**, `animation.js` calculates exact coordinates and writes them to `node.fx`, `node.fy`, `node.fz` (fixed positions).\n    *   It then calls `REFRESH.throttled()` (which calls `Graph.refresh()`) to notify the renderer of data changes.\n*   **Hiding Edges:** During heavy transitions (like `_animateStaggered`), `animation.js` sets `Graph.linkOpacity(0)` to improve performance, restoring it when the animation completes.\n*   **Crossfade:** It manipulates `node._viewOpacity` and traverses the Three.js objects directly (`node.__threeObj.material.opacity`) to handle visual transitions without re-running the physics engine.\n\n### 5. What's the current pattern for stopping/starting animations?\n\nThe codebase distinguishes between **Physics Simulation** (D3) and **Visual Transitions** (Tweens).\n\n**A. Physics Simulation (Continuous Force Layout):**\n*   **Stop:** `Graph.cooldownTicks(0)` inside `LAYOUT_HELPERS.freeze()`.\n*   **Start:** `Graph.d3ReheatSimulation()` inside `PHYSICS.applyState()`.\n\n**B. Visual Transitions (Layout Changes / Camera):**\n*   **Start:** `ANIM.applyLayout(preset)` initiates a `requestAnimationFrame` loop stored in `_animationId`.\n*   **Stop:** `ANIM.stop()` calls `cancelAnimationFrame(_animationId)` and clears the owner.\n\n**Summary Table of Controls:**\n\n| Action | Mechanism Used | Location |\n| :--- | :--- | :--- |\n| **Stop Physics** | `Graph.cooldownTicks(0)` | `layout-helpers.js`, `panel-handlers.js` |\n| **Disable Forces** | `Graph.d3Force(name, null)` | `panel-handlers.js`, `layout-forces.js` |\n| **Restart Physics** | `Graph.d3ReheatSimulation()` | `physics.js`, `control-bar.js` |\n| **Stop Transitions**| `cancelAnimationFrame(_animationId)` | `animation.js` |\n| **Render Update** | `REFRESH.throttled()` -> `Graph.refresh()` | `refresh-throttle.js` |",
    "mode": "standard"
  }
}