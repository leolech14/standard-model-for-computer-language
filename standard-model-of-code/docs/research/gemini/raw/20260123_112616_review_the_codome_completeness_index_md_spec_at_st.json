{
  "_meta": {
    "saved_at": "2026-01-23T11:26:16.938731",
    "source": "gemini",
    "model": "gemini-3-pro-preview",
    "query": "Review the CODOME_COMPLETENESS_INDEX.md spec at standard-model-of-code/docs/specs/CODOME_COMPLETENESS_INDEX.md. \n\nTASKS:\n1. Validate the architecture - is CCI = Sensitivity × Specificity the right formula? Should we use F1 instead? What about weighted versions?\n\n2. Challenge: Design a PRECISION CONTEXT FETCHING system using Perplexity API SONAR-PRO model. The goal is to fetch pinpoint external knowledge (documentation, best practices, edge cases) when our CCI attribution reveals OUR_FAULT gaps. For example, if we miss IIFE patterns, the system should auto-query Perplexity for 'JavaScript IIFE module patterns detection AST' and return structured guidance.\n\nRequirements for the Perplexity integration:\n- Use sonar-pro model for maximum context window\n- Query formulation from attribution category\n- Response parsing into actionable guidance\n- Caching strategy to avoid duplicate queries\n- Rate limiting and cost control\n\nOutput: Concrete Python architecture for this integration.",
    "query_length": 986,
    "checksum": "sha256:4be78adc6ade4ae2887a2dda55cb75d40e3e51948b48e3a7dd0647b9a11b6926"
  },
  "response": {
    "content": "Since the file `standard-model-of-code/docs/specs/CODOME_COMPLETENESS_INDEX.md` is referenced but its content is not in the provided context, I will validate the formula based on your description and standard data science principles, then proceed to the architectural design of the Perplexity integration.\n\n---\n\n### Part 1: Validation of CODOME Completeness Index (CCI)\n\n**Current Formula:** `CCI = Sensitivity × Specificity`\n\n#### 1. Critique of the Formula\nWhile mathematically sound for balanced datasets, this formula has specific risks in the context of Code AST Extraction (an \"imbalanced\" problem where non-target tokens vastly outnumber target atoms):\n\n*   **The \"Zero\" Penalty:** If either metric is 0, the score is 0. This is good for strictness but bad for progress tracking (a system with 99% Sensitivity and 0.1% Specificity scores near zero, hiding its high detection capability).\n*   **The Specificity Trap:** In code analysis, \"True Negatives\" (stuff correctly identified as *not* being a specific atom) are conceptually infinite (whitespace, comments, other atoms). Specificity ($TN / (TN + FP)$) becomes artificially high because TN is huge.\n*   **Multiplication vs. Harmonic Mean:** Multiplication implies the metrics are independent probabilities.\n\n#### 2. Recommendation: The F-Beta Score (Specifically F2)\nFor \"Completeness,\" **Sensitivity (Recall)** is more important than **Precision**. We want to find *all* atoms first, then filter noise later.\n\n**Recommended Formula:** **F2 Score**\n$$ F_2 = (1 + 2^2) \\cdot \\frac{\\text{Precision} \\times \\text{Recall}}{(2^2 \\cdot \\text{Precision}) + \\text{Recall}} $$\n\n*   **Why:** F2 weighs Recall (Sensitivity) higher than Precision. It penalizes missing an IIFE pattern (False Negative) more than misclassifying a comment as code (False Positive).\n*   **Alternative:** If you stick to the geometric approach, use **G-Mean** ($\\sqrt{Sensitivity \\times Specificity}$), which dampens the volatility of raw multiplication.\n\n---\n\n### Part 2: Precision Context Fetching Architecture\n\nThis system acts as a \"just-in-time\" researcher. When the CCI logic detects a specific gap (e.g., \"Missed Pattern\"), it dispatches a Sonar-Pro agent to fetch the implementation details needed to close that gap.\n\n#### 1. System Design\n\n**Location:** `context-management/tools/ai/research/precision_fetcher.py`\n**Config:** Extensions to `aci_config.yaml`\n\n```mermaid\ngraph TD\n    A[Gap Detector] -->|Identifies FN| B(Gap Profile)\n    B -->|Language: JS, Type: IIFE| C{Cache Check}\n    C -->|Hit| D[Return Cached Strategy]\n    C -->|Miss| E[Prompt Engineer]\n    E -->|Construct Query| F[Perplexity API<br/>Model: sonar-pro]\n    F -->|Raw Response| G[Guidance Parser]\n    G -->|Structured JSON| H[Knowledge Store]\n    H --> D\n```\n\n#### 2. Python Implementation\n\nThis implementation uses `pydantic` for structure and `httpx` for async API communication, aligning with the project's tooling.\n\n```python\nimport os\nimport json\nimport hashlib\nimport time\nimport asyncio\nfrom typing import List, Optional, Dict, Literal\nfrom pathlib import Path\nfrom pydantic import BaseModel, Field\nimport httpx\nimport yaml\n\n# =============================================================================\n# DATA MODELS\n# =============================================================================\n\nclass GapProfile(BaseModel):\n    \"\"\"Defines the specific 'Our Fault' gap detected by CCI.\"\"\"\n    language: str\n    missing_atom: str  # e.g., \"LOG.MOD.IIFE\"\n    context_snippet: str  # The raw code we failed to capture\n    error_type: Literal[\"MISSING_DETECTION\", \"MISCLASSIFICATION\", \"BOUNDARY_ERROR\"]\n\nclass ActionableGuidance(BaseModel):\n    \"\"\"Structured knowledge returned by Sonar-Pro.\"\"\"\n    pattern_name: str\n    detection_regex: Optional[str]\n    tree_sitter_query: Optional[str]\n    edge_cases: List[str]\n    implementation_tips: str\n    confidence: float\n\nclass ResearchResult(BaseModel):\n    gap_id: str\n    timestamp: float\n    guidance: ActionableGuidance\n    source_urls: List[str]\n\n# =============================================================================\n# CONFIGURATION MANAGEMENT\n# =============================================================================\n\nclass ACIFetcherConfig:\n    \"\"\"Manages rate limits and model settings.\"\"\"\n    def __init__(self, config_path: str = \"context-management/config/aci_config.yaml\"):\n        self.api_key = os.getenv(\"PERPLEXITY_API_KEY\")\n        self.model = \"sonar-pro\"\n        self.max_retries = 3\n        self.cache_dir = Path(\".agent/intelligence/external_cache\")\n        self.cache_dir.mkdir(parents=True, exist_ok=True)\n        \n        # Load constraints from YAML if exists\n        if os.path.exists(config_path):\n            with open(config_path) as f:\n                self.aci_config = yaml.safe_load(f)\n\n# =============================================================================\n# CORE ENGINE\n# =============================================================================\n\nclass PrecisionContextFetcher:\n    def __init__(self):\n        self.config = ACIFetcherConfig()\n        self.client = httpx.AsyncClient(\n            base_url=\"https://api.perplexity.ai\",\n            headers={\"Authorization\": f\"Bearer {self.config.api_key}\"},\n            timeout=60.0\n        )\n\n    def _get_cache_key(self, gap: GapProfile) -> str:\n        \"\"\"Create deterministic hash for the gap.\"\"\"\n        payload = f\"{gap.language}:{gap.missing_atom}:{gap.error_type}\"\n        return hashlib.sha256(payload.encode()).hexdigest()\n\n    async def _check_cache(self, cache_key: str) -> Optional[ResearchResult]:\n        cache_file = self.config.cache_dir / f\"{cache_key}.json\"\n        if cache_file.exists():\n            try:\n                data = json.loads(cache_file.read_text())\n                return ResearchResult(**data)\n            except Exception:\n                return None\n        return None\n\n    def _construct_system_prompt(self) -> str:\n        return \"\"\"\n        You are a Senior Compiler Engineer and AST Expert. \n        Your goal is to provide concrete implementation details for detecting code patterns.\n        \n        OUTPUT FORMAT:\n        Return ONLY valid JSON matching this schema:\n        {\n            \"pattern_name\": \"Standard name of the pattern\",\n            \"detection_regex\": \"A python-safe regex to find this textually (if possible)\",\n            \"tree_sitter_query\": \"The S-expression query for Tree-Sitter (if applicable)\",\n            \"edge_cases\": [\"List of 3 common ways parsing fails\"],\n            \"implementation_tips\": \"Advice for implementing the extractor\",\n            \"confidence\": 0.0 to 1.0\n        }\n        \"\"\"\n\n    def _construct_user_prompt(self, gap: GapProfile) -> str:\n        return f\"\"\"\n        TASK: We failed to detect a '{gap.missing_atom}' in {gap.language}.\n        \n        CONTEXT SNIPPET:\n        ```\n        {gap.context_snippet}\n        ```\n        \n        ERROR TYPE: {gap.error_type}\n        \n        REQUEST:\n        1. Identify the specific syntax pattern shown in the snippet.\n        2. Provide the Tree-sitter S-expression query to capture this node.\n        3. Explain how to differentiate this from similar constructs.\n        \"\"\"\n\n    async def resolve_gap(self, gap: GapProfile) -> ResearchResult:\n        \"\"\"Main entry point to fetch context for a gap.\"\"\"\n        cache_key = self._get_cache_key(gap)\n        \n        # 1. Cache Layer\n        cached = await self._check_cache(cache_key)\n        if cached:\n            print(f\"[ACI] Cache Hit for {gap.missing_atom}\")\n            return cached\n\n        # 2. Rate Limiting (Simple Token Bucket Logic could go here)\n        print(f\"[ACI] Fetching external context for {gap.missing_atom} via Sonar-Pro...\")\n\n        # 3. API Execution\n        try:\n            response = await self.client.post(\n                \"/chat/completions\",\n                json={\n                    \"model\": self.config.model,\n                    \"messages\": [\n                        {\"role\": \"system\", \"content\": self._construct_system_prompt()},\n                        {\"role\": \"user\", \"content\": self._construct_user_prompt(gap)}\n                    ],\n                    \"temperature\": 0.1  # Low temp for factual precision\n                }\n            )\n            response.raise_for_status()\n            \n            # 4. Parsing\n            content = response.json()[\"choices\"][0][\"message\"][\"content\"]\n            # Extract JSON from potential markdown blocks\n            if \"```json\" in content:\n                content = content.split(\"```json\")[1].split(\"```\")[0]\n            \n            guidance_data = json.loads(content)\n            guidance = ActionableGuidance(**guidance_data)\n            \n            result = ResearchResult(\n                gap_id=cache_key,\n                timestamp=time.time(),\n                guidance=guidance,\n                source_urls=response.json().get(\"citations\", [])\n            )\n\n            # 5. Write Cache\n            cache_file = self.config.cache_dir / f\"{cache_key}.json\"\n            cache_file.write_text(result.model_dump_json(indent=2))\n            \n            return result\n\n        except Exception as e:\n            print(f\"[ACI] Error fetching context: {e}\")\n            raise\n\n# =============================================================================\n# USAGE EXAMPLE\n# =============================================================================\n\nasync def main():\n    fetcher = PrecisionContextFetcher()\n    \n    # Example: We missed a JavaScript IIFE\n    gap = GapProfile(\n        language=\"javascript\",\n        missing_atom=\"LOG.MOD.IIFE\",\n        context_snippet=\"(function() { console.log('I am hidden'); })();\",\n        error_type=\"MISSING_DETECTION\"\n    )\n    \n    result = await fetcher.resolve_gap(gap)\n    print(f\"Strategy Found: {result.guidance.pattern_name}\")\n    print(f\"Tree-Sitter Query: {result.guidance.tree_sitter_query}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n### Integration Points\n\n1.  **Update `aci_config.yaml`**:\n    Add a new budget section for research queries.\n    ```yaml\n    research:\n      model: \"sonar-pro\"\n      max_monthly_budget: 5.00 # USD\n      cache_ttl_hours: 168 # 1 week\n    ```\n\n2.  **Hook into `analyze.py`**:\n    When `analyze.py --verify` identifies a gap (using the Socratic Validator), instead of just logging the error, it can now optionally flag it for \"Deep Research\" if the confidence score is low.\n\n3.  **Knowledge Injection**:\n    The JSON output from `ActionableGuidance` is formatted to be directly copy-pasteable (or auto-merged) into `standard-model-of-code/src/patterns/learned/patterns.json`, closing the feedback loop automatically.",
    "mode": "standard"
  }
}