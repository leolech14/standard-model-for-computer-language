{
  "_meta": {
    "saved_at": "2026-01-23T12:35:19.193143",
    "source": "gemini",
    "model": "gemini-3-pro-preview",
    "query": "TERMINOLOGY AUDIT: We're about to use 'TOPOLOGY' in the Survey/Codome Definition module to describe project structure (Monolith vs Monorepo vs Microservices).\n\nPROBLEM: We already use 'topology' elsewhere in the codebase:\n- topology_reasoning.py uses it for GRAPH topology (Star, Mesh, Islands, Layers)\n- The visualization shows topological patterns of code relationships\n\nQUESTION: Is using 'TOPOLOGY' for project structure (Monolith/Monorepo/Microservices) the RIGHT term, or will it create AMBIGUITY?\n\nIf ambiguous, what's the CORRECT term for:\n1. Graph shape analysis (currently 'topology') - nodes and edges forming patterns\n2. Project structure type (proposed 'topology') - how the repo is organized\n\nWe need ZERO ambiguity. One term, one meaning.\n\nSuggest precise terminology with clear definitions.",
    "query_length": 806,
    "checksum": "sha256:73a848c9df7cb454e2530ca6ce7800901199a3cd5a92d45964e9ce6d27729ea7"
  },
  "response": {
    "content": "**VERDICT: YES, it creates dangerous ambiguity.**\n\nYou should **NOT** use `TOPOLOGY` for project structure (Monolith/Monorepo).\n\nBased on your codebase (`full_analysis.py`, Stage 10), `TOPOLOGY` is already strictly defined as a **Graph Theory** term describing the shape of connectivity (Star, Mesh, Islands). Overloading this term will cause confusion between \"How the repo is organized on disk\" (Monorepo) and \"How the atoms connect in the graph\" (Mesh).\n\nHere is the precise terminology strategy to eliminate ambiguity:\n\n---\n\n### 1. The Conflict (Evidence)\nIn `src/core/full_analysis.py` (lines 1182-1188), you currently have:\n```python\n# Stage 10: Visual Topology Analysis\ntopo = TopologyClassifier()\ntopology_result = topo.classify(nodes, edges)\nfull_output['kpis']['topology_shape'] = topology_result.get('shape', 'UNKNOWN')\n```\nAnd in lines 640-650, nodes are assigned a `topology_role` (hub, root, leaf).\n\nIf you introduce \"Topology\" to mean \"Monorepo\", a developer querying the system might ask: *\"What is the topology?\"*\n*   **Answer A:** \"It's a Monorepo.\" (Project Level)\n*   **Answer B:** \"It's a Mesh with high clustering.\" (Graph Level)\n*   **Result:** Cognitive failure.\n\n---\n\n### 2. The Solution: Terminology Split\n\nKeep **TOPOLOGY** for the graph. Use **ARCHETYPE** for the project structure.\n\n#### A. Graph Shape Analysis → Keep \"TOPOLOGY\"\nThis is the correct mathematical term for the arrangement of nodes and edges.\n*   **Definition:** The layout of connections and flow between code atoms.\n*   **Values:** `Star`, `Mesh`, `Bus`, `Islands`, `Layered_DAG`.\n*   **Context:** Used in `topology_reasoning.py` and visualization layers.\n*   **Code Reference:** `full_analysis.py` lines 1180+.\n\n#### B. Project Structure → Adopt \"ARCHETYPE\"\nAn archetype implies the fundamental model or pattern from which the project is derived. It describes the physical/deployment organization.\n*   **Definition:** The high-level deployment and organizational strategy of the repository.\n*   **Values:** `Monolith`, `Monorepo`, `Microservice`, `Library`, `Polyglot_Container`.\n*   **Context:** Survey/Codome Definition module.\n\n---\n\n### 3. Implementation Guide\n\nHere is how to structure your data models to reflect this separation cleanly.\n\n#### In `Survey/Codome Definition`:\nDo not use `project_topology`. Use `project_archetype`.\n\n```python\n@dataclass\nclass ProjectIdentity:\n    \"\"\"The high-level identity of the codebase.\"\"\"\n    root_path: str\n    \n    # TERMINOLOGY FIX: Use Archetype, not Topology\n    archetype: str  # 'monolith', 'monorepo', 'microservices'\n    \n    languages: List[str]\n    frameworks: List[str]\n```\n\n#### In `UnifiedAnalysisOutput` (src/core/unified_analysis.py):\nUpdate the output schema to distinguish the three layers of structure:\n\n1.  **Archetype** (Physical/Repo structure)\n2.  **Architecture** (Logical Design Patterns)\n3.  **Topology** (Graph Connectivity Shape)\n\n```python\n@dataclass\nclass UnifiedAnalysisOutput:\n    # ... existing fields ...\n\n    # 1. PHYSICAL / ORG STRUCTURE\n    archetype: Dict[str, Any] = field(default_factory=lambda: {\n        \"type\": \"monolith\",  # or monorepo, etc.\n        \"confidence\": 0.0,\n        \"components\": []     # e.g., list of packages in monorepo\n    })\n\n    # 2. LOGICAL DESIGN PATTERNS (Already exists in your code)\n    architecture: Dict[str, Any] = field(default_factory=lambda: {\n        \"detected_patterns\": [], # [\"DDD\", \"MVC\"]\n        \"layer_violations\": []\n    })\n    \n    # 3. GRAPH CONNECTIVITY SHAPE (Computed in Stage 10)\n    topology: Dict[str, Any] = field(default_factory=lambda: {\n        \"shape\": \"mesh\",     # or star, islands\n        \"connectivity_score\": 0.0,\n        \"bottlenecks\": []\n    })\n```\n\n### Summary\n*   **TOPOLOGY** = The **Shape** of the Graph (The \"How it connects\").\n*   **ARCHETYPE** = The **Form** of the Project (The \"What it is\").\n\nUse **ARCHETYPE** for Monolith/Monorepo.",
    "mode": "standard"
  }
}