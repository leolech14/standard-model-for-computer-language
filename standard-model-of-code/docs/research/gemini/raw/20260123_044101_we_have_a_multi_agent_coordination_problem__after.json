{
  "_meta": {
    "saved_at": "2026-01-23T04:41:01.205800",
    "source": "gemini",
    "model": "gemini-2.5-pro",
    "query": "We have a multi-agent coordination problem. After context compaction (session restore), two Claude Code agents both started working on the same task (TASK-103) simultaneously because neither checked the claim system (.agent/tools/claim_task.sh).\n\nExisting infrastructure:\n- .agent/tools/claim_task.sh (atomic mv-based locking)\n- .agent/tools/release_task.sh \n- .agent/tools/check_stale.sh (>30 min detection)\n- .agent/registry/claimed/ directory\n- KERNEL.md boot protocol\n- Task state machine: DISCOVERY → SCOPED → PLANNED → EXECUTING → COMPLETE\n\nThe problem: Context compaction summaries don't preserve claim state, so restored sessions don't know what was in-progress.\n\nQuestions:\n1. How should we modify the boot protocol to prevent this?\n2. Should the claim state be in the summary, or should agents always check on restore?\n3. Generate a Perplexity query to validate this approach against industry best practices for distributed task coordination.",
    "query_length": 952,
    "checksum": "sha256:559a467a1c2ebe693eaa12e82673081f0d669d463787deefe1ffcea1656e4f30"
  },
  "response": {
    "content": "As a senior software engineer, I've analyzed the situation. This is a classic distributed systems problem: a race condition caused by relying on stale, cached state after a disconnect. The core issue is that the context summary is a snapshot, but the task claim system is a live, shared resource.\n\nHere is a multi-layered solution to make your multi-agent system robust against this failure mode.\n\n### Executive Summary\n\nThe root cause is a state synchronization failure. Agents are acting on stale information from a restored context. The solution is **not** to put the claim state in the summary, as that can also become stale instantly.\n\nThe correct approach is to **always treat the file system as the single source of truth for task claims** and to enforce this verification at critical points in the agent lifecycle, especially after session restore.\n\n---\n\n### 1. How to Modify the Boot Protocol\n\nThe `AGENT_BOOT.md` protocol and its associated `boot.sh` script must be enhanced to handle task state verification. This makes checking the claim a non-negotiable part of agent initialization.\n\n#### Proposed Modification to `AGENT_BOOT.md`\n\nAdd a new step to the boot checklist:\n\n```markdown\n### C) Verify Task State\n- [ ] If resuming a task, verify the claim lock is still valid.\n- [ ] If starting a new task, ensure no other task is currently claimed.\n```\n\n#### Proposed `boot.sh` Logic Enhancement\n\nThe boot script should be modified to perform this check automatically.\n\n```bash\n#!/bin/bash\n\n# ... existing boot steps (checking repo root, branch, etc.) ...\n\n# --- NEW: TASK STATE VERIFICATION ---\necho \"Verifying task state...\"\n\n# Assume the task ID is passed to the agent, e.g., via an env var\nif [ -n \"$CURRENT_TASK_ID\" ]; then\n    CLAIM_FILE_PATH=\".agent/registry/claimed/$CURRENT_TASK_ID\"\n    \n    echo \"Agent believes it is working on task: $CURRENT_TASK_ID\"\n\n    if [ -f \"$CLAIM_FILE_PATH\" ]; then\n        # The claim file exists. Check who owns it.\n        OWNER_AGENT_ID=$(cat \"$CLAIM_FILE_PATH\")\n        if [ \"$OWNER_AGENT_ID\" == \"$AGENT_ID\" ]; then\n            echo \"✅ Confirmed: This agent ($AGENT_ID) still holds the claim for task $CURRENT_TASK_ID.\"\n            # Optionally, update a timestamp in the file\n            # echo \"$AGENT_ID:$(date +%s)\" > \"$CLAIM_FILE_PATH\"\n        else\n            echo \"❌ FATAL: Task $CURRENT_TASK_ID was claimed by another agent ($OWNER_AGENT_ID). Aborting.\"\n            exit 1 # Critical failure, stop execution\n        fi\n    else\n        echo \"❌ FATAL: This agent was supposed to be working on $CURRENT_TASK_ID, but the claim lock is missing. The task may have been released or become stale. Aborting.\"\n        exit 1 # Critical failure, stop execution\n    fi\nelse\n    echo \"ℹ️ No current task ID set. Agent is starting fresh.\"\nfi\n\n# --- END OF NEW LOGIC ---\n\n# ... continue with the rest of the boot script ...\n\necho \"✅ Initiation complete. Agent is ready.\"\n```\n\n**Implementation Note:** This requires that each agent has a unique ID (`$AGENT_ID`) and knows the ID of the task it's supposed to be working on (`$CURRENT_TASK_ID`). It also assumes the claim file contains the ID of the claiming agent. Your `claim_task.sh` should be updated to do this: `echo \"$AGENT_ID\" > \".agent/registry/claimed/$TASK_ID\"`.\n\n---\n\n### 2. State in Summary vs. Live Check\n\nYou should **always perform a live check**. Relying on the summary is fundamentally unsafe for resource locking.\n\nHere is a breakdown of the trade-offs:\n\n| Approach | Pros | Cons | Verdict |\n| :--- | :--- | :--- | :--- |\n| **State in Summary (Data-Based)** | - Fast (no I/O on restore)<br>- Agent has immediate knowledge | - **Fundamentally Unsafe**: The summary is stale the moment it's created.<br>- **Race Condition**: Agent A's summary says TASK-103 is free. Milliseconds later, Agent B claims it. Agent A restores and starts work, causing a conflict.<br>- **Complex Reconciliation**: Requires a complex process to handle conflicts when the summary and reality diverge. | **REJECT** |\n| **Live Check (Action-Based)** | - **Always Correct**: Verifies the actual state at the moment of execution.<br>- **Atomic**: The `mv` command in `claim_task.sh` is an atomic operation, preventing two agents from succeeding simultaneously.<br>- **Simple Logic**: The agent's logic is \"try to claim; if fail, stop.\" | - Requires a file system I/O operation on restore.<br>- Slightly slower than reading from memory. | **ACCEPT** |\n\n**Conclusion:** The principle of a **single source of truth** is paramount. The `claimed/` directory *is* the truth. The agent's memory or context is just a cache, and caches must be invalidated or re-verified.\n\n---\n\n### Defense in Depth: Strengthening the Claim System\n\nBeyond the boot protocol, we should harden the entire claim/release process.\n\n#### Layer 1: Improve `claim_task.sh`\n\nThe script should be idempotent and provide clearer feedback. It must handle the case where a task is already claimed.\n\n```bash\n#!/bin/bash\n# .agent/tools/claim_task.sh\n\nTASK_ID=$1\nAGENT_ID=$2 # The ID of the agent trying to claim the task\n\nif [ -z \"$TASK_ID\" ] || [ -z \"$AGENT_ID\" ]; then\n    echo \"Usage: $0 <task_id> <agent_id>\"\n    exit 1\nfi\n\nTASK_FILE=\".agent/registry/scoped/$TASK_ID\"\nCLAIM_DIR=\".agent/registry/claimed\"\nCLAIM_FILE=\"$CLAIM_DIR/$TASK_ID\"\n\nif [ ! -f \"$TASK_FILE\" ]; then\n    # Check if it's already claimed by us\n    if [ -f \"$CLAIM_FILE\" ]; then\n        OWNER_ID=$(cat \"$CLAIM_FILE\")\n        if [ \"$OWNER_ID\" == \"$AGENT_ID\" ]; then\n            echo \"INFO: Task $TASK_ID already claimed by this agent ($AGENT_ID). Refreshing claim.\"\n            # Update timestamp\n            echo \"$AGENT_ID:$(date +%s)\" > \"$CLAIM_FILE\"\n            exit 0 # Success\n        else\n             echo \"ERROR: Task $TASK_ID is already claimed by another agent ($OWNER_ID).\"\n             exit 1 # Failure\n        fi\n    else\n        echo \"ERROR: Task $TASK_ID not found in scoped registry.\"\n        exit 1 # Failure\n    fi\nfi\n\n# Attempt to atomically move the file. This is the core locking mechanism.\nif mv \"$TASK_FILE\" \"$CLAIM_FILE\"; then\n    # On successful move, write owner ID and timestamp to the claim file.\n    echo \"$AGENT_ID:$(date +%s)\" > \"$CLAIM_FILE\"\n    echo \"SUCCESS: Task $TASK_ID claimed by agent $AGENT_ID.\"\n    exit 0 # Success\nelse\n    # This block will likely not be hit due to the checks above, but is a good safeguard.\n    echo \"ERROR: Failed to claim task $TASK_ID. It might have been claimed by another agent simultaneously.\"\n    exit 1 # Failure\nfi\n```\n\n#### Layer 2: Enhance `check_stale.sh` (Dead Man's Switch)\n\nThe `check_stale.sh` script becomes more powerful if the claim file contains a timestamp.\n\n```bash\n#!/bin/bash\n# .agent/tools/check_stale.sh\n\nCLAIM_DIR=\".agent/registry/claimed\"\nSTALE_THRESHOLD_SECONDS=1800 # 30 minutes\nNOW=$(date +%s)\n\nfor claim_file in \"$CLAIM_DIR\"/*; do\n    if [ -f \"$claim_file\" ]; then\n        CONTENT=$(cat \"$claim_file\")\n        TIMESTAMP=$(echo \"$CONTENT\" | cut -d':' -f2)\n        \n        if [ -z \"$TIMESTAMP\" ]; then\n            # Handle old format files without timestamps\n            MOD_TIME=$(stat -f %m \"$claim_file\")\n            TIMESTAMP=$MOD_TIME\n        fi\n\n        AGE=$((NOW - TIMESTAMP))\n\n        if [ \"$AGE\" -gt \"$STALE_THRESHOLD_SECONDS\" ]; then\n            TASK_ID=$(basename \"$claim_file\")\n            OWNER_ID=$(echo \"$CONTENT\" | cut -d':' -f1)\n            echo \"STALE: Task $TASK_ID claimed by $OWNER_ID is stale (age: $AGE seconds). Releasing.\"\n            \n            # Move back to scoped for another agent to pick up\n            mv \"$claim_file\" \".agent/registry/scoped/$TASK_ID\"\n        fi\n    fi\ndone\n```\n\n---\n\n### 3. Perplexity Query Generation\n\nTo validate this approach against industry best practices, here is a well-formed query for Perplexity:\n\n```\nProvide a comprehensive overview of best practices for distributed task coordination and locking in a multi-agent system where agents are stateless workers operating on a shared file system.\n\nContext:\n- Agents are shell-script-based and can be restarted, losing in-memory state (amnesiac property).\n- A file-based locking mechanism is used, where claiming a task is an atomic 'mv' command.\n- The system needs to be resilient to race conditions, especially after an agent restores its session and might have stale knowledge of a task it previously held.\n\nQuestions to answer:\n1. What are the standard design patterns for ensuring only one agent works on a task at a time in this environment (e.g., leader election, distributed locks)? How does an atomic 'mv' fit into these patterns?\n2. Compare the robustness of two approaches for state synchronization after an agent restores:\n   a) Storing claim status in a context summary that is restored with the agent.\n   b) Forcing the agent to always perform a live check-and-claim against the file system after restore.\n3. What are the pitfalls of file-based locking (e.g., stale locks)?\n4. Propose a \"defense in depth\" strategy, including mechanisms like heartbeats (timestamp updates) and stale lock detection (reapers/janitors), to make the system fault-tolerant.\n5. Provide code examples or pseudo-code in shell script for implementing an idempotent and robust task claiming function.\n```",
    "mode": "standard"
  }
}