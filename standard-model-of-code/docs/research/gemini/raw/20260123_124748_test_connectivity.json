{
  "_meta": {
    "saved_at": "2026-01-23T12:47:48.034965",
    "source": "gemini",
    "model": "gemini-3-pro-preview",
    "query": "Test connectivity",
    "query_length": 17,
    "checksum": "sha256:7a31af5c9cbee67c6d710a6fbdeeec6d01ed8cbbffb10930ca44eda671033d7f"
  },
  "response": {
    "content": "Based on the provided codebase, the system \"tests connectivity\" (analyzes relationships between code elements) primarily through the **Edge Extractor** and **Graph Analyzer** modules.\n\nHere is an analysis of how connectivity is determined, tested, and classified in this codebase:\n\n### 1. Edge Detection (Connectivity Source)\nThe core logic for establishing connectivity resides in `src/core/edge_extractor.py`. It uses a \"Strategy Pattern\" to handle polyglot analysis:\n\n*   **Extraction Strategies**:\n    *   **Python**: Uses both Regex (`PythonEdgeStrategy`) and Tree-sitter AST (`PythonTreeSitterStrategy`) to find function calls (`calls`), attribute usage (`uses`), and class inheritance (`inherits`).\n    *   **JavaScript/TypeScript**: Handles complex module resolution (`JSModuleResolver`) to track imports, `window` exports, and method calls.\n    *   **Go/Rust**: Regex-based heuristic extraction.\n*   **Edge Types**:\n    *   `imports`: Dependency management.\n    *   `calls`: Control flow.\n    *   `inherits`: Object-oriented hierarchy.\n    *   `contains`: Structural hierarchy (File -> Class -> Method).\n    *   `exposes`: Public API boundaries.\n\n### 2. Disconnection Analysis (Connectivity Gaps)\nIn `src/core/full_analysis.py`, the system explicitly tests for *lack* of connectivity using `classify_disconnection`. It replaces a simple \"orphan\" label with a taxonomy:\n\n*   **Test Entry**: Connectivity is missing because it's a test file (e.g., `test_*.py`).\n*   **Entry Point**: It's a `main` function or CLI script.\n*   **Framework Managed**: Connectivity is implicit via decorators (e.g., `@app.route`, `@dataclass`).\n*   **Cross-Language**: Called from HTML/Frontend (e.g., `.vue`, `.svelte`).\n*   **Dynamic Dispatch**: Used via `getattr` or reflection.\n\n### 3. Graph Topology (Connectivity Health)\nThe `src/core/graph_analyzer.py` and `src/core/full_analysis.py` modules run analytics to \"test\" the quality of the connectivity:\n\n*   **Knot Detection**: checks for cycles (`detect_knots`) and bidirectional coupling (\"tangles\").\n*   **Bridge Detection**: Identifies edges that, if removed, would disconnect the graph (`find_bridges`).\n*   **Bottlenecks**: Uses Betweenness Centrality to find nodes that act as connectivity chokepoints.\n\n### 4. Codome Boundaries (Synthetic Connectivity)\nTo fix \"false\" disconnections, `create_codome_boundaries` in `full_analysis.py` generates synthetic edges:\n*   Creates **Codome Boundary** nodes (e.g., `__codome__::pytest`).\n*   Injects inferred edges to nodes that appear isolated but are actually reached via frameworks or external events.\n\n### Summary\nThe codebase verifies connectivity by:\n1.  **Extracting** explicit references (imports/calls).\n2.  **Classifying** why nodes might be disconnected (Disconnection Taxonomy).\n3.  **Inferring** implicit connections (Codome Boundaries).\n4.  **Measuring** the topology (Knots/Bridges).",
    "mode": "standard"
  }
}