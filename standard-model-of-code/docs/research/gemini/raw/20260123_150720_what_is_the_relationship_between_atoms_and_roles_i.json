{
  "_meta": {
    "saved_at": "2026-01-23T15:07:20.141482",
    "source": "gemini",
    "model": "gemini-2.0-flash-001",
    "query": "What is the relationship between atoms and roles in this project?",
    "query_length": 65,
    "checksum": "sha256:e2848dfdc7379f4c2c946b191b7e47500cea67ab265bb47622783449d8f294f5"
  },
  "response": {
    "content": "```tool_code\nfrom collections import Counter\nimport json\n\ndef analyze_atoms_and_roles(file_path=\"standard-model-of-code/docs/MODEL.md\"):\n    \"\"\"\n    Analyzes the relationship between atoms and roles in the project based on the provided context.\n    \"\"\"\n    \n    try:\n        # Load the MODEL.md file to understand the theoretical relationship\n        with open(file_path, \"r\") as f:\n            model_md = f.read()\n        \n        # This is a VERY high-level theoretical relationship\n        # The relationship is further defined within the code and schema (see below)\n        theoretical_relationship = \"\"\"\n        Atoms and roles are fundamental building blocks of the Standard Model of Code. \n        Atoms represent the 'WHAT' (syntactic element) and roles represent the 'WHY' (semantic purpose).\n        They are distinct but linked: every atom is classified with a role.\n        \"\"\"\n    except FileNotFoundError:\n        theoretical_relationship = \"MODEL.md not found\"\n\n    # Load relevant schema and code files to understand implemented relationships\n    # There are many dimensions and relationships defined in the code so it is\n    # important to check the schema and code to see how these are related.\n    \n    # Enumerate the atoms\n    def get_atoms(file_path=\"standard-model-of-code/schema/fixed/atoms.json\"):\n        try:\n             with open(file_path, \"r\") as f:\n                atoms = json.load(f)\n             num_atoms = len(atoms.get(\"atoms\", {})) if atoms else 0\n             return num_atoms, file_path\n        except:\n            return 0, \"standard-model-of-code/schema/fixed/atoms.json\"\n\n    num_atoms, atoms_file = get_atoms()\n\n    # Enumerate the roles\n    def get_roles(file_path=\"standard-model-of-code/schema/fixed/roles.json\"):\n        try:\n            with open(file_path, \"r\") as f:\n                roles = json.load(f)\n            num_roles = len(roles.get(\"roles\", {})) if roles else 0\n            return num_roles, file_path\n        except:\n            return 0, \"standard-model-of-code/schema/fixed/roles.json\"\n    num_roles, roles_file = get_roles()\n\n    # Relationship in code\n    classification_code = \"\"\"\n     # Standard Model of Code project - Atoms and Roles\n     For each code element (particle), a 'what' (atom) is paired with a 'why' (role).\n     A 4 dimensional space is constructed:\n       - WHAT: What type of atom is this?\n       - LAYER: Architectural layer\n       - ROLE: Semantic role (from 33 canonical roles)\n       - TRUST: Trust level (0-100)\n    \"\"\"\n\n    ###\n    from collections import defaultdict\n    import re\n\n    def extract_code_from_file(file_path: str) -> str:\n        \"\"\"Extract code from a file, returning empty string on failure\"\"\"\n        try:\n            with open(file_path, 'r') as f:\n                return f.read()\n        except FileNotFoundError:\n            return \"\"\n\n    def extract_dependencies(file_content: str) -> list[str]:\n        \"\"\"Extract import statements from the code\"\"\"\n        import_list = []\n        for line in file_content.splitlines():\n            if line.strip().startswith((\"import \", \"from \")):\n                import_list.append(line.strip())\n        return import_list\n\n    # ---------------------------------------------------------\n    # Extract imports from the specified code (This is for the report)\n    # ---------------------------------------------------------\n\n    file_content = extract_code_from_file(\"standard-model-of-code/src/core/unified_analysis.py\")\n    imports = extract_dependencies(file_content)\n\n    # ---------------------------------------------------------\n    # Extract the most common atom by type\n    # ---------------------------------------------------------\n    def get_most_common_atom_by_type(file_path=\"standard-model-of-code/src/core/full_analysis.py\"):\n      most_common_atom_by_type = \"\"\n      body = extract_code_from_file(file_path)\n      atom_matches = re.findall(r\"n\\['atom'] = '([^']+)'\", body)\n      if atom_matches:\n        atom_counts = Counter(atom_matches)\n        top = atom_counts.most_common(1)\n        if top:\n          most_common_atom_by_type = top[0][0]\n      return most_common_atom_by_type\n\n    most_common_atom_by_type = get_most_common_atom_by_type()\n\n    report = f\"\"\"\n## Relationship between Atoms and Roles\n\n{theoretical_relationship}\n\nThe project uses {num_atoms} atoms (defined in {atoms_file}) and {num_roles} roles (defined in {roles_file}).\n\nIn the code, a typical particle is classified with a 'what' (atom) and a 'why' (role). This relationship is codified in the _derive_dimensions in the `universal_classifier.py`.  \n\nThe most common atom is: {most_common_atom_by_type}\n\nCode Description:\n```code\n{classification_code}\n```\n\n\"\"\"\n\n    return report\n\nanalysis = analyze_atoms_and_roles()\nprint(analysis)\n```",
    "mode": "flash_deep"
  }
}