{
  "_meta": {
    "saved_at": "2026-01-23T09:10:33.062080",
    "source": "gemini",
    "model": "gemini-3-pro-preview",
    "query": "You are auditing the ACI (Adaptive Context Intelligence) module - the 'curriculum compiler' that prepares context for AI queries.\n\nCURRENT STATE:\n- ACI has 4 files: query_analyzer.py, tier_router.py, context_optimizer.py, feedback_loop.py\n- Only analyze.py imports ACI\n- aci_config.yaml exists but values are HARDCODED in code (not read from config)\n- No dedicated documentation (only docstrings)\n- Not connected to: HSL (validation), Perplexity (research), BARE (truths system)\n\nQUESTION:\n1. What documentation should ACI have? (filename, sections, purpose)\n2. How should aci_config.yaml be wired up?\n3. How should ACI connect to sibling subsystems (HSL, Perplexity, BARE)?\n4. What's the minimal viable integration to make ACI a true orchestrator?\n\nBe specific. Give file paths and code patterns.",
    "query_length": 797,
    "checksum": "sha256:d2f4bb9ca875d8ae33a5a70a0c5b24f8d9e30c9ce0b14fea54422f732e9af71b"
  },
  "response": {
    "content": "This is a critical architectural audit. The ACI module is currently operating as a \"stub\" rather than the intelligence engine described in `aci_config.yaml`. To elevate it from a hardcoded heuristic script to a true **Adaptive Context Intelligence**, we need to externalize configuration and formalize the interfaces.\n\nHere is the remediation plan.\n\n### 1. Documentation Architecture\n\n**Filename:** `context-management/docs/specs/ACI_ARCHITECTURE.md`\n\nThis document defines the \"Brain's Routing Protocol.\" It must be distinct from `TOOL.md` (which describes the CLI) and `THEORY.md` (which describes the data).\n\n**Required Sections:**\n1.  **Routing Logic:** How `query_analyzer.py` calculates `complexity_score` and maps it to Tiers defined in `aci_config.yaml`.\n2.  **Context Injection Strategy:** How `context_optimizer.py` selects between `minimal`, `standard`, and `full` agent contexts based on the keywords in `aci_config.yaml`.\n3.  **The Feedback Loop:** How `feedback_loop.py` writes to `.agent/intelligence/aci_feedback.yaml` to tune thresholds over time.\n4.  **Interface Contract:** The input/output signature expected by `analyze.py`.\n\n### 2. Wiring `aci_config.yaml` (The Fix)\n\nCurrently, `tier_router.py` likely has `if complexity > 5: return 'long_context'`. This must change to read from the YAML.\n\n**Step A: Create a Config Loader**\nAdd a utility method in `context-management/tools/ai/aci/utils.py` (or inside `query_analyzer.py` if keeping file count low):\n\n```python\nimport yaml\nfrom pathlib import Path\n\n# Path to the config provided in context\nCONFIG_PATH = Path(\"context-management/config/aci_config.yaml\")\n\ndef load_aci_config():\n    if not CONFIG_PATH.exists():\n        raise FileNotFoundError(f\"ACI Config missing at {CONFIG_PATH}\")\n    \n    with open(CONFIG_PATH, 'r') as f:\n        return yaml.safe_load(f)\n\n# Global singleton to prevent re-reading every query\nACI_CONFIG = load_aci_config()\n```\n\n**Step B: Refactor `tier_router.py`**\nStop using magic numbers. Use the loaded config.\n\n```python\nfrom .utils import ACI_CONFIG\n\ndef route_tier(query_metrics):\n    # 1. Check Overrides (Fastest)\n    query_text = query_metrics['text'].lower()\n    for tier, patterns in ACI_CONFIG['routing_overrides'].items():\n        if any(p.replace('*', '') in query_text for p in patterns):\n            return tier\n\n    # 2. Check Complexity Thresholds (Logic derived from config)\n    # Note: You'll need to map config descriptions to logic, or add explicit \n    # score thresholds to the yaml in a future update. \n    # For now, map intent to tiers defined in config:\n    \n    if query_metrics['is_external_scope']:\n        return \"perplexity\" # As defined in config\n        \n    if query_metrics['requires_reasoning']:\n        return \"long_context\"\n        \n    return \"rag\" # Default fallthrough\n```\n\n### 3. Sibling Subsystem Connection Strategy\n\nACI must act as the **Dispatcher**, identifying the intent and delegating to the specialized subsystem via `analyze.py`.\n\n**A. HSL (Holographic-Socratic Layer)**\n*   **Trigger:** `query_analyzer.py` detects keywords from `aci_config.yaml` -> `intent_keywords.architecture` or explicit `--verify` flags.\n*   **Action:** ACI returns a `routing_instruction` object.\n*   **Implementation:**\n    ```python\n    # In query_analyzer.py\n    if any(k in query for k in ACI_CONFIG['intent_keywords']['architecture']):\n        return {\n            \"tier\": \"socratic\",\n            \"context_set\": \"architecture_review\",\n            \"validation_mode\": True \n        }\n    ```\n\n**B. Perplexity (External Research)**\n*   **Trigger:** `query_analyzer.py` checks `ACI_CONFIG['external_indicators']` (e.g., \"latest\", \"2026\", \"best practice\").\n*   **Action:** ACI routes to `perplexity` tier.\n*   **Implementation:**\n    ```python\n    # In tier_router.py\n    external_triggers = ACI_CONFIG['external_indicators']\n    if any(t in query for t in external_triggers):\n        return \"perplexity\" \n    ```\n\n**C. BARE (Background Auto-Refinement Engine)**\n*   **Trigger:** Keywords like \"truth\", \"drift\", \"confidence\" (from `ACI_CONFIG['agent_context']['trigger_keywords']`).\n*   **Action:** `context_optimizer.py` injects the `agent_intelligence` Analysis Set.\n*   **Implementation:**\n    ```python\n    # In context_optimizer.py\n    def get_context_mix(query):\n        triggers = ACI_CONFIG['agent_context']['trigger_keywords']\n        if any(t in query for t in triggers):\n            # Dynamic injection of BARE truths\n            return [\"agent_intelligence\", \"agent_kernel\"] \n        return [\"agent_kernel\"] # Default\n    ```\n\n### 4. Minimal Viable Integration (The Orchestrator Pattern)\n\nTo make ACI the true orchestrator without rewriting `analyze.py` entirely, implement this **Facade Pattern** in `analyze.py`:\n\n**Current (Likely State):**\n```python\n# analyze.py\nimport tier_router\ntier = tier_router.get_tier(query)\nif tier == 'rag': ...\n```\n\n**Proposed MVI (The Orchestrator):**\n\nModify `context-management/tools/ai/analyze.py` to use a unified entry point.\n\n1.  **Create `ACIResult` DTO:**\n    ```python\n    @dataclass\n    class ACIResult:\n        tier: str              # 'rag', 'long_context', 'perplexity', 'socratic'\n        analysis_sets: List[str] # ['pipeline', 'agent_intelligence']\n        token_budget: int      # From aci_config.yaml token_budgets\n        system_prompt_modifier: str # e.g., \"You are a FORENSIC ANALYST...\"\n    ```\n\n2.  **Update `analyze.py` Main Loop:**\n    ```python\n    from context_management.tools.ai.aci import orchestrator\n\n    def analyze(query, ...):\n        # 1. ACI decides the strategy\n        plan: ACIResult = orchestrator.compile_plan(query)\n\n        print(f\"ðŸ§  ACI Plan: Tier={plan.tier}, Budget={plan.token_budget}\")\n\n        # 2. Execute based on plan\n        if plan.tier == 'perplexity':\n            return run_perplexity(query)\n        elif plan.tier == 'socratic':\n            return run_socratic_validation(plan.analysis_sets)\n        else:\n            # Standard Gemini/RAG path\n            context = build_context(plan.analysis_sets, plan.token_budget)\n            return run_llm(context, query)\n    ```\n\n**Specific Action Items for You:**\n1.  Create `context-management/docs/specs/ACI_ARCHITECTURE.md`.\n2.  Add config loading logic to `context-management/tools/ai/aci/__init__.py` or a util file to expose `ACI_CONFIG`.\n3.  Update `query_analyzer.py` to read `intent_keywords` from that config object.\n4.  Modify `analyze.py` to accept an `ACIResult` object rather than raw strings.",
    "mode": "standard"
  }
}