# Research: list the stages

> **Date:** 2026-01-23 18:28:51
> **Source:** gemini
> **Model:** gemini-2.0-flash-001
> **Checksum:** `sha256:ab0523d743bb06c639f5c3df9f717b9db35cb9f6d98e8a45076facff1fa64644`
> **Raw JSON:** `raw/20260123_182851_list_the_stages.json`

---

## Query

list the stages

---

## Response

Okay, I can help you with that. Based on the provided codebase, particularly the `full_analysis.py` file, here's a list of the stages in the Collider full analysis pipeline:

1.  **Survey**: Pre-Analysis Intelligence (Phase 10) - This stage surveys the target codebase to gather initial information and determine exclusion paths.

2.  **Base Analysis**: This stage performs the initial AST parsing and extracts raw particles using `tree_sitter_engine.py`.

3.  **Standard Model Enrichment**: This stage enriches the nodes with Standard Model concepts.

4.  **Ecosystem Discovery**: This stage discovers unknown ecosystem patterns.

5.  **Octahedral Dimension Classification**: This stage classifies nodes based on octahedral dimensions (D4, D5, D7).

6.  **Scope Analysis**: This stage analyzes the scope of variables (definitions, references, unused, shadowing).

7.  **Control Flow Metrics**: This stage calculates control flow metrics like cyclomatic complexity and nesting depth.

8.  **Pattern-Based Atom Detection**: This stage detects atoms based on code patterns.

9.  **Data Flow Analysis**: This stage analyzes data flow (D6:EFFECT) and determines the purity of functions.

10. **Purpose Field**: This stage detects the purpose of different code elements.

11. **π₃ (Organelle Purpose)**: This stage computes the purpose of containers (organelles).

12. **π₄ (System Purpose)**: This stage computes the system purpose of files.

13. **Execution Flow**: This stage detects entry points and orphans in the code.

14. **Markov Transition Matrix**: This stage computes the Markov transition matrix to analyze call graph transitions.

15. **Knot/Cycle Detection**: This stage detects dependency knots and cycles in the graph.

16. **Graph Analytics**: This stage performs various graph analytics calculations.

17. **Statistical Metrics**: This stage computes various statistical metrics like entropy, complexity, and Halstead metrics.

18. **Codome Boundary Generation**: This stage generates codome boundaries to represent external calling contexts and infers edges to disconnected nodes.

19. **Data Flow Analysis**: This stage analyzes data flow patterns across the codebase.

20. **Performance Prediction**: This stage predicts performance characteristics of the code.

21. **Constraint Field Validation**: This stage validates the codebase against defined constraints.

22. **Purpose Intelligence**: This stage enriches nodes with purpose intelligence.

23. **Roadmap Evaluation**: This stage evaluates the codebase against a specified roadmap.

24. **Visual Topology Analysis**: This stage classifies the visual topology of the codebase.

25. **Semantic Cortex**: This stage extracts concepts from the codebase.

26. **AI Insights Generation**: (Optional) This stage generates AI-driven insights using Vertex AI.

27. **Output Generation**: This stage generates the final output files, including the LLM-oriented JSON and the human-readable HTML report.

It's worth noting that some stages are conditional (e.g., LLM Enrichment, Roadmap Evaluation) and might be skipped based on the provided options. Also, the file-centric view is built as part of the output generation phase. Some stages that were present in earlier versions have been removed, such as "Orphan Integration Analysis".


---

## Citations

_No citations provided_
